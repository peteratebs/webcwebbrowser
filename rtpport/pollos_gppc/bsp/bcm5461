#ifndef __SUNGEM_PHY_H__
  2 #define __SUNGEM_PHY_H__
  3 
  4 struct mii_phy;
  5 
  6 /* Operations supported by any kind of PHY */
  7 struct mii_phy_ops
  8 {
  9         int             (*init)(struct mii_phy *phy);
 10         int             (*suspend)(struct mii_phy *phy);
 11         int             (*setup_aneg)(struct mii_phy *phy, u32 advertise);
 12         int             (*setup_forced)(struct mii_phy *phy, int speed, int fd);
 13         int             (*poll_link)(struct mii_phy *phy);
 14         int             (*read_link)(struct mii_phy *phy);
 15         int             (*enable_fiber)(struct mii_phy *phy, int autoneg);
 16 };
 17 
 18 /* Structure used to statically define an mii/gii based PHY */
 19 struct mii_phy_def
 20 {
 21         u32                             phy_id;         /* Concatenated ID1 << 16 | ID2 */
 22         u32                             phy_id_mask;    /* Significant bits */
 23         u32                             features;       /* Ethtool SUPPORTED_* defines */
 24         int                             magic_aneg;     /* Autoneg does all speed test for us */
 25         const char*                     name;
 26         const struct mii_phy_ops*       ops;
 27 };
 28 
 29 enum {
 30         BCM54XX_COPPER,
 31         BCM54XX_FIBER,
 32         BCM54XX_GBIC,
 33         BCM54XX_SGMII,
 34         BCM54XX_UNKNOWN,
 35 };
 36 
 37 /* An instance of a PHY, partially borrowed from mii_if_info */
 38 struct mii_phy
 39 {
 40         struct mii_phy_def*     def;
 41         u32                     advertising;
 42         int                     mii_id;
 43 
 44         /* 1: autoneg enabled, 0: disabled */
 45         int                     autoneg;
 46 
 47         /* forced speed & duplex (no autoneg)
 48          * partner speed & duplex & pause (autoneg)
 49          */
 50         int                     speed;
 51         int                     duplex;
 52         int                     pause;
 53 
 54         /* Provided by host chip */
 55         struct net_device       *dev;
 56         int (*mdio_read) (struct net_device *dev, int mii_id, int reg);
 57         void (*mdio_write) (struct net_device *dev, int mii_id, int reg, int val);
 58         void                    *platform_data;
 59 };
 60 
 61 /* Pass in a struct mii_phy with dev, mdio_read and mdio_write
 62  * filled, the remaining fields will be filled on return
 63  */
 64 extern int mii_phy_probe(struct mii_phy *phy, int mii_id);
 65 
 66 
 67 /* MII definitions missing from mii.h */
 68 
 69 #define BMCR_SPD2       0x0040          /* Gigabit enable (bcm54xx)     */
 70 #define LPA_PAUSE       0x0400
 71 
 72 /* More PHY registers (model specific) */
 73 
 74 /* MII BCM5201 MULTIPHY interrupt register */
 75 #define MII_BCM5201_INTERRUPT                   0x1A
 76 #define MII_BCM5201_INTERRUPT_INTENABLE         0x4000
 77 
 78 #define MII_BCM5201_AUXMODE2                    0x1B
 79 #define MII_BCM5201_AUXMODE2_LOWPOWER           0x0008
 80 
 81 #define MII_BCM5201_MULTIPHY                    0x1E
 82 
 83 /* MII BCM5201 MULTIPHY register bits */
 84 #define MII_BCM5201_MULTIPHY_SERIALMODE         0x0002
 85 #define MII_BCM5201_MULTIPHY_SUPERISOLATE       0x0008
 86 
 87 /* MII BCM5221 Additional registers */
 88 #define MII_BCM5221_TEST                        0x1f
 89 #define MII_BCM5221_TEST_ENABLE_SHADOWS         0x0080
 90 #define MII_BCM5221_SHDOW_AUX_STAT2             0x1b
 91 #define MII_BCM5221_SHDOW_AUX_STAT2_APD         0x0020
 92 #define MII_BCM5221_SHDOW_AUX_MODE4             0x1a
 93 #define MII_BCM5221_SHDOW_AUX_MODE4_IDDQMODE    0x0001
 94 #define MII_BCM5221_SHDOW_AUX_MODE4_CLKLOPWR    0x0004
 95 
 96 /* MII BCM5241 Additional registers */
 97 #define MII_BCM5241_SHDOW_AUX_MODE4_STANDBYPWR  0x0008
 98 
 99 /* MII BCM5400 1000-BASET Control register */
100 #define MII_BCM5400_GB_CONTROL                  0x09
101 #define MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP    0x0200
102 
103 /* MII BCM5400 AUXCONTROL register */
104 #define MII_BCM5400_AUXCONTROL                  0x18
105 #define MII_BCM5400_AUXCONTROL_PWR10BASET       0x0004
106 
107 /* MII BCM5400 AUXSTATUS register */
108 #define MII_BCM5400_AUXSTATUS                   0x19
109 #define MII_BCM5400_AUXSTATUS_LINKMODE_MASK     0x0700
110 #define MII_BCM5400_AUXSTATUS_LINKMODE_SHIFT    8
111 
112 /* 1000BT control (Marvell & BCM54xx at least) */
113 #define MII_1000BASETCONTROL                    0x09
114 #define MII_1000BASETCONTROL_FULLDUPLEXCAP      0x0200
115 #define MII_1000BASETCONTROL_HALFDUPLEXCAP      0x0100
116 
117 /* Marvell 88E1011 PHY control */
118 #define MII_M1011_PHY_SPEC_CONTROL              0x10
119 #define MII_M1011_PHY_SPEC_CONTROL_MANUAL_MDIX  0x20
120 #define MII_M1011_PHY_SPEC_CONTROL_AUTO_MDIX    0x40
121 
122 /* Marvell 88E1011 PHY status */
123 #define MII_M1011_PHY_SPEC_STATUS               0x11
124 #define MII_M1011_PHY_SPEC_STATUS_1000          0x8000
125 #define MII_M1011_PHY_SPEC_STATUS_100           0x4000
126 #define MII_M1011_PHY_SPEC_STATUS_SPD_MASK      0xc000
127 #define MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX    0x2000
128 #define MII_M1011_PHY_SPEC_STATUS_RESOLVED      0x0800
129 #define MII_M1011_PHY_SPEC_STATUS_TX_PAUSE      0x0008
130 #define MII_M1011_PHY_SPEC_STATUS_RX_PAUSE      0x0004
131 
132 #endif /* __SUNGEM_PHY_H__ */
133 


~ [ source navigation ] ~ [ diff markup ] ~ [ identifier search ] ~ [ freetext search ] ~ [ file search ] ~ 
TOMOYO Linux Cross Reference
Linux/drivers/net/sungem_phy.c 
Version: ~ [ linux-2.6.25-ccs-1.6.1 ] ~ [ linux-2.6.25-ccs-1.5.4 ] ~ [ linux-2.4.36-ccs-1.5.4 ] ~ [ ccstools-1.6.1 ] ~ [ ccstools-1.5.4 ] ~ [ policy-sample ] ~ 
Architecture: ~ [ i386 ] ~ [ alpha ] ~ [ m68k ] ~ [ mips ] ~ [ ppc ] ~ [ sparc ] ~ [ sparc64 ] ~ 


--------------------------------------------------------------------------------

  1 /*
  2  * PHY drivers for the sungem ethernet driver.
  3  *
  4  * This file could be shared with other drivers.
  5  *
  6  * (c) 2002-2007, Benjamin Herrenscmidt (benh@kernel.crashing.org)
  7  *
  8  * TODO:
  9  *  - Add support for PHYs that provide an IRQ line
 10  *  - Eventually moved the entire polling state machine in
 11  *    there (out of the eth driver), so that it can easily be
 12  *    skipped on PHYs that implement it in hardware.
 13  *  - On LXT971 & BCM5201, Apple uses some chip specific regs
 14  *    to read the link status. Figure out why and if it makes
 15  *    sense to do the same (magic aneg ?)
 16  *  - Apple has some additional power management code for some
 17  *    Broadcom PHYs that they "hide" from the OpenSource version
 18  *    of darwin, still need to reverse engineer that
 19  */
 20 
 21 
 22 #include <linux/module.h>
 23 
 24 #include <linux/kernel.h>
 25 #include <linux/types.h>
 26 #include <linux/netdevice.h>
 27 #include <linux/etherdevice.h>
 28 #include <linux/mii.h>
 29 #include <linux/ethtool.h>
 30 #include <linux/delay.h>
 31 
 32 #ifdef CONFIG_PPC_PMAC
 33 #include <asm/prom.h>
 34 #endif
 35 
 36 #include "sungem_phy.h"
 37 
 38 /* Link modes of the BCM5400 PHY */
 39 static const int phy_BCM5400_link_table[8][3] = {
 40         { 0, 0, 0 },    /* No link */
 41         { 0, 0, 0 },    /* 10BT Half Duplex */
 42         { 1, 0, 0 },    /* 10BT Full Duplex */
 43         { 0, 1, 0 },    /* 100BT Half Duplex */
 44         { 0, 1, 0 },    /* 100BT Half Duplex */
 45         { 1, 1, 0 },    /* 100BT Full Duplex*/
 46         { 1, 0, 1 },    /* 1000BT */
 47         { 1, 0, 1 },    /* 1000BT */
 48 };
 49 
 50 static inline int __phy_read(struct mii_phy* phy, int id, int reg)
 51 {
 52         return phy->mdio_read(phy->dev, id, reg);
 53 }
 54 
 55 static inline void __phy_write(struct mii_phy* phy, int id, int reg, int val)
 56 {
 57         phy->mdio_write(phy->dev, id, reg, val);
 58 }
 59 
 60 static inline int phy_read(struct mii_phy* phy, int reg)
 61 {
 62         return phy->mdio_read(phy->dev, phy->mii_id, reg);
 63 }
 64 
 65 static inline void phy_write(struct mii_phy* phy, int reg, int val)
 66 {
 67         phy->mdio_write(phy->dev, phy->mii_id, reg, val);
 68 }
 69 
 70 static int reset_one_mii_phy(struct mii_phy* phy, int phy_id)
 71 {
 72         u16 val;
 73         int limit = 10000;
 74 
 75         val = __phy_read(phy, phy_id, MII_BMCR);
 76         val &= ~(BMCR_ISOLATE | BMCR_PDOWN);
 77         val |= BMCR_RESET;
 78         __phy_write(phy, phy_id, MII_BMCR, val);
 79 
 80         udelay(100);
 81 
 82         while (limit--) {
 83                 val = __phy_read(phy, phy_id, MII_BMCR);
 84                 if ((val & BMCR_RESET) == 0)
 85                         break;
 86                 udelay(10);
 87         }
 88         if ((val & BMCR_ISOLATE) && limit > 0)
 89                 __phy_write(phy, phy_id, MII_BMCR, val & ~BMCR_ISOLATE);
 90 
 91         return (limit <= 0);
 92 }
 93 
 94 static int bcm5201_init(struct mii_phy* phy)
 95 {
 96         u16 data;
 97 
 98         data = phy_read(phy, MII_BCM5201_MULTIPHY);
 99         data &= ~MII_BCM5201_MULTIPHY_SUPERISOLATE;
100         phy_write(phy, MII_BCM5201_MULTIPHY, data);
101 
102         phy_write(phy, MII_BCM5201_INTERRUPT, 0);
103 
104         return 0;
105 }
106 
107 static int bcm5201_suspend(struct mii_phy* phy)
108 {
109         phy_write(phy, MII_BCM5201_INTERRUPT, 0);
110         phy_write(phy, MII_BCM5201_MULTIPHY, MII_BCM5201_MULTIPHY_SUPERISOLATE);
111 
112         return 0;
113 }
114 
115 static int bcm5221_init(struct mii_phy* phy)
116 {
117         u16 data;
118 
119         data = phy_read(phy, MII_BCM5221_TEST);
120         phy_write(phy, MII_BCM5221_TEST,
121                 data | MII_BCM5221_TEST_ENABLE_SHADOWS);
122 
123         data = phy_read(phy, MII_BCM5221_SHDOW_AUX_STAT2);
124         phy_write(phy, MII_BCM5221_SHDOW_AUX_STAT2,
125                 data | MII_BCM5221_SHDOW_AUX_STAT2_APD);
126 
127         data = phy_read(phy, MII_BCM5221_SHDOW_AUX_MODE4);
128         phy_write(phy, MII_BCM5221_SHDOW_AUX_MODE4,
129                 data | MII_BCM5221_SHDOW_AUX_MODE4_CLKLOPWR);
130 
131         data = phy_read(phy, MII_BCM5221_TEST);
132         phy_write(phy, MII_BCM5221_TEST,
133                 data & ~MII_BCM5221_TEST_ENABLE_SHADOWS);
134 
135         return 0;
136 }
137 
138 static int bcm5221_suspend(struct mii_phy* phy)
139 {
140         u16 data;
141 
142         data = phy_read(phy, MII_BCM5221_TEST);
143         phy_write(phy, MII_BCM5221_TEST,
144                 data | MII_BCM5221_TEST_ENABLE_SHADOWS);
145 
146         data = phy_read(phy, MII_BCM5221_SHDOW_AUX_MODE4);
147         phy_write(phy, MII_BCM5221_SHDOW_AUX_MODE4,
148                   data | MII_BCM5221_SHDOW_AUX_MODE4_IDDQMODE);
149 
150         return 0;
151 }
152 
153 static int bcm5241_init(struct mii_phy* phy)
154 {
155         u16 data;
156 
157         data = phy_read(phy, MII_BCM5221_TEST);
158         phy_write(phy, MII_BCM5221_TEST,
159                 data | MII_BCM5221_TEST_ENABLE_SHADOWS);
160 
161         data = phy_read(phy, MII_BCM5221_SHDOW_AUX_STAT2);
162         phy_write(phy, MII_BCM5221_SHDOW_AUX_STAT2,
163                 data | MII_BCM5221_SHDOW_AUX_STAT2_APD);
164 
165         data = phy_read(phy, MII_BCM5221_SHDOW_AUX_MODE4);
166         phy_write(phy, MII_BCM5221_SHDOW_AUX_MODE4,
167                 data & ~MII_BCM5241_SHDOW_AUX_MODE4_STANDBYPWR);
168 
169         data = phy_read(phy, MII_BCM5221_TEST);
170         phy_write(phy, MII_BCM5221_TEST,
171                 data & ~MII_BCM5221_TEST_ENABLE_SHADOWS);
172 
173         return 0;
174 }
175 
176 static int bcm5241_suspend(struct mii_phy* phy)
177 {
178         u16 data;
179 
180         data = phy_read(phy, MII_BCM5221_TEST);
181         phy_write(phy, MII_BCM5221_TEST,
182                 data | MII_BCM5221_TEST_ENABLE_SHADOWS);
183 
184         data = phy_read(phy, MII_BCM5221_SHDOW_AUX_MODE4);
185         phy_write(phy, MII_BCM5221_SHDOW_AUX_MODE4,
186                   data | MII_BCM5241_SHDOW_AUX_MODE4_STANDBYPWR);
187 
188         return 0;
189 }
190 
191 static int bcm5400_init(struct mii_phy* phy)
192 {
193         u16 data;
194 
195         /* Configure for gigabit full duplex */
196         data = phy_read(phy, MII_BCM5400_AUXCONTROL);
197         data |= MII_BCM5400_AUXCONTROL_PWR10BASET;
198         phy_write(phy, MII_BCM5400_AUXCONTROL, data);
199 
200         data = phy_read(phy, MII_BCM5400_GB_CONTROL);
201         data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
202         phy_write(phy, MII_BCM5400_GB_CONTROL, data);
203 
204         udelay(100);
205 
206         /* Reset and configure cascaded 10/100 PHY */
207         (void)reset_one_mii_phy(phy, 0x1f);
208 
209         data = __phy_read(phy, 0x1f, MII_BCM5201_MULTIPHY);
210         data |= MII_BCM5201_MULTIPHY_SERIALMODE;
211         __phy_write(phy, 0x1f, MII_BCM5201_MULTIPHY, data);
212 
213         data = phy_read(phy, MII_BCM5400_AUXCONTROL);
214         data &= ~MII_BCM5400_AUXCONTROL_PWR10BASET;
215         phy_write(phy, MII_BCM5400_AUXCONTROL, data);
216 
217         return 0;
218 }
219 
220 static int bcm5400_suspend(struct mii_phy* phy)
221 {
222 #if 0 /* Commented out in Darwin... someone has those dawn docs ? */
223         phy_write(phy, MII_BMCR, BMCR_PDOWN);
224 #endif
225         return 0;
226 }
227 
228 static int bcm5401_init(struct mii_phy* phy)
229 {
230         u16 data;
231         int rev;
232 
233         rev = phy_read(phy, MII_PHYSID2) & 0x000f;
234         if (rev == 0 || rev == 3) {
235                 /* Some revisions of 5401 appear to need this
236                  * initialisation sequence to disable, according
237                  * to OF, "tap power management"
238                  *
239                  * WARNING ! OF and Darwin don't agree on the
240                  * register addresses. OF seem to interpret the
241                  * register numbers below as decimal
242                  *
243                  * Note: This should (and does) match tg3_init_5401phy_dsp
244                  *       in the tg3.c driver. -DaveM
245                  */
246                 phy_write(phy, 0x18, 0x0c20);
247                 phy_write(phy, 0x17, 0x0012);
248                 phy_write(phy, 0x15, 0x1804);
249                 phy_write(phy, 0x17, 0x0013);
250                 phy_write(phy, 0x15, 0x1204);
251                 phy_write(phy, 0x17, 0x8006);
252                 phy_write(phy, 0x15, 0x0132);
253                 phy_write(phy, 0x17, 0x8006);
254                 phy_write(phy, 0x15, 0x0232);
255                 phy_write(phy, 0x17, 0x201f);
256                 phy_write(phy, 0x15, 0x0a20);
257         }
258 
259         /* Configure for gigabit full duplex */
260         data = phy_read(phy, MII_BCM5400_GB_CONTROL);
261         data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
262         phy_write(phy, MII_BCM5400_GB_CONTROL, data);
263 
264         udelay(10);
265 
266         /* Reset and configure cascaded 10/100 PHY */
267         (void)reset_one_mii_phy(phy, 0x1f);
268 
269         data = __phy_read(phy, 0x1f, MII_BCM5201_MULTIPHY);
270         data |= MII_BCM5201_MULTIPHY_SERIALMODE;
271         __phy_write(phy, 0x1f, MII_BCM5201_MULTIPHY, data);
272 
273         return 0;
274 }
275 
276 static int bcm5401_suspend(struct mii_phy* phy)
277 {
278 #if 0 /* Commented out in Darwin... someone has those dawn docs ? */
279         phy_write(phy, MII_BMCR, BMCR_PDOWN);
280 #endif
281         return 0;
282 }
283 
284 static int bcm5411_init(struct mii_phy* phy)
285 {
286         u16 data;
287 
288         /* Here's some more Apple black magic to setup
289          * some voltage stuffs.
290          */
291         phy_write(phy, 0x1c, 0x8c23);
292         phy_write(phy, 0x1c, 0x8ca3);
293         phy_write(phy, 0x1c, 0x8c23);
294 
295         /* Here, Apple seems to want to reset it, do
296          * it as well
297          */
298         phy_write(phy, MII_BMCR, BMCR_RESET);
299         phy_write(phy, MII_BMCR, 0x1340);
300 
301         data = phy_read(phy, MII_BCM5400_GB_CONTROL);
302         data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
303         phy_write(phy, MII_BCM5400_GB_CONTROL, data);
304 
305         udelay(10);
306 
307         /* Reset and configure cascaded 10/100 PHY */
308         (void)reset_one_mii_phy(phy, 0x1f);
309 
310         return 0;
311 }
312 
313 static int genmii_setup_aneg(struct mii_phy *phy, u32 advertise)
314 {
315         u16 ctl, adv;
316 
317         phy->autoneg = 1;
318         phy->speed = SPEED_10;
319         phy->duplex = DUPLEX_HALF;
320         phy->pause = 0;
321         phy->advertising = advertise;
322 
323         /* Setup standard advertise */
324         adv = phy_read(phy, MII_ADVERTISE);
325         adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
326         if (advertise & ADVERTISED_10baseT_Half)
327                 adv |= ADVERTISE_10HALF;
328         if (advertise & ADVERTISED_10baseT_Full)
329                 adv |= ADVERTISE_10FULL;
330         if (advertise & ADVERTISED_100baseT_Half)
331                 adv |= ADVERTISE_100HALF;
332         if (advertise & ADVERTISED_100baseT_Full)
333                 adv |= ADVERTISE_100FULL;
334         phy_write(phy, MII_ADVERTISE, adv);
335 
336         /* Start/Restart aneg */
337         ctl = phy_read(phy, MII_BMCR);
338         ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
339         phy_write(phy, MII_BMCR, ctl);
340 
341         return 0;
342 }
343 
344 static int genmii_setup_forced(struct mii_phy *phy, int speed, int fd)
345 {
346         u16 ctl;
347 
348         phy->autoneg = 0;
349         phy->speed = speed;
350         phy->duplex = fd;
351         phy->pause = 0;
352 
353         ctl = phy_read(phy, MII_BMCR);
354         ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_ANENABLE);
355 
356         /* First reset the PHY */
357         phy_write(phy, MII_BMCR, ctl | BMCR_RESET);
358 
359         /* Select speed & duplex */
360         switch(speed) {
361         case SPEED_10:
362                 break;
363         case SPEED_100:
364                 ctl |= BMCR_SPEED100;
365                 break;
366         case SPEED_1000:
367         default:
368                 return -EINVAL;
369         }
370         if (fd == DUPLEX_FULL)
371                 ctl |= BMCR_FULLDPLX;
372         phy_write(phy, MII_BMCR, ctl);
373 
374         return 0;
375 }
376 
377 static int genmii_poll_link(struct mii_phy *phy)
378 {
379         u16 status;
380 
381         (void)phy_read(phy, MII_BMSR);
382         status = phy_read(phy, MII_BMSR);
383         if ((status & BMSR_LSTATUS) == 0)
384                 return 0;
385         if (phy->autoneg && !(status & BMSR_ANEGCOMPLETE))
386                 return 0;
387         return 1;
388 }
389 
390 static int genmii_read_link(struct mii_phy *phy)
391 {
392         u16 lpa;
393 
394         if (phy->autoneg) {
395                 lpa = phy_read(phy, MII_LPA);
396 
397                 if (lpa & (LPA_10FULL | LPA_100FULL))
398                         phy->duplex = DUPLEX_FULL;
399                 else
400                         phy->duplex = DUPLEX_HALF;
401                 if (lpa & (LPA_100FULL | LPA_100HALF))
402                         phy->speed = SPEED_100;
403                 else
404                         phy->speed = SPEED_10;
405                 phy->pause = 0;
406         }
407         /* On non-aneg, we assume what we put in BMCR is the speed,
408          * though magic-aneg shouldn't prevent this case from occurring
409          */
410 
411          return 0;
412 }
413 
414 static int generic_suspend(struct mii_phy* phy)
415 {
416         phy_write(phy, MII_BMCR, BMCR_PDOWN);
417 
418         return 0;
419 }
420 
421 static int bcm5421_init(struct mii_phy* phy)
422 {
423         u16 data;
424         unsigned int id;
425 
426         id = (phy_read(phy, MII_PHYSID1) << 16 | phy_read(phy, MII_PHYSID2));
427 
428         /* Revision 0 of 5421 needs some fixups */
429         if (id == 0x002060e0) {
430                 /* This is borrowed from MacOS
431                  */
432                 phy_write(phy, 0x18, 0x1007);
433                 data = phy_read(phy, 0x18);
434                 phy_write(phy, 0x18, data | 0x0400);
435                 phy_write(phy, 0x18, 0x0007);
436                 data = phy_read(phy, 0x18);
437                 phy_write(phy, 0x18, data | 0x0800);
438                 phy_write(phy, 0x17, 0x000a);
439                 data = phy_read(phy, 0x15);
440                 phy_write(phy, 0x15, data | 0x0200);
441         }
442 
443         /* Pick up some init code from OF for K2 version */
444         if ((id & 0xfffffff0) == 0x002062e0) {
445                 phy_write(phy, 4, 0x01e1);
446                 phy_write(phy, 9, 0x0300);
447         }
448 
449         /* Check if we can enable automatic low power */
450 #ifdef CONFIG_PPC_PMAC
451         if (phy->platform_data) {
452                 struct device_node *np = of_get_parent(phy->platform_data);
453                 int can_low_power = 1;
454                 if (np == NULL || of_get_property(np, "no-autolowpower", NULL))
455                         can_low_power = 0;
456                 if (can_low_power) {
457                         /* Enable automatic low-power */
458                         phy_write(phy, 0x1c, 0x9002);
459                         phy_write(phy, 0x1c, 0xa821);
460                         phy_write(phy, 0x1c, 0x941d);
461                 }
462         }
463 #endif /* CONFIG_PPC_PMAC */
464 
465         return 0;
466 }
467 
468 static int bcm54xx_setup_aneg(struct mii_phy *phy, u32 advertise)
469 {
470         u16 ctl, adv;
471 
472         phy->autoneg = 1;
473         phy->speed = SPEED_10;
474         phy->duplex = DUPLEX_HALF;
475         phy->pause = 0;
476         phy->advertising = advertise;
477 
478         /* Setup standard advertise */
479         adv = phy_read(phy, MII_ADVERTISE);
480         adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
481         if (advertise & ADVERTISED_10baseT_Half)
482                 adv |= ADVERTISE_10HALF;
483         if (advertise & ADVERTISED_10baseT_Full)
484                 adv |= ADVERTISE_10FULL;
485         if (advertise & ADVERTISED_100baseT_Half)
486                 adv |= ADVERTISE_100HALF;
487         if (advertise & ADVERTISED_100baseT_Full)
488                 adv |= ADVERTISE_100FULL;
489         if (advertise & ADVERTISED_Pause)
490                 adv |= ADVERTISE_PAUSE_CAP;
491         if (advertise & ADVERTISED_Asym_Pause)
492                 adv |= ADVERTISE_PAUSE_ASYM;
493         phy_write(phy, MII_ADVERTISE, adv);
494 
495         /* Setup 1000BT advertise */
496         adv = phy_read(phy, MII_1000BASETCONTROL);
497         adv &= ~(MII_1000BASETCONTROL_FULLDUPLEXCAP|MII_1000BASETCONTROL_HALFDUPLEXCAP);
498         if (advertise & SUPPORTED_1000baseT_Half)
499                 adv |= MII_1000BASETCONTROL_HALFDUPLEXCAP;
500         if (advertise & SUPPORTED_1000baseT_Full)
501                 adv |= MII_1000BASETCONTROL_FULLDUPLEXCAP;
502         phy_write(phy, MII_1000BASETCONTROL, adv);
503 
504         /* Start/Restart aneg */
505         ctl = phy_read(phy, MII_BMCR);
506         ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
507         phy_write(phy, MII_BMCR, ctl);
508 
509         return 0;
510 }
511 
512 static int bcm54xx_setup_forced(struct mii_phy *phy, int speed, int fd)
513 {
514         u16 ctl;
515 
516         phy->autoneg = 0;
517         phy->speed = speed;
518         phy->duplex = fd;
519         phy->pause = 0;
520 
521         ctl = phy_read(phy, MII_BMCR);
522         ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_SPD2|BMCR_ANENABLE);
523 
524         /* First reset the PHY */
525         phy_write(phy, MII_BMCR, ctl | BMCR_RESET);
526 
527         /* Select speed & duplex */
528         switch(speed) {
529         case SPEED_10:
530                 break;
531         case SPEED_100:
532                 ctl |= BMCR_SPEED100;
533                 break;
534         case SPEED_1000:
535                 ctl |= BMCR_SPD2;
536         }
537         if (fd == DUPLEX_FULL)
538                 ctl |= BMCR_FULLDPLX;
539 
540         // XXX Should we set the sungem to GII now on 1000BT ?
541 
542         phy_write(phy, MII_BMCR, ctl);
543 
544         return 0;
545 }
546 
547 static int bcm54xx_read_link(struct mii_phy *phy)
548 {
549         int link_mode;
550         u16 val;
551 
552         if (phy->autoneg) {
553                 val = phy_read(phy, MII_BCM5400_AUXSTATUS);
554                 link_mode = ((val & MII_BCM5400_AUXSTATUS_LINKMODE_MASK) >>
555                              MII_BCM5400_AUXSTATUS_LINKMODE_SHIFT);
556                 phy->duplex = phy_BCM5400_link_table[link_mode][0] ?
557                         DUPLEX_FULL : DUPLEX_HALF;
558                 phy->speed = phy_BCM5400_link_table[link_mode][2] ?
559                                 SPEED_1000 :
560                                 (phy_BCM5400_link_table[link_mode][1] ?
561                                  SPEED_100 : SPEED_10);
562                 val = phy_read(phy, MII_LPA);
563                 phy->pause = (phy->duplex == DUPLEX_FULL) &&
564                         ((val & LPA_PAUSE) != 0);
565         }
566         /* On non-aneg, we assume what we put in BMCR is the speed,
567          * though magic-aneg shouldn't prevent this case from occurring
568          */
569 
570         return 0;
571 }
572 
573 static int marvell88e1111_init(struct mii_phy* phy)
574 {
575         u16 rev;
576 
577         /* magic init sequence for rev 0 */
578         rev = phy_read(phy, MII_PHYSID2) & 0x000f;
579         if (rev == 0) {
580                 phy_write(phy, 0x1d, 0x000a);
581                 phy_write(phy, 0x1e, 0x0821);
582 
583                 phy_write(phy, 0x1d, 0x0006);
584                 phy_write(phy, 0x1e, 0x8600);
585 
586                 phy_write(phy, 0x1d, 0x000b);
587                 phy_write(phy, 0x1e, 0x0100);
588 
589                 phy_write(phy, 0x1d, 0x0004);
590                 phy_write(phy, 0x1e, 0x4850);
591         }
592         return 0;
593 }
594 
595 #define BCM5421_MODE_MASK       (1 << 5)
596 
597 static int bcm5421_poll_link(struct mii_phy* phy)
598 {
599         u32 phy_reg;
600         int mode;
601 
602         /* find out in what mode we are */
603         phy_write(phy, MII_NCONFIG, 0x1000);
604         phy_reg = phy_read(phy, MII_NCONFIG);
605 
606         mode = (phy_reg & BCM5421_MODE_MASK) >> 5;
607 
608         if ( mode == BCM54XX_COPPER)
609                 return genmii_poll_link(phy);
610 
611         /* try to find out wether we have a link */
612         phy_write(phy, MII_NCONFIG, 0x2000);
613         phy_reg = phy_read(phy, MII_NCONFIG);
614 
615         if (phy_reg & 0x0020)
616                 return 0;
617         else
618                 return 1;
619 }
620 
621 static int bcm5421_read_link(struct mii_phy* phy)
622 {
623         u32 phy_reg;
624         int mode;
625 
626         /* find out in what mode we are */
627         phy_write(phy, MII_NCONFIG, 0x1000);
628         phy_reg = phy_read(phy, MII_NCONFIG);
629 
630         mode = (phy_reg & BCM5421_MODE_MASK ) >> 5;
631 
632         if ( mode == BCM54XX_COPPER)
633                 return bcm54xx_read_link(phy);
634 
635         phy->speed = SPEED_1000;
636 
637         /* find out wether we are running half- or full duplex */
638         phy_write(phy, MII_NCONFIG, 0x2000);
639         phy_reg = phy_read(phy, MII_NCONFIG);
640 
641         if ( (phy_reg & 0x0080) >> 7)
642                 phy->duplex |=  DUPLEX_HALF;
643         else
644                 phy->duplex |=  DUPLEX_FULL;
645 
646         return 0;
647 }
648 
649 static int bcm5421_enable_fiber(struct mii_phy* phy, int autoneg)
650 {
651         /* enable fiber mode */
652         phy_write(phy, MII_NCONFIG, 0x9020);
653         /* LEDs active in both modes, autosense prio = fiber */
654         phy_write(phy, MII_NCONFIG, 0x945f);
655 
656         if (!autoneg) {
657                 /* switch off fibre autoneg */
658                 phy_write(phy, MII_NCONFIG, 0xfc01);
659                 phy_write(phy, 0x0b, 0x0004);
660         }
661 
662         phy->autoneg = autoneg;
663 
664         return 0;
665 }
666 
667 #define BCM5461_FIBER_LINK      (1 << 2)
668 #define BCM5461_MODE_MASK       (3 << 1)
669 
670 static int bcm5461_poll_link(struct mii_phy* phy)
671 {
672         u32 phy_reg;
673         int mode;
674 
675         /* find out in what mode we are */
676         phy_write(phy, MII_NCONFIG, 0x7c00);
677         phy_reg = phy_read(phy, MII_NCONFIG);
678 
679         mode = (phy_reg & BCM5461_MODE_MASK ) >> 1;
680 
681         if ( mode == BCM54XX_COPPER)
682                 return genmii_poll_link(phy);
683 
684         /* find out wether we have a link */
685         phy_write(phy, MII_NCONFIG, 0x7000);
686         phy_reg = phy_read(phy, MII_NCONFIG);
687 
688         if (phy_reg & BCM5461_FIBER_LINK)
689                 return 1;
690         else
691                 return 0;
692 }
693 
694 #define BCM5461_FIBER_DUPLEX    (1 << 3)
695 
696 static int bcm5461_read_link(struct mii_phy* phy)
697 {
698         u32 phy_reg;
699         int mode;
700 
701         /* find out in what mode we are */
702         phy_write(phy, MII_NCONFIG, 0x7c00);
703         phy_reg = phy_read(phy, MII_NCONFIG);
704 
705         mode = (phy_reg & BCM5461_MODE_MASK ) >> 1;
706 
707         if ( mode == BCM54XX_COPPER) {
708                 return bcm54xx_read_link(phy);
709         }
710 
711         phy->speed = SPEED_1000;
712 
713         /* find out wether we are running half- or full duplex */
714         phy_write(phy, MII_NCONFIG, 0x7000);
715         phy_reg = phy_read(phy, MII_NCONFIG);
716 
717         if (phy_reg & BCM5461_FIBER_DUPLEX)
718                 phy->duplex |=  DUPLEX_FULL;
719         else
720                 phy->duplex |=  DUPLEX_HALF;
721 
722         return 0;
723 }
724 
725 static int bcm5461_enable_fiber(struct mii_phy* phy, int autoneg)
726 {
727         /* select fiber mode, enable 1000 base-X registers */
728         phy_write(phy, MII_NCONFIG, 0xfc0b);
729 
730         if (autoneg) {
731                 /* enable fiber with no autonegotiation */
732                 phy_write(phy, MII_ADVERTISE, 0x01e0);
733                 phy_write(phy, MII_BMCR, 0x1140);
734         } else {
735                 /* enable fiber with autonegotiation */
736                 phy_write(phy, MII_BMCR, 0x0140);
737         }
738 
739         phy->autoneg = autoneg;
740 
741         return 0;
742 }
743 
744 static int marvell_setup_aneg(struct mii_phy *phy, u32 advertise)
745 {
746         u16 ctl, adv;
747 
748         phy->autoneg = 1;
749         phy->speed = SPEED_10;
750         phy->duplex = DUPLEX_HALF;
751         phy->pause = 0;
752         phy->advertising = advertise;
753 
754         /* Setup standard advertise */
755         adv = phy_read(phy, MII_ADVERTISE);
756         adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
757         if (advertise & ADVERTISED_10baseT_Half)
758                 adv |= ADVERTISE_10HALF;
759         if (advertise & ADVERTISED_10baseT_Full)
760                 adv |= ADVERTISE_10FULL;
761         if (advertise & ADVERTISED_100baseT_Half)
762                 adv |= ADVERTISE_100HALF;
763         if (advertise & ADVERTISED_100baseT_Full)
764                 adv |= ADVERTISE_100FULL;
765         if (advertise & ADVERTISED_Pause)
766                 adv |= ADVERTISE_PAUSE_CAP;
767         if (advertise & ADVERTISED_Asym_Pause)
768                 adv |= ADVERTISE_PAUSE_ASYM;
769         phy_write(phy, MII_ADVERTISE, adv);
770 
771         /* Setup 1000BT advertise & enable crossover detect
772          * XXX How do we advertise 1000BT ? Darwin source is
773          * confusing here, they read from specific control and
774          * write to control... Someone has specs for those
775          * beasts ?
776          */
777         adv = phy_read(phy, MII_M1011_PHY_SPEC_CONTROL);
778         adv |= MII_M1011_PHY_SPEC_CONTROL_AUTO_MDIX;
779         adv &= ~(MII_1000BASETCONTROL_FULLDUPLEXCAP |
780                         MII_1000BASETCONTROL_HALFDUPLEXCAP);
781         if (advertise & SUPPORTED_1000baseT_Half)
782                 adv |= MII_1000BASETCONTROL_HALFDUPLEXCAP;
783         if (advertise & SUPPORTED_1000baseT_Full)
784                 adv |= MII_1000BASETCONTROL_FULLDUPLEXCAP;
785         phy_write(phy, MII_1000BASETCONTROL, adv);
786 
787         /* Start/Restart aneg */
788         ctl = phy_read(phy, MII_BMCR);
789         ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
790         phy_write(phy, MII_BMCR, ctl);
791 
792         return 0;
793 }
794 
795 static int marvell_setup_forced(struct mii_phy *phy, int speed, int fd)
796 {
797         u16 ctl, ctl2;
798 
799         phy->autoneg = 0;
800         phy->speed = speed;
801         phy->duplex = fd;
802         phy->pause = 0;
803 
804         ctl = phy_read(phy, MII_BMCR);
805         ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_SPD2|BMCR_ANENABLE);
806         ctl |= BMCR_RESET;
807 
808         /* Select speed & duplex */
809         switch(speed) {
810         case SPEED_10:
811                 break;
812         case SPEED_100:
813                 ctl |= BMCR_SPEED100;
814                 break;
815         /* I'm not sure about the one below, again, Darwin source is
816          * quite confusing and I lack chip specs
817          */
818         case SPEED_1000:
819                 ctl |= BMCR_SPD2;
820         }
821         if (fd == DUPLEX_FULL)
822                 ctl |= BMCR_FULLDPLX;
823 
824         /* Disable crossover. Again, the way Apple does it is strange,
825          * though I don't assume they are wrong ;)
826          */
827         ctl2 = phy_read(phy, MII_M1011_PHY_SPEC_CONTROL);
828         ctl2 &= ~(MII_M1011_PHY_SPEC_CONTROL_MANUAL_MDIX |
829                 MII_M1011_PHY_SPEC_CONTROL_AUTO_MDIX |
830                 MII_1000BASETCONTROL_FULLDUPLEXCAP |
831                 MII_1000BASETCONTROL_HALFDUPLEXCAP);
832         if (speed == SPEED_1000)
833                 ctl2 |= (fd == DUPLEX_FULL) ?
834                         MII_1000BASETCONTROL_FULLDUPLEXCAP :
835                         MII_1000BASETCONTROL_HALFDUPLEXCAP;
836         phy_write(phy, MII_1000BASETCONTROL, ctl2);
837 
838         // XXX Should we set the sungem to GII now on 1000BT ?
839 
840         phy_write(phy, MII_BMCR, ctl);
841 
842         return 0;
843 }
844 
845 static int marvell_read_link(struct mii_phy *phy)
846 {
847         u16 status, pmask;
848 
849         if (phy->autoneg) {
850                 status = phy_read(phy, MII_M1011_PHY_SPEC_STATUS);
851                 if ((status & MII_M1011_PHY_SPEC_STATUS_RESOLVED) == 0)
852                         return -EAGAIN;
853                 if (status & MII_M1011_PHY_SPEC_STATUS_1000)
854                         phy->speed = SPEED_1000;
855                 else if (status & MII_M1011_PHY_SPEC_STATUS_100)
856                         phy->speed = SPEED_100;
857                 else
858                         phy->speed = SPEED_10;
859                 if (status & MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX)
860                         phy->duplex = DUPLEX_FULL;
861                 else
862                         phy->duplex = DUPLEX_HALF;
863                 pmask = MII_M1011_PHY_SPEC_STATUS_TX_PAUSE |
864                         MII_M1011_PHY_SPEC_STATUS_RX_PAUSE;
865                 phy->pause = (status & pmask) == pmask;
866         }
867         /* On non-aneg, we assume what we put in BMCR is the speed,
868          * though magic-aneg shouldn't prevent this case from occurring
869          */
870 
871         return 0;
872 }
873 
874 #define MII_BASIC_FEATURES \
875         (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |      \
876          SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |    \
877          SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII |     \
878          SUPPORTED_Pause)
879 
880 /* On gigabit capable PHYs, we advertise Pause support but not asym pause
881  * support for now as I'm not sure it's supported and Darwin doesn't do
882  * it neither. --BenH.
883  */
884 #define MII_GBIT_FEATURES \
885         (MII_BASIC_FEATURES |   \
886          SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)
887 
888 /* Broadcom BCM 5201 */
889 static struct mii_phy_ops bcm5201_phy_ops = {
890         .init           = bcm5201_init,
891         .suspend        = bcm5201_suspend,
892         .setup_aneg     = genmii_setup_aneg,
893         .setup_forced   = genmii_setup_forced,
894         .poll_link      = genmii_poll_link,
895         .read_link      = genmii_read_link,
896 };
897 
898 static struct mii_phy_def bcm5201_phy_def = {
899         .phy_id         = 0x00406210,
900         .phy_id_mask    = 0xfffffff0,
901         .name           = "BCM5201",
902         .features       = MII_BASIC_FEATURES,
903         .magic_aneg     = 1,
904         .ops            = &bcm5201_phy_ops
905 };
906 
907 /* Broadcom BCM 5221 */
908 static struct mii_phy_ops bcm5221_phy_ops = {
909         .suspend        = bcm5221_suspend,
910         .init           = bcm5221_init,
911         .setup_aneg     = genmii_setup_aneg,
912         .setup_forced   = genmii_setup_forced,
913         .poll_link      = genmii_poll_link,
914         .read_link      = genmii_read_link,
915 };
916 
917 static struct mii_phy_def bcm5221_phy_def = {
918         .phy_id         = 0x004061e0,
919         .phy_id_mask    = 0xfffffff0,
920         .name           = "BCM5221",
921         .features       = MII_BASIC_FEATURES,
922         .magic_aneg     = 1,
923         .ops            = &bcm5221_phy_ops
924 };
925 
926 /* Broadcom BCM 5241 */
927 static struct mii_phy_ops bcm5241_phy_ops = {
928         .suspend        = bcm5241_suspend,
929         .init           = bcm5241_init,
930         .setup_aneg     = genmii_setup_aneg,
931         .setup_forced   = genmii_setup_forced,
932         .poll_link      = genmii_poll_link,
933         .read_link      = genmii_read_link,
934 };
935 static struct mii_phy_def bcm5241_phy_def = {
936         .phy_id         = 0x0143bc30,
937         .phy_id_mask    = 0xfffffff0,
938         .name           = "BCM5241",
939         .features       = MII_BASIC_FEATURES,
940         .magic_aneg     = 1,
941         .ops            = &bcm5241_phy_ops
942 };
943 
944 /* Broadcom BCM 5400 */
945 static struct mii_phy_ops bcm5400_phy_ops = {
946         .init           = bcm5400_init,
947         .suspend        = bcm5400_suspend,
948         .setup_aneg     = bcm54xx_setup_aneg,
949         .setup_forced   = bcm54xx_setup_forced,
950         .poll_link      = genmii_poll_link,
951         .read_link      = bcm54xx_read_link,
952 };
953 
954 static struct mii_phy_def bcm5400_phy_def = {
955         .phy_id         = 0x00206040,
956         .phy_id_mask    = 0xfffffff0,
957         .name           = "BCM5400",
958         .features       = MII_GBIT_FEATURES,
959         .magic_aneg     = 1,
960         .ops            = &bcm5400_phy_ops
961 };
962 
963 /* Broadcom BCM 5401 */
964 static struct mii_phy_ops bcm5401_phy_ops = {
965         .init           = bcm5401_init,
966         .suspend        = bcm5401_suspend,
967         .setup_aneg     = bcm54xx_setup_aneg,
968         .setup_forced   = bcm54xx_setup_forced,
969         .poll_link      = genmii_poll_link,
970         .read_link      = bcm54xx_read_link,
971 };
972 
973 static struct mii_phy_def bcm5401_phy_def = {
974         .phy_id         = 0x00206050,
975         .phy_id_mask    = 0xfffffff0,
976         .name           = "BCM5401",
977         .features       = MII_GBIT_FEATURES,
978         .magic_aneg     = 1,
979         .ops            = &bcm5401_phy_ops
980 };
981 
982 /* Broadcom BCM 5411 */
983 static struct mii_phy_ops bcm5411_phy_ops = {
984         .init           = bcm5411_init,
985         .suspend        = generic_suspend,
986         .setup_aneg     = bcm54xx_setup_aneg,
987         .setup_forced   = bcm54xx_setup_forced,
988         .poll_link      = genmii_poll_link,
989         .read_link      = bcm54xx_read_link,
990 };
991 
992 static struct mii_phy_def bcm5411_phy_def = {
993         .phy_id         = 0x00206070,
994         .phy_id_mask    = 0xfffffff0,
995         .name           = "BCM5411",
996         .features       = MII_GBIT_FEATURES,
997         .magic_aneg     = 1,
998         .ops            = &bcm5411_phy_ops
999 };
1000 
1001 /* Broadcom BCM 5421 */
1002 static struct mii_phy_ops bcm5421_phy_ops = {
1003         .init           = bcm5421_init,
1004         .suspend        = generic_suspend,
1005         .setup_aneg     = bcm54xx_setup_aneg,
1006         .setup_forced   = bcm54xx_setup_forced,
1007         .poll_link      = bcm5421_poll_link,
1008         .read_link      = bcm5421_read_link,
1009         .enable_fiber   = bcm5421_enable_fiber,
1010 };
1011 
1012 static struct mii_phy_def bcm5421_phy_def = {
1013         .phy_id         = 0x002060e0,
1014         .phy_id_mask    = 0xfffffff0,
1015         .name           = "BCM5421",
1016         .features       = MII_GBIT_FEATURES,
1017         .magic_aneg     = 1,
1018         .ops            = &bcm5421_phy_ops
1019 };
1020 
1021 /* Broadcom BCM 5421 built-in K2 */
1022 static struct mii_phy_ops bcm5421k2_phy_ops = {
1023         .init           = bcm5421_init,
1024         .suspend        = generic_suspend,
1025         .setup_aneg     = bcm54xx_setup_aneg,
1026         .setup_forced   = bcm54xx_setup_forced,
1027         .poll_link      = genmii_poll_link,
1028         .read_link      = bcm54xx_read_link,
1029 };
1030 
1031 static struct mii_phy_def bcm5421k2_phy_def = {
1032         .phy_id         = 0x002062e0,
1033         .phy_id_mask    = 0xfffffff0,
1034         .name           = "BCM5421-K2",
1035         .features       = MII_GBIT_FEATURES,
1036         .magic_aneg     = 1,
1037         .ops            = &bcm5421k2_phy_ops
1038 };
1039 
1040 static struct mii_phy_ops bcm5461_phy_ops = {
1041         .init           = bcm5421_init,
1042         .suspend        = generic_suspend,
1043         .setup_aneg     = bcm54xx_setup_aneg,
1044         .setup_forced   = bcm54xx_setup_forced,
1045         .poll_link      = bcm5461_poll_link,
1046         .read_link      = bcm5461_read_link,
1047         .enable_fiber   = bcm5461_enable_fiber,
1048 };
1049 
1050 static struct mii_phy_def bcm5461_phy_def = {
1051         .phy_id         = 0x002060c0,
1052         .phy_id_mask    = 0xfffffff0,
1053         .name           = "BCM5461",
1054         .features       = MII_GBIT_FEATURES,
1055         .magic_aneg     = 1,
1056         .ops            = &bcm5461_phy_ops
1057 };
1058 
1059 /* Broadcom BCM 5462 built-in Vesta */
1060 static struct mii_phy_ops bcm5462V_phy_ops = {
1061         .init           = bcm5421_init,
1062         .suspend        = generic_suspend,
1063         .setup_aneg     = bcm54xx_setup_aneg,
1064         .setup_forced   = bcm54xx_setup_forced,
1065         .poll_link      = genmii_poll_link,
1066         .read_link      = bcm54xx_read_link,
1067 };
1068 
1069 static struct mii_phy_def bcm5462V_phy_def = {
1070         .phy_id         = 0x002060d0,
1071         .phy_id_mask    = 0xfffffff0,
1072         .name           = "BCM5462-Vesta",
1073         .features       = MII_GBIT_FEATURES,
1074         .magic_aneg     = 1,
1075         .ops            = &bcm5462V_phy_ops
1076 };
1077 
1078 /* Marvell 88E1101 amd 88E1111 */
1079 static struct mii_phy_ops marvell88e1101_phy_ops = {
1080         .suspend        = generic_suspend,
1081         .setup_aneg     = marvell_setup_aneg,
1082         .setup_forced   = marvell_setup_forced,
1083         .poll_link      = genmii_poll_link,
1084         .read_link      = marvell_read_link
1085 };
1086 
1087 static struct mii_phy_ops marvell88e1111_phy_ops = {
1088         .init           = marvell88e1111_init,
1089         .suspend        = generic_suspend,
1090         .setup_aneg     = marvell_setup_aneg,
1091         .setup_forced   = marvell_setup_forced,
1092         .poll_link      = genmii_poll_link,
1093         .read_link      = marvell_read_link
1094 };
1095 
1096 /* two revs in darwin for the 88e1101 ... I could use a datasheet
1097  * to get the proper names...
1098  */
1099 static struct mii_phy_def marvell88e1101v1_phy_def = {
1100         .phy_id         = 0x01410c20,
1101         .phy_id_mask    = 0xfffffff0,
1102         .name           = "Marvell 88E1101v1",
1103         .features       = MII_GBIT_FEATURES,
1104         .magic_aneg     = 1,
1105         .ops            = &marvell88e1101_phy_ops
1106 };
1107 static struct mii_phy_def marvell88e1101v2_phy_def = {
1108         .phy_id         = 0x01410c60,
1109         .phy_id_mask    = 0xfffffff0,
1110         .name           = "Marvell 88E1101v2",
1111         .features       = MII_GBIT_FEATURES,
1112         .magic_aneg     = 1,
1113         .ops            = &marvell88e1101_phy_ops
1114 };
1115 static struct mii_phy_def marvell88e1111_phy_def = {
1116         .phy_id         = 0x01410cc0,
1117         .phy_id_mask    = 0xfffffff0,
1118         .name           = "Marvell 88E1111",
1119         .features       = MII_GBIT_FEATURES,
1120         .magic_aneg     = 1,
1121         .ops            = &marvell88e1111_phy_ops
1122 };
1123 
1124 /* Generic implementation for most 10/100 PHYs */
1125 static struct mii_phy_ops generic_phy_ops = {
1126         .setup_aneg     = genmii_setup_aneg,
1127         .setup_forced   = genmii_setup_forced,
1128         .poll_link      = genmii_poll_link,
1129         .read_link      = genmii_read_link
1130 };
1131 
1132 static struct mii_phy_def genmii_phy_def = {
1133         .phy_id         = 0x00000000,
1134         .phy_id_mask    = 0x00000000,
1135         .name           = "Generic MII",
1136         .features       = MII_BASIC_FEATURES,
1137         .magic_aneg     = 0,
1138         .ops            = &generic_phy_ops
1139 };
1140 
1141 static struct mii_phy_def* mii_phy_table[] = {
1142         &bcm5201_phy_def,
1143         &bcm5221_phy_def,
1144         &bcm5241_phy_def,
1145         &bcm5400_phy_def,
1146         &bcm5401_phy_def,
1147         &bcm5411_phy_def,
1148         &bcm5421_phy_def,
1149         &bcm5421k2_phy_def,
1150         &bcm5461_phy_def,
1151         &bcm5462V_phy_def,
1152         &marvell88e1101v1_phy_def,
1153         &marvell88e1101v2_phy_def,
1154         &marvell88e1111_phy_def,
1155         &genmii_phy_def,
1156         NULL
1157 };
1158 
1159 int mii_phy_probe(struct mii_phy *phy, int mii_id)
1160 {
1161         int rc;
1162         u32 id;
1163         struct mii_phy_def* def;
1164         int i;
1165 
1166         /* We do not reset the mii_phy structure as the driver
1167          * may re-probe the PHY regulary
1168          */
1169         phy->mii_id = mii_id;
1170 
1171         /* Take PHY out of isloate mode and reset it. */
1172         rc = reset_one_mii_phy(phy, mii_id);
1173         if (rc)
1174                 goto fail;
1175 
1176         /* Read ID and find matching entry */
1177         id = (phy_read(phy, MII_PHYSID1) << 16 | phy_read(phy, MII_PHYSID2));
1178         printk(KERN_DEBUG "PHY ID: %x, addr: %x\n", id, mii_id);
1179         for (i=0; (def = mii_phy_table[i]) != NULL; i++)
1180                 if ((id & def->phy_id_mask) == def->phy_id)
1181                         break;
1182         /* Should never be NULL (we have a generic entry), but... */
1183         if (def == NULL)
1184                 goto fail;
1185 
1186         phy->def = def;
1187 
1188         return 0;
1189 fail:
1190         phy->speed = 0;
1191         phy->duplex = 0;
1192         phy->pause = 0;
1193         phy->advertising = 0;
1194         return -ENODEV;
1195 }
1196 
1197 EXPORT_SYMBOL(mii_phy_probe);
1198 MODULE_LICENSE("GPL");
1199 
1200 

--------------------------------------------------------------------------------

~ [ source navigation ] ~ [ diff markup ] ~ [ identifier search ] ~ [ freetext search ] ~ [ file search ] ~ 

--------------------------------------------------------------------------------

Project Home | Wiki (Japanese) | Wiki | SVN repository

 
  
[ source navigation ] [ diff markup ] [ identifier search ] [ freetext search ] [ file search ] 
FreeBSD/Linux Kernel Cross Reference 
sys/dev/tsec/if_tsec.c 
Version: -  FREEBSD  -  FREEBSD7  -  FREEBSD70  -  FREEBSD6  -  FREEBSD63  -  FREEBSD62  -  FREEBSD61  -  FREEBSD60  -  FREEBSD5  -  FREEBSD55  -  FREEBSD54  -  FREEBSD53  -  FREEBSD52  -  FREEBSD51  -  FREEBSD50  -  FREEBSD4  -  FREEBSD3  -  linux-2.6  -  linux-2.4.22  -  PLAN9  -  DFBSD  -  NETBSD  -  NETBSD4  -  NETBSD3  -  NETBSD20  -  OPENBSD  -  xnu-517  -  xnu-792  -  xnu-792.6.70  -  xnu-1228  -  OPENSOLARIS  -  minix-3-1-1  -  TRUSTEDBSD-SEBSD  -  TRUSTEDBSD-SEDARWIN  -  TRUSTEDBSD-SEDARWIN7  
Ident_Mode: -  plain  -  excerpts  


--------------------------------------------------------------------------------

  1 /*-
  2  * Copyright (C) 2006-2008 Semihalf
  3  * All rights reserved.
  4  *
  5  * Written by: Piotr Kruszynski <ppk@semihalf.com>
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  * 1. Redistributions of source code must retain the above copyright
 11  *    notice, this list of conditions and the following disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above copyright
 13  *    notice, this list of conditions and the following disclaimer in the
 14  *    documentation and/or other materials provided with the distribution.
 15  * 3. The name of the author may not be used to endorse or promote products
 16  *    derived from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 19  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 20  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 21  * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 22  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 23  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 24  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 25  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 26  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 27  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 /*
 31  * Freescale integrated Three-Speed Ethernet Controller (TSEC) driver.
 32  */
 33 #include <sys/cdefs.h>
 34 __FBSDID("$FreeBSD: src/sys/dev/tsec/if_tsec.c,v 1.3 2008/03/12 16:35:25 raj Exp $");
 35 
 36 #include <sys/param.h>
 37 #include <sys/systm.h>
 38 #include <sys/endian.h>
 39 #include <sys/mbuf.h>
 40 #include <sys/kernel.h>
 41 #include <sys/module.h>
 42 #include <sys/socket.h>
 43 #include <sys/sysctl.h>
 44 
 45 #include <net/if.h>
 46 #include <net/if_dl.h>
 47 #include <net/if_media.h>
 48 
 49 #include <net/bpf.h>
 50 #include <sys/sockio.h>
 51 #include <sys/bus.h>
 52 #include <machine/bus.h>
 53 #include <sys/rman.h>
 54 #include <machine/resource.h>
 55 
 56 #include <net/ethernet.h>
 57 #include <net/if_arp.h>
 58 
 59 #include <net/if_types.h>
 60 #include <net/if_vlan_var.h>
 61 
 62 #include <dev/mii/mii.h>
 63 #include <dev/mii/miivar.h>
 64 
 65 #include <machine/ocpbus.h>
 66 
 67 #include <dev/tsec/if_tsec.h>
 68 #include <dev/tsec/if_tsecreg.h>
 69 
 70 #include "miibus_if.h"
 71 
 72 #define TSEC_DEBUG
 73 
 74 #ifdef TSEC_DEBUG
 75 #define PDEBUG(a) {printf("%s:%d: ", __func__, __LINE__), printf a; printf("\n");}
 76 #else
 77 #define PDEBUG(a) /* nop */
 78 #endif
 79 
 80 static int      tsec_probe(device_t dev);
 81 static int      tsec_attach(device_t dev);
 82 static int      tsec_setup_intr(device_t dev, struct resource **ires,
 83     void **ihand, int *irid, driver_intr_t handler, const char *iname);
 84 static void     tsec_release_intr(device_t dev, struct resource *ires,
 85     void *ihand, int irid, const char *iname);
 86 static void     tsec_free_dma(struct tsec_softc *sc);
 87 static int      tsec_detach(device_t dev);
 88 static void     tsec_shutdown(device_t dev);
 89 static int      tsec_suspend(device_t dev); /* XXX */
 90 static int      tsec_resume(device_t dev); /* XXX */
 91 
 92 static void     tsec_init(void *xsc);
 93 static void     tsec_init_locked(struct tsec_softc *sc);
 94 static void     tsec_set_mac_address(struct tsec_softc *sc);
 95 static void     tsec_dma_ctl(struct tsec_softc *sc, int state);
 96 static void     tsec_intrs_ctl(struct tsec_softc *sc, int state);
 97 static void     tsec_reset_mac(struct tsec_softc *sc);
 98 
 99 static void     tsec_watchdog(struct tsec_softc *sc);
100 static void     tsec_start(struct ifnet *ifp);
101 static void     tsec_start_locked(struct ifnet *ifp);
102 static int      tsec_encap(struct tsec_softc *sc,
103     struct mbuf *m_head);
104 static void     tsec_setfilter(struct tsec_softc *sc);
105 static int      tsec_ioctl(struct ifnet *ifp, u_long command,
106     caddr_t data);
107 static int      tsec_ifmedia_upd(struct ifnet *ifp);
108 static void     tsec_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr);
109 static int      tsec_new_rxbuf(bus_dma_tag_t tag, bus_dmamap_t map,
110     struct mbuf **mbufp, uint32_t *paddr);
111 static void     tsec_map_dma_addr(void *arg, bus_dma_segment_t *segs,
112     int nseg, int error);
113 static int      tsec_alloc_dma_desc(device_t dev, bus_dma_tag_t *dtag,
114     bus_dmamap_t *dmap, bus_size_t dsize, void **vaddr, void *raddr,
115     const char *dname);
116 static void     tsec_free_dma_desc(bus_dma_tag_t dtag, bus_dmamap_t dmap,
117     void *vaddr);
118 
119 static void     tsec_stop(struct tsec_softc *sc);
120 
121 static void     tsec_receive_intr(void *arg);
122 static void     tsec_transmit_intr(void *arg);
123 static void     tsec_error_intr(void *arg);
124 
125 static void     tsec_tick(void *arg);
126 static int      tsec_miibus_readreg(device_t dev, int phy, int reg);
127 static void     tsec_miibus_writereg(device_t dev, int phy, int reg, int value);
128 static void     tsec_miibus_statchg(device_t dev);
129 
130 static struct tsec_softc *tsec0_sc = NULL; /* XXX ugly hack! */
131 
132 static device_method_t tsec_methods[] = {
133         /* Device interface */
134         DEVMETHOD(device_probe,         tsec_probe),
135         DEVMETHOD(device_attach,        tsec_attach),
136         DEVMETHOD(device_detach,        tsec_detach),
137         DEVMETHOD(device_shutdown,      tsec_shutdown),
138         DEVMETHOD(device_suspend,       tsec_suspend),
139         DEVMETHOD(device_resume,        tsec_resume),
140 
141         /* bus interface */
142         DEVMETHOD(bus_print_child,      bus_generic_print_child),
143         DEVMETHOD(bus_driver_added,     bus_generic_driver_added),
144 
145         /* MII interface */
146         DEVMETHOD(miibus_readreg,       tsec_miibus_readreg),
147         DEVMETHOD(miibus_writereg,      tsec_miibus_writereg),
148         DEVMETHOD(miibus_statchg,       tsec_miibus_statchg),
149         { 0, 0 }
150 };
151 
152 static driver_t tsec_driver = {
153         "tsec",
154         tsec_methods,
155         sizeof(struct tsec_softc),
156 };
157 
158 static devclass_t tsec_devclass;
159 
160 DRIVER_MODULE(tsec, ocpbus, tsec_driver, tsec_devclass, 0, 0);
161 DRIVER_MODULE(miibus, tsec, miibus_driver, miibus_devclass, 0, 0);
162 MODULE_DEPEND(tsec, ether, 1, 1, 1);
163 MODULE_DEPEND(tsec, miibus, 1, 1, 1);
164 
165 static void
166 tsec_get_hwaddr(struct tsec_softc *sc, uint8_t *addr)
167 {
168         union {
169                 uint32_t reg[2];
170                 uint8_t addr[6];
171         } curmac;
172         uint32_t a[6];
173         device_t parent;
174         uintptr_t macaddr;
175         int i;
176 
177         parent = device_get_parent(sc->dev);
178         if (BUS_READ_IVAR(parent, sc->dev, OCPBUS_IVAR_MACADDR,
179             &macaddr) == 0) {
180                 bcopy((uint8_t *)macaddr, addr, 6);
181                 return;
182         }
183 
184         /*
185          * Fall back -- use the currently programmed address in the hope that
186          * it was set be firmware...
187          */
188         curmac.reg[0] = TSEC_READ(sc, TSEC_REG_MACSTNADDR1);
189         curmac.reg[1] = TSEC_READ(sc, TSEC_REG_MACSTNADDR2);
190         for (i = 0; i < 6; i++)
191                 a[5-i] = curmac.addr[i];
192 
193         addr[0] = a[0];
194         addr[1] = a[1];
195         addr[2] = a[2];
196         addr[3] = a[3];
197         addr[4] = a[4];
198         addr[5] = a[5];
199 }
200 
201 static void
202 tsec_init(void *xsc)
203 {
204         struct tsec_softc *sc = xsc;
205 
206         TSEC_GLOBAL_LOCK(sc);
207         tsec_init_locked(sc);
208         TSEC_GLOBAL_UNLOCK(sc);
209 }
210 
211 static void
212 tsec_init_locked(struct tsec_softc *sc)
213 {
214         struct tsec_desc *tx_desc = sc->tsec_tx_vaddr;
215         struct tsec_desc *rx_desc = sc->tsec_rx_vaddr;
216         struct ifnet *ifp = sc->tsec_ifp;
217         uint32_t timeout;
218         uint32_t val;
219         uint32_t i;
220 
221         TSEC_GLOBAL_LOCK_ASSERT(sc);
222         tsec_stop(sc);
223 
224         /*
225          * These steps are according to the MPC8555E PowerQUICCIII RM:
226          * 14.7 Initialization/Application Information
227          */
228 
229         /* Step 1: soft reset MAC */
230         tsec_reset_mac(sc);
231 
232         /* Step 2: Initialize MACCFG2 */
233         TSEC_WRITE(sc, TSEC_REG_MACCFG2,
234             TSEC_MACCFG2_FULLDUPLEX |   /* Full Duplex = 1 */
235             TSEC_MACCFG2_PADCRC |       /* PAD/CRC append */
236             TSEC_MACCFG2_GMII |         /* I/F Mode bit */
237             TSEC_MACCFG2_PRECNT         /* Preamble count = 7 */
238         );
239 
240         /* Step 3: Initialize ECNTRL
241          * While the documentation states that R100M is ignored if RPM is
242          * not set, it does seem to be needed to get the orange boxes to
243          * work (which have a Marvell 88E1111 PHY). Go figure.
244          */
245 
246         /*
247          * XXX kludge - use circumstancial evidence to program ECNTRL
248          * correctly. Ideally we need some board information to guide
249          * us here.
250          */
251         i = TSEC_READ(sc, TSEC_REG_ID2);
252         val = (i & 0xffff)
253             ? (TSEC_ECNTRL_TBIM | TSEC_ECNTRL_SGMIIM)   /* Sumatra */
254             : TSEC_ECNTRL_R100M;                        /* Orange + CDS */
255         TSEC_WRITE(sc, TSEC_REG_ECNTRL, TSEC_ECNTRL_STEN | val);
256 
257         /* Step 4: Initialize MAC station address */
258         tsec_set_mac_address(sc);
259 
260         /*
261          * Step 5: Assign a Physical address to the TBI so as to not conflict
262          * with the external PHY physical address
263          */
264         TSEC_WRITE(sc, TSEC_REG_TBIPA, 5);
265 
266         /* Step 6: Reset the management interface */
267         TSEC_WRITE(tsec0_sc, TSEC_REG_MIIMCFG, TSEC_MIIMCFG_RESETMGMT);
268 
269         /* Step 7: Setup the MII Mgmt clock speed */
270         TSEC_WRITE(tsec0_sc, TSEC_REG_MIIMCFG, TSEC_MIIMCFG_CLKDIV28);
271 
272         /* Step 8: Read MII Mgmt indicator register and check for Busy = 0 */
273         timeout = TSEC_READ_RETRY;
274         while (--timeout && (TSEC_READ(tsec0_sc, TSEC_REG_MIIMIND) &
275             TSEC_MIIMIND_BUSY))
276                 DELAY(TSEC_READ_DELAY);
277         if (timeout == 0) {
278                 if_printf(ifp, "tsec_init_locked(): Mgmt busy timeout\n");
279                 return;
280         }
281 
282         /* Step 9: Setup the MII Mgmt */
283         mii_mediachg(sc->tsec_mii);
284 
285         /* Step 10: Clear IEVENT register */
286         TSEC_WRITE(sc, TSEC_REG_IEVENT, 0xffffffff);
287 
288         /* Step 11: Initialize IMASK */
289         tsec_intrs_ctl(sc, 1);
290 
291         /* Step 12: Initialize IADDRn */
292         TSEC_WRITE(sc, TSEC_REG_IADDR0, 0);
293         TSEC_WRITE(sc, TSEC_REG_IADDR1, 0);
294         TSEC_WRITE(sc, TSEC_REG_IADDR2, 0);
295         TSEC_WRITE(sc, TSEC_REG_IADDR3, 0);
296         TSEC_WRITE(sc, TSEC_REG_IADDR4, 0);
297         TSEC_WRITE(sc, TSEC_REG_IADDR5, 0);
298         TSEC_WRITE(sc, TSEC_REG_IADDR6, 0);
299         TSEC_WRITE(sc, TSEC_REG_IADDR7, 0);
300 
301         /* Step 13: Initialize GADDRn */
302         TSEC_WRITE(sc, TSEC_REG_GADDR0, 0);
303         TSEC_WRITE(sc, TSEC_REG_GADDR1, 0);
304         TSEC_WRITE(sc, TSEC_REG_GADDR2, 0);
305         TSEC_WRITE(sc, TSEC_REG_GADDR3, 0);
306         TSEC_WRITE(sc, TSEC_REG_GADDR4, 0);
307         TSEC_WRITE(sc, TSEC_REG_GADDR5, 0);
308         TSEC_WRITE(sc, TSEC_REG_GADDR6, 0);
309         TSEC_WRITE(sc, TSEC_REG_GADDR7, 0);
310 
311         /* Step 14: Initialize RCTRL */
312         TSEC_WRITE(sc, TSEC_REG_RCTRL, 0);
313 
314         /* Step 15: Initialize DMACTRL */
315         tsec_dma_ctl(sc, 1);
316 
317         /* Step 16: Initialize FIFO_PAUSE_CTRL */
318         TSEC_WRITE(sc, TSEC_REG_FIFO_PAUSE_CTRL, TSEC_FIFO_PAUSE_CTRL_EN);
319 
320         /*
321          * Step 17: Initialize transmit/receive descriptor rings.
322          * Initialize TBASE and RBASE.
323          */
324         TSEC_WRITE(sc, TSEC_REG_TBASE, sc->tsec_tx_raddr);
325         TSEC_WRITE(sc, TSEC_REG_RBASE, sc->tsec_rx_raddr);
326 
327         for (i = 0; i < TSEC_TX_NUM_DESC; i++) {
328                 tx_desc[i].bufptr = 0;
329                 tx_desc[i].length = 0;
330                 tx_desc[i].flags = ((i == TSEC_TX_NUM_DESC-1) ? TSEC_TXBD_W : 0);
331         }
332         bus_dmamap_sync(sc->tsec_tx_dtag, sc->tsec_tx_dmap, BUS_DMASYNC_PREREAD |
333             BUS_DMASYNC_PREWRITE);
334 
335         for (i = 0; i < TSEC_RX_NUM_DESC; i++) {
336                 rx_desc[i].bufptr = sc->rx_data[i].paddr;
337                 rx_desc[i].length = 0;
338                 rx_desc[i].flags = TSEC_RXBD_E | TSEC_RXBD_I |
339                     ((i == TSEC_RX_NUM_DESC-1) ? TSEC_RXBD_W : 0);
340         }
341         bus_dmamap_sync(sc->tsec_rx_dtag, sc->tsec_rx_dmap, BUS_DMASYNC_PREREAD |
342             BUS_DMASYNC_PREWRITE);
343 
344         /* Step 18: Initialize the maximum and minimum receive buffer length */
345         TSEC_WRITE(sc, TSEC_REG_MRBLR, TSEC_DEFAULT_MAX_RX_BUFFER_SIZE);
346         TSEC_WRITE(sc, TSEC_REG_MINFLR, TSEC_DEFAULT_MIN_RX_BUFFER_SIZE);
347 
348         /* Step 19: Enable Rx and RxBD sdata snooping */
349         TSEC_WRITE(sc, TSEC_REG_ATTR, TSEC_ATTR_RDSEN | TSEC_ATTR_RBDSEN);
350         TSEC_WRITE(sc, TSEC_REG_ATTRELI, 0);
351 
352         /* Step 20: Reset collision counters in hardware */
353         TSEC_WRITE(sc, TSEC_REG_MON_TSCL, 0);
354         TSEC_WRITE(sc, TSEC_REG_MON_TMCL, 0);
355         TSEC_WRITE(sc, TSEC_REG_MON_TLCL, 0);
356         TSEC_WRITE(sc, TSEC_REG_MON_TXCL, 0);
357         TSEC_WRITE(sc, TSEC_REG_MON_TNCL, 0);
358 
359         /* Step 21: Mask all CAM interrupts */
360         TSEC_WRITE(sc, TSEC_REG_MON_CAM1, 0xffffffff);
361         TSEC_WRITE(sc, TSEC_REG_MON_CAM2, 0xffffffff);
362 
363         /* Step 22: Enable Rx and Tx */
364         val = TSEC_READ(sc, TSEC_REG_MACCFG1);
365         val |= (TSEC_MACCFG1_RX_EN | TSEC_MACCFG1_TX_EN);
366         TSEC_WRITE(sc, TSEC_REG_MACCFG1, val);
367 
368         /* Step 23: Reset TSEC counters for Tx and Rx rings */
369         TSEC_TX_RX_COUNTERS_INIT(sc);
370 
371         /* Step 24: Activate timer for PHY */
372         callout_reset(&sc->tsec_tick_ch, hz, tsec_tick, sc);
373 
374         /* Step 25: Activate network interface */
375         ifp->if_drv_flags |= IFF_DRV_RUNNING;
376         ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
377         sc->tsec_if_flags = ifp->if_flags;
378 
379         /* Schedule watchdog timeout */
380         callout_reset(&sc->wd_callout, hz, tsec_tick, sc);
381 }
382 
383 static void
384 tsec_set_mac_address(struct tsec_softc *sc)
385 {
386         uint32_t macbuf[2] = { 0, 0 };
387         int i;
388         char *macbufp;
389         char *curmac;
390 
391         TSEC_GLOBAL_LOCK_ASSERT(sc);
392 
393         KASSERT((ETHER_ADDR_LEN <= sizeof(macbuf)),
394             ("tsec_set_mac_address: (%d <= %d",
395             ETHER_ADDR_LEN, sizeof(macbuf)));
396 
397         macbufp = (char *)macbuf;
398         curmac = (char *)IF_LLADDR(sc->tsec_ifp);
399 
400         /* Correct order of MAC address bytes */
401         for (i = 1; i <= ETHER_ADDR_LEN; i++)
402                 macbufp[ETHER_ADDR_LEN-i] = curmac[i-1];
403 
404         /* Initialize MAC station address MACSTNADDR2 and MACSTNADDR1 */
405         TSEC_WRITE(sc, TSEC_REG_MACSTNADDR2, macbuf[1]);
406         TSEC_WRITE(sc, TSEC_REG_MACSTNADDR1, macbuf[0]);
407 }
408 
409 /*
410  * DMA control function, if argument state is:
411  * 0 - DMA engine will be disabled
412  * 1 - DMA engine will be enabled
413  */
414 static void
415 tsec_dma_ctl(struct tsec_softc *sc, int state)
416 {
417         device_t dev;
418         uint32_t dma_flags;
419         uint32_t timeout;
420 
421         dev = sc->dev;
422 
423         dma_flags = TSEC_READ(sc, TSEC_REG_DMACTRL);
424 
425         switch (state) {
426         case 0:
427                 /* Temporarily clear stop graceful stop bits. */
428                 tsec_dma_ctl(sc, 1000);
429 
430                 /* Set it again */
431                 dma_flags |= (TSEC_DMACTRL_GRS | TSEC_DMACTRL_GTS);
432                 break;
433         case 1000:
434         case 1:
435                 /* Set write with response (WWR), wait (WOP) and snoop bits */
436                 dma_flags |= (TSEC_DMACTRL_TDSEN | TSEC_DMACTRL_TBDSEN |
437                     DMACTRL_WWR | DMACTRL_WOP);
438 
439                 /* Clear graceful stop bits */
440                 dma_flags &= ~(TSEC_DMACTRL_GRS | TSEC_DMACTRL_GTS);
441                 break;
442         default:
443                 device_printf(dev, "tsec_dma_ctl(): unknown state value: %d\n",
444                     state);
445         }
446 
447         TSEC_WRITE(sc, TSEC_REG_DMACTRL, dma_flags);
448 
449         switch (state) {
450         case 0:
451                 /* Wait for DMA stop */
452                 timeout = TSEC_READ_RETRY;
453                 while (--timeout && (!(TSEC_READ(sc, TSEC_REG_IEVENT) &
454                     (TSEC_IEVENT_GRSC | TSEC_IEVENT_GTSC))))
455                         DELAY(TSEC_READ_DELAY);
456 
457                 if (timeout == 0)
458                         device_printf(dev, "tsec_dma_ctl(): timeout!\n");
459                 break;
460         case 1:
461                 /* Restart transmission function */
462                 TSEC_WRITE(sc, TSEC_REG_TSTAT, TSEC_TSTAT_THLT);
463         }
464 }
465 
466 /*
467  * Interrupts control function, if argument state is:
468  * 0 - all TSEC interrupts will be masked
469  * 1 - all TSEC interrupts will be unmasked
470  */
471 static void
472 tsec_intrs_ctl(struct tsec_softc *sc, int state)
473 {
474         device_t dev;
475 
476         dev = sc->dev;
477 
478         switch (state) {
479         case 0:
480                 TSEC_WRITE(sc, TSEC_REG_IMASK, 0);
481                 break;
482         case 1:
483                 TSEC_WRITE(sc, TSEC_REG_IMASK, TSEC_IMASK_BREN |
484                     TSEC_IMASK_RXCEN | TSEC_IMASK_BSYEN |
485                     TSEC_IMASK_EBERREN | TSEC_IMASK_BTEN |
486                     TSEC_IMASK_TXEEN | TSEC_IMASK_TXBEN |
487                     TSEC_IMASK_TXFEN | TSEC_IMASK_XFUNEN |
488                     TSEC_IMASK_RXFEN
489                   );
490                 break;
491         default:
492                 device_printf(dev, "tsec_intrs_ctl(): unknown state value: %d\n",
493                     state);
494         }
495 }
496 
497 static void
498 tsec_reset_mac(struct tsec_softc *sc)
499 {
500         uint32_t maccfg1_flags;
501 
502         /* Set soft reset bit */
503         maccfg1_flags = TSEC_READ(sc, TSEC_REG_MACCFG1);
504         maccfg1_flags |= TSEC_MACCFG1_SOFT_RESET;
505         TSEC_WRITE(sc, TSEC_REG_MACCFG1, maccfg1_flags);
506 
507         /* Clear soft reset bit */
508         maccfg1_flags = TSEC_READ(sc, TSEC_REG_MACCFG1);
509         maccfg1_flags &= ~TSEC_MACCFG1_SOFT_RESET;
510         TSEC_WRITE(sc, TSEC_REG_MACCFG1, maccfg1_flags);
511 }
512 
513 static void
514 tsec_watchdog(struct tsec_softc *sc)
515 {
516         struct ifnet *ifp;
517 
518         TSEC_GLOBAL_LOCK_ASSERT(sc);
519 
520         if (sc->wd_timer == 0 || --sc->wd_timer > 0)
521                 return;
522 
523         ifp = sc->tsec_ifp;
524         ifp->if_oerrors++;
525         if_printf(ifp, "watchdog timeout\n");
526 
527         tsec_stop(sc);
528         tsec_init_locked(sc);
529 }
530 
531 static void
532 tsec_start(struct ifnet *ifp)
533 {
534         struct tsec_softc *sc = ifp->if_softc;
535 
536         TSEC_TRANSMIT_LOCK(sc);
537         tsec_start_locked(ifp);
538         TSEC_TRANSMIT_UNLOCK(sc);
539 }
540 
541 static void
542 tsec_start_locked(struct ifnet *ifp)
543 {
544         struct tsec_softc *sc;
545         struct mbuf *m0;
546         struct mbuf *mtmp;
547         unsigned int queued = 0;
548 
549         sc = ifp->if_softc;
550 
551         TSEC_TRANSMIT_LOCK_ASSERT(sc);
552 
553         if ((ifp->if_drv_flags & (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=
554             IFF_DRV_RUNNING)
555                 return;
556 
557         if (sc->tsec_link == 0)
558                 return;
559 
560         bus_dmamap_sync(sc->tsec_tx_dtag, sc->tsec_tx_dmap,
561             BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
562 
563         for (;;) {
564                 /* Get packet from the queue */
565                 IF_DEQUEUE(&ifp->if_snd, m0);
566                 if (m0 == NULL)
567                         break;
568 
569                 mtmp = m_defrag(m0, M_DONTWAIT);
570                 if (mtmp)
571                         m0 = mtmp;
572 
573                 if (tsec_encap(sc, m0)) {
574                         IF_PREPEND(&ifp->if_snd, m0);
575                         ifp->if_drv_flags |= IFF_DRV_OACTIVE;
576                         break;
577                 }
578                 queued++;
579                 BPF_MTAP(ifp, m0);
580         }
581         bus_dmamap_sync(sc->tsec_tx_dtag, sc->tsec_tx_dmap,
582             BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
583 
584         if (queued) {
585                 /* Enable transmitter and watchdog timer */
586                 TSEC_WRITE(sc, TSEC_REG_TSTAT, TSEC_TSTAT_THLT);
587                 sc->wd_timer = 5;
588         }
589 }
590 
591 static int
592 tsec_encap(struct tsec_softc *sc, struct mbuf *m0)
593 {
594         struct tsec_desc *tx_desc = NULL;
595         struct ifnet *ifp;
596         bus_dma_segment_t segs[TSEC_TX_NUM_DESC];
597         bus_dmamap_t *mapp;
598         int error;
599         int seg, nsegs;
600 
601         TSEC_TRANSMIT_LOCK_ASSERT(sc);
602 
603         ifp = sc->tsec_ifp;
604 
605         if (TSEC_FREE_TX_DESC(sc) == 0) {
606                 /* No free descriptors */
607                 return (-1);
608         }
609 
610         /* Fetch unused map */
611         mapp = TSEC_ALLOC_TX_MAP(sc);
612 
613         /* Create mapping in DMA memory */
614         error = bus_dmamap_load_mbuf_sg(sc->tsec_tx_mtag,
615            *mapp, m0, segs, &nsegs, BUS_DMA_NOWAIT);
616         if (error != 0 || nsegs > TSEC_FREE_TX_DESC(sc) || nsegs <= 0) {
617                 bus_dmamap_unload(sc->tsec_tx_mtag, *mapp);
618                 TSEC_FREE_TX_MAP(sc, mapp);
619                 return ((error != 0) ? error : -1);
620         }
621         bus_dmamap_sync(sc->tsec_tx_mtag, *mapp, BUS_DMASYNC_PREWRITE);
622 
623         if ((ifp->if_flags & IFF_DEBUG) && (nsegs > 1))
624                 if_printf(ifp, "TX buffer has %d segments\n", nsegs);
625 
626         /* Everything is ok, now we can send buffers */
627         for (seg = 0; seg < nsegs; seg++) {
628                 tx_desc = TSEC_GET_CUR_TX_DESC(sc);
629 
630                 tx_desc->length = segs[seg].ds_len;
631                 tx_desc->bufptr = segs[seg].ds_addr;
632 
633                 tx_desc->flags =
634                     (tx_desc->flags & TSEC_TXBD_W) | /* wrap */
635                     TSEC_TXBD_I |               /* interrupt */
636                     TSEC_TXBD_R |               /* ready to send */
637                     TSEC_TXBD_TC |              /* transmit the CRC sequence
638                                                  * after the last data byte */
639                     ((seg == nsegs-1) ? TSEC_TXBD_L : 0);/* last in frame */
640         }
641 
642         /* Save mbuf and DMA mapping for release at later stage */
643         TSEC_PUT_TX_MBUF(sc, m0);
644         TSEC_PUT_TX_MAP(sc, mapp);
645 
646         return (0);
647 }
648 
649 static void
650 tsec_setfilter(struct tsec_softc *sc)
651 {
652         struct ifnet *ifp;
653         uint32_t flags;
654 
655         ifp = sc->tsec_ifp;
656         flags = TSEC_READ(sc, TSEC_REG_RCTRL);
657 
658         /* Promiscuous mode */
659         if (ifp->if_flags & IFF_PROMISC)
660                 flags |= TSEC_RCTRL_PROM;
661         else
662                 flags &= ~TSEC_RCTRL_PROM;
663 
664         TSEC_WRITE(sc, TSEC_REG_RCTRL, flags);
665 }
666 
667 static int
668 tsec_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
669 {
670         struct tsec_softc *sc = ifp->if_softc;
671         struct ifreq *ifr = (struct ifreq *)data;
672         device_t dev;
673         int error = 0;
674 
675         dev = sc->dev;
676 
677         switch (command) {
678         case SIOCSIFFLAGS:
679                 TSEC_GLOBAL_LOCK(sc);
680                 if (ifp->if_flags & IFF_UP) {
681                         if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
682                                 if ((sc->tsec_if_flags ^ ifp->if_flags) &
683                                     IFF_PROMISC)
684                                         tsec_setfilter(sc);
685                         } else
686                                 tsec_init_locked(sc);
687                 } else {
688                         if (ifp->if_drv_flags & IFF_DRV_RUNNING)
689                                 tsec_stop(sc);
690                 }
691                 sc->tsec_if_flags = ifp->if_flags;
692                 TSEC_GLOBAL_UNLOCK(sc);
693                 break;
694         case SIOCGIFMEDIA:
695         case SIOCSIFMEDIA:
696                 error = ifmedia_ioctl(ifp, ifr, &sc->tsec_mii->mii_media,
697                     command);
698                 break;
699         default:
700                 error = ether_ioctl(ifp, command, data);
701         }
702 
703         /* Flush buffers if not empty */
704         if (ifp->if_flags & IFF_UP)
705                 tsec_start(ifp);
706         return (error);
707 }
708 
709 static int
710 tsec_ifmedia_upd(struct ifnet *ifp)
711 {
712         struct tsec_softc *sc = ifp->if_softc;
713         struct mii_data *mii;
714 
715         TSEC_TRANSMIT_LOCK(sc);
716 
717         mii = sc->tsec_mii;
718         mii_mediachg(mii);
719 
720         TSEC_TRANSMIT_UNLOCK(sc);
721         return (0);
722 }
723 
724 static void
725 tsec_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
726 {
727         struct tsec_softc *sc = ifp->if_softc;
728         struct mii_data *mii;
729 
730         TSEC_TRANSMIT_LOCK(sc);
731 
732         mii = sc->tsec_mii;
733         mii_pollstat(mii);
734 
735         ifmr->ifm_active = mii->mii_media_active;
736         ifmr->ifm_status = mii->mii_media_status;
737 
738         TSEC_TRANSMIT_UNLOCK(sc);
739 }
740 
741 static int
742 tsec_new_rxbuf(bus_dma_tag_t tag, bus_dmamap_t map, struct mbuf **mbufp,
743                uint32_t *paddr)
744 {
745         struct mbuf *new_mbuf;
746         bus_dma_segment_t seg[1];
747         int error;
748         int nsegs;
749 
750         KASSERT(mbufp != NULL, ("NULL mbuf pointer!"));
751 
752         new_mbuf = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
753         if (new_mbuf == NULL)
754                 return (ENOBUFS);
755         new_mbuf->m_len = new_mbuf->m_pkthdr.len = new_mbuf->m_ext.ext_size;
756 
757         if (*mbufp) {
758                 bus_dmamap_sync(tag, map, BUS_DMASYNC_POSTREAD);
759                 bus_dmamap_unload(tag, map);
760         }
761 
762         error = bus_dmamap_load_mbuf_sg(tag, map, new_mbuf, seg, &nsegs,
763             BUS_DMA_NOWAIT);
764         KASSERT(nsegs == 1, ("Too many segments returned!"));
765         if (nsegs != 1 || error)
766                 panic("tsec_new_rxbuf(): nsegs(%d), error(%d)", nsegs, error);
767 
768 #if 0
769         if (error) {
770                 printf("tsec: bus_dmamap_load_mbuf_sg() returned: %d!\n",
771                         error);
772                 m_freem(new_mbuf);
773                 return (ENOBUFS);
774         }
775 #endif
776 
777 #if 0
778         KASSERT(((seg->ds_addr) & (TSEC_RXBUFFER_ALIGNMENT-1)) == 0,
779                 ("Wrong alignment of RX buffer!"));
780 #endif
781         bus_dmamap_sync(tag, map, BUS_DMASYNC_PREREAD);
782 
783         (*mbufp) = new_mbuf;
784         (*paddr) = seg->ds_addr;
785         return (0);
786 }
787 
788 static void
789 tsec_map_dma_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)
790 {
791         u_int32_t *paddr;
792 
793         KASSERT(nseg == 1, ("wrong number of segments, should be 1"));
794         paddr = arg;
795         *paddr = segs->ds_addr;
796 }
797 
798 static int
799 tsec_alloc_dma_desc(device_t dev, bus_dma_tag_t *dtag, bus_dmamap_t *dmap,
800     bus_size_t dsize, void **vaddr, void *raddr, const char *dname)
801 {
802         int error;
803 
804         /* Allocate a busdma tag and DMA safe memory for TX/RX descriptors. */
805         error = bus_dma_tag_create(NULL,        /* parent */
806             PAGE_SIZE, 0,                       /* alignment, boundary */
807             BUS_SPACE_MAXADDR_32BIT,            /* lowaddr */
808             BUS_SPACE_MAXADDR,                  /* highaddr */
809             NULL, NULL,                         /* filtfunc, filtfuncarg */
810             dsize, 1,                           /* maxsize, nsegments */
811             dsize, 0,                           /* maxsegsz, flags */
812             NULL, NULL,                         /* lockfunc, lockfuncarg */
813             dtag);                              /* dmat */
814 
815         if (error) {
816                 device_printf(dev, "failed to allocate busdma %s tag\n", dname);
817                 (*vaddr) = NULL;
818                 return (ENXIO);
819         }
820 
821         error = bus_dmamem_alloc(*dtag, vaddr, BUS_DMA_NOWAIT | BUS_DMA_ZERO,
822             dmap);
823         if (error) {
824                 device_printf(dev, "failed to allocate %s DMA safe memory\n",
825                     dname);
826                 bus_dma_tag_destroy(*dtag);
827                 (*vaddr) = NULL;
828                 return (ENXIO);
829         }
830 
831         error = bus_dmamap_load(*dtag, *dmap, *vaddr, dsize, tsec_map_dma_addr,
832             raddr, BUS_DMA_NOWAIT);
833         if (error) {
834                 device_printf(dev, "cannot get address of the %s descriptors\n",
835                     dname);
836                 bus_dmamem_free(*dtag, *vaddr, *dmap);
837                 bus_dma_tag_destroy(*dtag);
838                 (*vaddr) = NULL;
839                 return (ENXIO);
840         }
841 
842         return (0);
843 }
844 
845 static void
846 tsec_free_dma_desc(bus_dma_tag_t dtag, bus_dmamap_t dmap, void *vaddr)
847 {
848 
849         if (vaddr == NULL)
850                 return;
851 
852         /* Unmap descriptors from DMA memory */
853         bus_dmamap_sync(dtag, dmap, BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
854         bus_dmamap_unload(dtag, dmap);
855 
856         /* Free descriptors memory */
857         bus_dmamem_free(dtag, vaddr, dmap);
858 
859         /* Destroy descriptors tag */
860         bus_dma_tag_destroy(dtag);
861 }
862 
863 static int
864 tsec_probe(device_t dev)
865 {
866         struct tsec_softc *sc;
867         device_t parent;
868         uintptr_t devtype;
869         int error;
870         uint32_t id;
871 
872         parent = device_get_parent(dev);
873 
874         error = BUS_READ_IVAR(parent, dev, OCPBUS_IVAR_DEVTYPE, &devtype);
875         if (error)
876                 return (error);
877         if (devtype != OCPBUS_DEVTYPE_TSEC)
878                 return (ENXIO);
879 
880         sc = device_get_softc(dev);
881 
882         sc->sc_rrid = 0;
883         sc->sc_rres = bus_alloc_resource(dev, SYS_RES_MEMORY, &sc->sc_rrid,
884             0ul, ~0ul, TSEC_IO_SIZE, RF_ACTIVE);
885         if (sc->sc_rres == NULL)
886                 return (ENXIO);
887 
888         sc->sc_bas.bsh = rman_get_bushandle(sc->sc_rres);
889         sc->sc_bas.bst = rman_get_bustag(sc->sc_rres);
890 
891         /* Check that we actually have a TSEC at this address */
892         id = TSEC_READ(sc, TSEC_REG_ID) | TSEC_READ(sc, TSEC_REG_ID2);
893 
894         bus_release_resource(dev, SYS_RES_MEMORY, sc->sc_rrid, sc->sc_rres);
895 
896         if (id == 0)
897                 return (ENXIO);
898 
899         device_set_desc(dev, "Three-Speed Ethernet Controller");
900         return (BUS_PROBE_DEFAULT);
901 }
902 
903 static int
904 tsec_attach(device_t dev)
905 {
906         uint8_t hwaddr[ETHER_ADDR_LEN];
907         struct tsec_softc *sc;
908         struct ifnet *ifp;
909         bus_dmamap_t *map_ptr;
910         bus_dmamap_t **map_pptr;
911         int error = 0;
912         int i;
913 
914         sc = device_get_softc(dev);
915         sc->dev = dev;
916 
917         if (device_get_unit(dev) == 0)
918                 tsec0_sc = sc; /* XXX */
919 
920         callout_init(&sc->tsec_tick_ch, 1);
921         mtx_init(&sc->transmit_lock, device_get_nameunit(dev), "TSEC TX lock",
922             MTX_DEF);
923         mtx_init(&sc->receive_lock, device_get_nameunit(dev), "TSEC RX lock",
924             MTX_DEF);
925 
926         /* Reset all TSEC counters */
927         TSEC_TX_RX_COUNTERS_INIT(sc);
928 
929         /* Allocate IO memory for TSEC registers */
930         sc->sc_rrid = 0;
931         sc->sc_rres = bus_alloc_resource(dev, SYS_RES_MEMORY, &sc->sc_rrid,
932             0ul, ~0ul, TSEC_IO_SIZE, RF_ACTIVE);
933         if (sc->sc_rres == NULL) {
934                 device_printf(dev, "could not allocate IO memory range!\n");
935                 tsec_detach(dev);
936                 return (ENXIO);
937         }
938         sc->sc_bas.bsh = rman_get_bushandle(sc->sc_rres);
939         sc->sc_bas.bst = rman_get_bustag(sc->sc_rres);
940 
941         /* Stop DMA engine if enabled by firmware */
942         tsec_dma_ctl(sc, 0);
943 
944         /* Reset MAC */
945         tsec_reset_mac(sc);
946 
947         /* Disable interrupts for now */
948         tsec_intrs_ctl(sc, 0);
949 
950         /* Allocate a busdma tag and DMA safe memory for TX descriptors. */
951         error = tsec_alloc_dma_desc(dev, &sc->tsec_tx_dtag, &sc->tsec_tx_dmap,
952             sizeof(*sc->tsec_tx_vaddr) * TSEC_TX_NUM_DESC,
953             (void **)&sc->tsec_tx_vaddr, &sc->tsec_tx_raddr, "TX");
954         if (error) {
955                 tsec_detach(dev);
956                 return (ENXIO);
957         }
958 
959         /* Allocate a busdma tag and DMA safe memory for RX descriptors. */
960         error = tsec_alloc_dma_desc(dev, &sc->tsec_rx_dtag, &sc->tsec_rx_dmap,
961             sizeof(*sc->tsec_rx_vaddr) * TSEC_RX_NUM_DESC,
962             (void **)&sc->tsec_rx_vaddr, &sc->tsec_rx_raddr, "RX");
963         if (error) {
964                 tsec_detach(dev);
965                 return (ENXIO);
966         }
967 
968         /* Allocate a busdma tag for TX mbufs. */
969         error = bus_dma_tag_create(NULL,        /* parent */
970             TSEC_TXBUFFER_ALIGNMENT, 0,         /* alignment, boundary */
971             BUS_SPACE_MAXADDR_32BIT,            /* lowaddr */
972             BUS_SPACE_MAXADDR,                  /* highaddr */
973             NULL, NULL,                         /* filtfunc, filtfuncarg */
974             MCLBYTES * (TSEC_TX_NUM_DESC - 1),  /* maxsize */
975             TSEC_TX_NUM_DESC - 1,               /* nsegments */
976             MCLBYTES, 0,                        /* maxsegsz, flags */
977             NULL, NULL,                         /* lockfunc, lockfuncarg */
978             &sc->tsec_tx_mtag);                 /* dmat */
979         if (error) {
980                 device_printf(dev, "failed to allocate busdma tag(tx mbufs)\n");
981                 tsec_detach(dev);
982                 return (ENXIO);
983         }
984 
985         /* Allocate a busdma tag for RX mbufs. */
986         error = bus_dma_tag_create(NULL,        /* parent */
987             TSEC_RXBUFFER_ALIGNMENT, 0,         /* alignment, boundary */
988             BUS_SPACE_MAXADDR_32BIT,            /* lowaddr */
989             BUS_SPACE_MAXADDR,                  /* highaddr */
990             NULL, NULL,                         /* filtfunc, filtfuncarg */
991             MCLBYTES,                           /* maxsize */
992             1,                                  /* nsegments */
993             MCLBYTES, 0,                                /* maxsegsz, flags */
994             NULL, NULL,                 /* lockfunc, lockfuncarg */
995             &sc->tsec_rx_mtag);                 /* dmat */
996         if (error) {
997                 device_printf(dev, "failed to allocate busdma tag(rx mbufs)\n");
998                 tsec_detach(dev);
999                 return (ENXIO);
1000         }
1001 
1002         /* Create TX busdma maps */
1003         map_ptr = sc->tx_map_data;
1004         map_pptr = sc->tx_map_unused_data;
1005 
1006         for (i = 0; i < TSEC_TX_NUM_DESC; i++) {
1007                 map_pptr[i] = &map_ptr[i];
1008                 error = bus_dmamap_create(sc->tsec_tx_mtag, 0,
1009                     map_pptr[i]);
1010                 if (error) {
1011                         device_printf(dev, "failed to init TX ring\n");
1012                         tsec_detach(dev);
1013                         return (ENXIO);
1014                 }
1015         }
1016 
1017         /* Create RX busdma maps and zero mbuf handlers */
1018         for (i = 0; i < TSEC_RX_NUM_DESC; i++) {
1019                 error = bus_dmamap_create(sc->tsec_rx_mtag, 0,
1020                     &sc->rx_data[i].map);
1021                 if (error) {
1022                         device_printf(dev, "failed to init RX ring\n");
1023                         tsec_detach(dev);
1024                         return (ENXIO);
1025                 }
1026                 sc->rx_data[i].mbuf = NULL;
1027         }
1028 
1029         /* Create mbufs for RX buffers */
1030         for (i = 0; i < TSEC_RX_NUM_DESC; i++) {
1031                 error = tsec_new_rxbuf(sc->tsec_rx_mtag, sc->rx_data[i].map,
1032                     &sc->rx_data[i].mbuf, &sc->rx_data[i].paddr);
1033                 if (error) {
1034                         device_printf(dev, "can't load rx DMA map %d, error = "
1035                             "%d\n", i, error);
1036                         tsec_detach(dev);
1037                         return (error);
1038                 }
1039         }
1040 
1041         /* Create network interface for upper layers */
1042         ifp = sc->tsec_ifp = if_alloc(IFT_ETHER);
1043         if (ifp == NULL) {
1044                 device_printf(dev, "if_alloc() failed\n");
1045                 tsec_detach(dev);
1046                 return (ENOMEM);
1047         }
1048 
1049         ifp->if_softc = sc;
1050         if_initname(ifp, device_get_name(dev), device_get_unit(dev));
1051         ifp->if_mtu = ETHERMTU;
1052         ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST;
1053         ifp->if_init = tsec_init;
1054         ifp->if_start = tsec_start;
1055         ifp->if_ioctl = tsec_ioctl;
1056 
1057         IFQ_SET_MAXLEN(&ifp->if_snd, TSEC_TX_NUM_DESC - 1);
1058         ifp->if_snd.ifq_drv_maxlen = TSEC_TX_NUM_DESC - 1;
1059         IFQ_SET_READY(&ifp->if_snd);
1060 
1061         /* XXX No special features of TSEC are supported currently */
1062         ifp->if_capabilities = 0;
1063         ifp->if_capenable = ifp->if_capabilities;
1064 
1065         /* Probe PHY(s) */
1066         error = mii_phy_probe(dev, &sc->tsec_miibus, tsec_ifmedia_upd,
1067             tsec_ifmedia_sts);
1068         if (error) {
1069                 device_printf(dev, "MII failed to find PHY!\n");
1070                 if_free(ifp);
1071                 sc->tsec_ifp = NULL;
1072                 tsec_detach(dev);
1073                 return (error);
1074         }
1075         sc->tsec_mii = device_get_softc(sc->tsec_miibus);
1076 
1077         tsec_get_hwaddr(sc, hwaddr);
1078         ether_ifattach(ifp, hwaddr);
1079         callout_init(&sc->wd_callout, 0);
1080 
1081         /* Interrupts configuration (TX/RX/ERR) */
1082         sc->sc_transmit_irid = OCP_TSEC_RID_TXIRQ;
1083         error = tsec_setup_intr(dev, &sc->sc_transmit_ires,
1084             &sc->sc_transmit_ihand, &sc->sc_transmit_irid,
1085             tsec_transmit_intr, "TX");
1086         if (error) {
1087                 tsec_detach(dev);
1088                 return (error);
1089         }
1090 
1091         sc->sc_receive_irid = OCP_TSEC_RID_RXIRQ;
1092         error = tsec_setup_intr(dev, &sc->sc_receive_ires,
1093             &sc->sc_receive_ihand, &sc->sc_receive_irid,
1094             tsec_receive_intr, "RX");
1095         if (error) {
1096                 tsec_detach(dev);
1097                 return (error);
1098         }
1099 
1100         sc->sc_error_irid = OCP_TSEC_RID_ERRIRQ;
1101         error = tsec_setup_intr(dev, &sc->sc_error_ires,
1102             &sc->sc_error_ihand, &sc->sc_error_irid,
1103             tsec_error_intr, "ERR");
1104         if (error) {
1105                 tsec_detach(dev);
1106                 return (error);
1107         }
1108 
1109         return (0);
1110 }
1111 
1112 static int
1113 tsec_setup_intr(device_t dev, struct resource **ires, void **ihand, int *irid,
1114     driver_intr_t handler, const char *iname)
1115 {
1116         struct tsec_softc *sc;
1117         int error;
1118 
1119         sc = device_get_softc(dev);
1120 
1121         (*ires) = bus_alloc_resource_any(dev, SYS_RES_IRQ, irid, RF_ACTIVE);
1122         if ((*ires) == NULL) {
1123                 device_printf(dev, "could not allocate %s IRQ\n", iname);
1124                 return (ENXIO);
1125         }
1126         error = bus_setup_intr(dev, *ires, INTR_TYPE_NET | INTR_MPSAFE,
1127             NULL, handler, sc, ihand);
1128         if (error) {
1129                 device_printf(dev, "failed to set up %s IRQ\n", iname);
1130                 if (bus_release_resource(dev, SYS_RES_IRQ, *irid, *ires))
1131                         device_printf(dev, "could not release %s IRQ\n", iname);
1132                 (*ires) = NULL;
1133                 return (error);
1134         }
1135         return (0);
1136 }
1137 
1138 static void
1139 tsec_release_intr(device_t dev, struct resource *ires, void *ihand, int irid,
1140     const char *iname)
1141 {
1142         int error;
1143 
1144         if (ires == NULL)
1145                 return;
1146 
1147         error = bus_teardown_intr(dev, ires, ihand);
1148         if (error)
1149                 device_printf(dev, "bus_teardown_intr() failed for %s intr"
1150                     ", error %d\n", iname, error);
1151 
1152         error = bus_release_resource(dev, SYS_RES_IRQ, irid, ires);
1153         if (error)
1154                 device_printf(dev, "bus_release_resource() failed for %s intr"
1155                     ", error %d\n", iname, error);
1156 }
1157 
1158 static void
1159 tsec_free_dma(struct tsec_softc *sc)
1160 {
1161         int i;
1162 
1163         /* Free TX maps */
1164         for (i = 0; i < TSEC_TX_NUM_DESC; i++)
1165                 if (sc->tx_map_data[i] != NULL)
1166                         bus_dmamap_destroy(sc->tsec_tx_mtag,
1167                             sc->tx_map_data[i]);
1168         /* Destroy tag for Tx mbufs */
1169         bus_dma_tag_destroy(sc->tsec_tx_mtag);
1170 
1171         /* Free RX mbufs and maps */
1172         for (i = 0; i < TSEC_RX_NUM_DESC; i++) {
1173                 if (sc->rx_data[i].mbuf) {
1174                         /* Unload buffer from DMA */
1175                         bus_dmamap_sync(sc->tsec_rx_mtag, sc->rx_data[i].map,
1176                             BUS_DMASYNC_POSTREAD);
1177                         bus_dmamap_unload(sc->tsec_rx_mtag, sc->rx_data[i].map);
1178 
1179                         /* Free buffer */
1180                         m_freem(sc->rx_data[i].mbuf);
1181                 }
1182                 /* Destroy map for this buffer */
1183                 if (sc->rx_data[i].map != NULL)
1184                         bus_dmamap_destroy(sc->tsec_rx_mtag,
1185                             sc->rx_data[i].map);
1186         }
1187         /* Destroy tag for Rx mbufs */
1188         bus_dma_tag_destroy(sc->tsec_rx_mtag);
1189 
1190         /* Unload TX/RX descriptors */
1191         tsec_free_dma_desc(sc->tsec_tx_dtag, sc->tsec_tx_dmap,
1192             sc->tsec_tx_vaddr);
1193         tsec_free_dma_desc(sc->tsec_rx_dtag, sc->tsec_rx_dmap,
1194             sc->tsec_rx_vaddr);
1195 }
1196 
1197 static int
1198 tsec_detach(device_t dev)
1199 {
1200         struct tsec_softc *sc;
1201         int error;
1202 
1203         sc = device_get_softc(dev);
1204 
1205         /* Stop TSEC controller and free TX queue */
1206         if (sc->sc_rres && sc->tsec_ifp)
1207                 tsec_shutdown(dev);
1208 
1209         /* Wait for stopping TSEC ticks */
1210         callout_drain(&sc->tsec_tick_ch);
1211 
1212         /* Stop and release all interrupts */
1213         tsec_release_intr(dev, sc->sc_transmit_ires, sc->sc_transmit_ihand,
1214             sc->sc_transmit_irid, "TX");
1215         tsec_release_intr(dev, sc->sc_receive_ires, sc->sc_receive_ihand,
1216             sc->sc_receive_irid, "RX");
1217         tsec_release_intr(dev, sc->sc_error_ires, sc->sc_error_ihand,
1218             sc->sc_error_irid, "ERR");
1219 
1220         /* Detach network interface */
1221         if (sc->tsec_ifp) {
1222                 ether_ifdetach(sc->tsec_ifp);
1223                 if_free(sc->tsec_ifp);
1224                 sc->tsec_ifp = NULL;
1225         }
1226 
1227         /* Free DMA resources */
1228         tsec_free_dma(sc);
1229 
1230         /* Free IO memory handler */
1231         if (sc->sc_rres) {
1232                 error = bus_release_resource(dev, SYS_RES_MEMORY, sc->sc_rrid,
1233                     sc->sc_rres);
1234                 if (error)
1235                         device_printf(dev, "bus_release_resource() failed for"
1236                             " IO memory, error %d\n", error);
1237         }
1238 
1239         /* Destroy locks */
1240         mtx_destroy(&sc->receive_lock);
1241         mtx_destroy(&sc->transmit_lock);
1242         return (0);
1243 }
1244 
1245 static void
1246 tsec_shutdown(device_t dev)
1247 {
1248         struct tsec_softc *sc;
1249 
1250         sc = device_get_softc(dev);
1251 
1252         TSEC_GLOBAL_LOCK(sc);
1253         tsec_stop(sc);
1254         TSEC_GLOBAL_UNLOCK(sc);
1255 }
1256 
1257 static int
1258 tsec_suspend(device_t dev)
1259 {
1260 
1261         /* TODO not implemented! */
1262         return (ENODEV);
1263 }
1264 
1265 static int
1266 tsec_resume(device_t dev)
1267 {
1268 
1269         /* TODO not implemented! */
1270         return (ENODEV);
1271 }
1272 
1273 static void
1274 tsec_stop(struct tsec_softc *sc)
1275 {
1276         struct ifnet *ifp;
1277         struct mbuf *m0;
1278         bus_dmamap_t *mapp;
1279         uint32_t tmpval;
1280 
1281         TSEC_GLOBAL_LOCK_ASSERT(sc);
1282 
1283         ifp = sc->tsec_ifp;
1284 
1285         /* Stop PHY tick engine */
1286         callout_stop(&sc->tsec_tick_ch);
1287 
1288         /* Disable interface and watchdog timer */
1289         ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
1290         sc->wd_timer = 0;
1291 
1292         /* Disable all interrupts and stop DMA */
1293         tsec_intrs_ctl(sc, 0);
1294         tsec_dma_ctl(sc, 0);
1295 
1296         /* Remove pending data from TX queue */
1297         while (!TSEC_EMPTYQ_TX_MBUF(sc)) {
1298                 m0 = TSEC_GET_TX_MBUF(sc);
1299                 mapp = TSEC_GET_TX_MAP(sc);
1300 
1301                 bus_dmamap_sync(sc->tsec_tx_mtag, *mapp, BUS_DMASYNC_POSTWRITE);
1302                 bus_dmamap_unload(sc->tsec_tx_mtag, *mapp);
1303 
1304                 TSEC_FREE_TX_MAP(sc, mapp);
1305                 m_freem(m0);
1306         }
1307 
1308         /* Disable Rx and Tx */
1309         tmpval = TSEC_READ(sc, TSEC_REG_MACCFG1);
1310         tmpval &= ~(TSEC_MACCFG1_RX_EN | TSEC_MACCFG1_TX_EN);
1311         TSEC_WRITE(sc, TSEC_REG_MACCFG1, tmpval);
1312         DELAY(10);
1313 }
1314 
1315 static void
1316 tsec_receive_intr(void *arg)
1317 {
1318         struct mbuf *rcv_mbufs[TSEC_RX_NUM_DESC];
1319         struct tsec_softc *sc = arg;
1320         struct tsec_desc *rx_desc;
1321         struct ifnet *ifp;
1322         struct rx_data_type *rx_data;
1323         struct mbuf *m;
1324         device_t dev;
1325         uint32_t i;
1326         int count;
1327         int c1 = 0;
1328         int c2;
1329         uint16_t flags;
1330         uint16_t length;
1331 
1332         ifp = sc->tsec_ifp;
1333         rx_data = sc->rx_data;
1334         dev = sc->dev;
1335 
1336         /* Confirm the interrupt was received by driver */
1337         TSEC_WRITE(sc, TSEC_REG_IEVENT, TSEC_IEVENT_RXB | TSEC_IEVENT_RXF);
1338 
1339         TSEC_RECEIVE_LOCK(sc);
1340 
1341         bus_dmamap_sync(sc->tsec_rx_dtag, sc->tsec_rx_dmap, BUS_DMASYNC_POSTREAD |
1342             BUS_DMASYNC_POSTWRITE);
1343 
1344         for (count = 0; /* count < TSEC_RX_NUM_DESC */; count++) {
1345                 rx_desc = TSEC_GET_CUR_RX_DESC(sc);
1346                 flags = rx_desc->flags;
1347 
1348                 /* Check if there is anything to receive */
1349                 if ((flags & TSEC_RXBD_E) || (count >= TSEC_RX_NUM_DESC)) {
1350                         /*
1351                          * Avoid generating another interrupt
1352                          */
1353                         if (flags & TSEC_RXBD_E)
1354                                 TSEC_WRITE(sc, TSEC_REG_IEVENT,
1355                                     TSEC_IEVENT_RXB | TSEC_IEVENT_RXF);
1356                         /*
1357                          * We didn't consume current descriptor and have to
1358                          * return it to the queue
1359                          */
1360                         TSEC_BACK_CUR_RX_DESC(sc);
1361                         break;
1362                 }
1363 
1364                 if (flags & (TSEC_RXBD_LG | TSEC_RXBD_SH | TSEC_RXBD_NO |
1365                     TSEC_RXBD_CR | TSEC_RXBD_OV | TSEC_RXBD_TR)) {
1366                         rx_desc->length = 0;
1367                         rx_desc->flags = (rx_desc->flags &
1368                             ~TSEC_RXBD_ZEROONINIT) | TSEC_RXBD_E | TSEC_RXBD_I;
1369                         continue;
1370                 }
1371 
1372                 if ((flags & TSEC_RXBD_L) == 0)
1373                         device_printf(dev, "buf is not the last in frame!\n");
1374 
1375                 /* Ok... process frame */
1376                 length = rx_desc->length - ETHER_CRC_LEN;
1377                 i = TSEC_GET_CUR_RX_DESC_CNT(sc);
1378 
1379                 m = rx_data[i].mbuf;
1380 
1381                 if (tsec_new_rxbuf(sc->tsec_rx_mtag, rx_data[i].map,
1382                     &rx_data[i].mbuf, &rx_data[i].paddr)) {
1383                         ifp->if_ierrors++;
1384                         continue;
1385                 }
1386                 /* Attach new buffer to descriptor, and clear flags */
1387                 rx_desc->bufptr = rx_data[i].paddr;
1388                 rx_desc->length = 0;
1389                 rx_desc->flags = (rx_desc->flags & ~TSEC_RXBD_ZEROONINIT) |
1390                     TSEC_RXBD_E | TSEC_RXBD_I;
1391 
1392                 /* Prepare buffer for upper layers */
1393                 m->m_pkthdr.rcvif = ifp;
1394                 m->m_pkthdr.len = m->m_len = length;
1395 
1396                 /* Save it for push */
1397                 rcv_mbufs[c1++] = m;
1398         }
1399 
1400         bus_dmamap_sync(sc->tsec_rx_dtag, sc->tsec_rx_dmap,
1401             BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
1402 
1403         TSEC_RECEIVE_UNLOCK(sc);
1404 
1405         /* Push it now */
1406         for (c2 = 0; c2 < c1; c2++)
1407                 (*ifp->if_input)(ifp, rcv_mbufs[c2]);
1408 }
1409 
1410 static void
1411 tsec_transmit_intr(void *arg)
1412 {
1413         struct tsec_softc *sc = arg;
1414         struct tsec_desc *tx_desc;
1415         struct ifnet *ifp;
1416         struct mbuf *m0;
1417         bus_dmamap_t *mapp;
1418         int send = 0;
1419 
1420         ifp = sc->tsec_ifp;
1421 
1422         /* Confirm the interrupt was received by driver */
1423         TSEC_WRITE(sc, TSEC_REG_IEVENT, TSEC_IEVENT_TXB | TSEC_IEVENT_TXF);
1424 
1425         TSEC_TRANSMIT_LOCK(sc);
1426 
1427         /* Update collision statistics */
1428         ifp->if_collisions += TSEC_READ(sc, TSEC_REG_MON_TNCL);
1429 
1430         /* Reset collision counters in hardware */
1431         TSEC_WRITE(sc, TSEC_REG_MON_TSCL, 0);
1432         TSEC_WRITE(sc, TSEC_REG_MON_TMCL, 0);
1433         TSEC_WRITE(sc, TSEC_REG_MON_TLCL, 0);
1434         TSEC_WRITE(sc, TSEC_REG_MON_TXCL, 0);
1435         TSEC_WRITE(sc, TSEC_REG_MON_TNCL, 0);
1436 
1437         bus_dmamap_sync(sc->tsec_tx_dtag, sc->tsec_tx_dmap, BUS_DMASYNC_POSTREAD |
1438             BUS_DMASYNC_POSTWRITE);
1439 
1440         while (TSEC_CUR_DIFF_DIRTY_TX_DESC(sc)) {
1441                 tx_desc = TSEC_GET_DIRTY_TX_DESC(sc);
1442                 if (tx_desc->flags & TSEC_TXBD_R) {
1443                         TSEC_BACK_DIRTY_TX_DESC(sc);
1444                         break;
1445                 }
1446 
1447                 if ((tx_desc->flags & TSEC_TXBD_L) == 0)
1448                         continue;
1449 
1450                 /*
1451                  * This is the last buf in this packet, so unmap and free it.
1452                  */
1453                 m0 = TSEC_GET_TX_MBUF(sc);
1454                 mapp = TSEC_GET_TX_MAP(sc);
1455 
1456                 bus_dmamap_sync(sc->tsec_tx_mtag, *mapp, BUS_DMASYNC_POSTWRITE);
1457                 bus_dmamap_unload(sc->tsec_tx_mtag, *mapp);
1458 
1459                 TSEC_FREE_TX_MAP(sc, mapp);
1460                 m_freem(m0);
1461 
1462                 ifp->if_opackets++;
1463                 send = 1;
1464         }
1465         bus_dmamap_sync(sc->tsec_tx_dtag, sc->tsec_tx_dmap,
1466             BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
1467 
1468         if (send) {
1469                 /* Now send anything that was pending */
1470                 ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
1471                 tsec_start_locked(ifp);
1472 
1473                 /* Stop watchdog if all sent */
1474                 if (TSEC_EMPTYQ_TX_MBUF(sc))
1475                         sc->wd_timer = 0;
1476         }
1477         TSEC_TRANSMIT_UNLOCK(sc);
1478 }
1479 
1480 static void
1481 tsec_error_intr(void *arg)
1482 {
1483         struct tsec_softc *sc = arg;
1484         struct ifnet *ifp;
1485         uint32_t eflags;
1486 
1487         ifp = sc->tsec_ifp;
1488 
1489         eflags = TSEC_READ(sc, TSEC_REG_IEVENT);
1490 
1491         if (ifp->if_flags & IFF_DEBUG)
1492                 if_printf(ifp, "tsec_error_intr(): event flags: 0x%x\n", eflags);
1493 
1494         /* Clear events bits in hardware */
1495         TSEC_WRITE(sc, TSEC_REG_IEVENT, TSEC_IEVENT_RXC | TSEC_IEVENT_BSY |
1496             TSEC_IEVENT_EBERR | TSEC_IEVENT_MSRO | TSEC_IEVENT_BABT |
1497             TSEC_IEVENT_TXC | TSEC_IEVENT_TXE | TSEC_IEVENT_LC |
1498             TSEC_IEVENT_CRL | TSEC_IEVENT_XFUN);
1499 
1500         if (eflags & TSEC_IEVENT_EBERR)
1501                 if_printf(ifp, "System bus error occurred during"
1502                     " a DMA transaction (flags: 0x%x)\n", eflags);
1503 
1504         /* Check transmitter errors */
1505         if (eflags & TSEC_IEVENT_TXE) {
1506                 ifp->if_oerrors++;
1507 
1508                 if (eflags & TSEC_IEVENT_LC)
1509                         ifp->if_collisions++;
1510 
1511                 TSEC_WRITE(sc, TSEC_REG_TSTAT, TSEC_TSTAT_THLT);
1512         }
1513         if (eflags & TSEC_IEVENT_BABT)
1514                 ifp->if_oerrors++;
1515 
1516         /* Check receiver errors */
1517         if (eflags & TSEC_IEVENT_BSY) {
1518                 ifp->if_ierrors++;
1519                 ifp->if_iqdrops++;
1520 
1521                 /* Get data from RX buffers */
1522                 tsec_receive_intr(arg);
1523 
1524                 /* Make receiver again active */
1525                 TSEC_WRITE(sc, TSEC_REG_RSTAT, TSEC_RSTAT_QHLT);
1526         }
1527         if (eflags & TSEC_IEVENT_BABR)
1528                 ifp->if_ierrors++;
1529 }
1530 
1531 static void
1532 tsec_tick(void *xsc)
1533 {
1534         struct tsec_softc *sc = xsc;
1535         struct ifnet *ifp;
1536         int link;
1537 
1538         TSEC_GLOBAL_LOCK(sc);
1539 
1540         tsec_watchdog(sc);
1541 
1542         ifp = sc->tsec_ifp;
1543         link = sc->tsec_link;
1544 
1545         mii_tick(sc->tsec_mii);
1546 
1547         if (link == 0 && sc->tsec_link == 1 && (!IFQ_DRV_IS_EMPTY(&ifp->if_snd)))
1548                 tsec_start_locked(ifp);
1549 
1550         /* Schedule another timeout one second from now. */
1551         callout_reset(&sc->wd_callout, hz, tsec_tick, sc);
1552 
1553         TSEC_GLOBAL_UNLOCK(sc);
1554 }
1555 
1556 static int
1557 tsec_miibus_readreg(device_t dev, int phy, int reg)
1558 {
1559         struct tsec_softc *sc;
1560         uint32_t timeout;
1561 
1562         sc = device_get_softc(dev);
1563 
1564         if (device_get_unit(dev) != phy)
1565                 return (0);
1566 
1567         sc = tsec0_sc;
1568 
1569         TSEC_WRITE(sc, TSEC_REG_MIIMADD, (phy << 8) | reg);
1570         TSEC_WRITE(sc, TSEC_REG_MIIMCOM, 0);
1571         TSEC_WRITE(sc, TSEC_REG_MIIMCOM, TSEC_MIIMCOM_READCYCLE);
1572 
1573         timeout = TSEC_READ_RETRY;
1574         while (--timeout && TSEC_READ(sc, TSEC_REG_MIIMIND) &
1575             (TSEC_MIIMIND_NOTVALID | TSEC_MIIMIND_BUSY))
1576                 DELAY(TSEC_READ_DELAY);
1577 
1578         if (timeout == 0)
1579                 device_printf(dev, "Timeout while reading from PHY!\n");
1580 
1581         return (TSEC_READ(sc, TSEC_REG_MIIMSTAT));
1582 }
1583 
1584 static void
1585 tsec_miibus_writereg(device_t dev, int phy, int reg, int value)
1586 {
1587         struct tsec_softc *sc;
1588         uint32_t timeout;
1589 
1590         sc = device_get_softc(dev);
1591 
1592         if (device_get_unit(dev) != phy)
1593                 device_printf(dev, "Trying to write to an alien PHY(%d)\n", phy);
1594 
1595         sc = tsec0_sc;
1596 
1597         TSEC_WRITE(sc, TSEC_REG_MIIMADD, (phy << 8) | reg);
1598         TSEC_WRITE(sc, TSEC_REG_MIIMCON, value);
1599 
1600         timeout = TSEC_READ_RETRY;
1601         while (--timeout && (TSEC_READ(sc, TSEC_REG_MIIMIND) & TSEC_MIIMIND_BUSY))
1602                 DELAY(TSEC_READ_DELAY);
1603 
1604         if (timeout == 0)
1605                 device_printf(dev, "Timeout while writing to PHY!\n");
1606 }
1607 
1608 static void
1609 tsec_miibus_statchg(device_t dev)
1610 {
1611         struct tsec_softc *sc;
1612         struct mii_data *mii;
1613         uint32_t ecntrl, id, tmp;
1614         int link;
1615 
1616         sc = device_get_softc(dev);
1617         mii = sc->tsec_mii;
1618         link = ((mii->mii_media_status & IFM_ACTIVE) ? 1 : 0);
1619 
1620         tmp = TSEC_READ(sc, TSEC_REG_MACCFG2) & ~TSEC_MACCFG2_IF;
1621 
1622         if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
1623                 tmp |= TSEC_MACCFG2_FULLDUPLEX;
1624         else
1625                 tmp &= ~TSEC_MACCFG2_FULLDUPLEX;
1626 
1627         switch (IFM_SUBTYPE(mii->mii_media_active)) {
1628         case IFM_1000_T:
1629         case IFM_1000_SX:
1630                 tmp |= TSEC_MACCFG2_GMII;
1631                 sc->tsec_link = link;
1632                 break;
1633         case IFM_100_TX:
1634         case IFM_10_T:
1635                 tmp |= TSEC_MACCFG2_MII;
1636                 sc->tsec_link = link;
1637                 break;
1638         case IFM_NONE:
1639                 if (link)
1640                         device_printf(dev, "No speed selected but link active!\n");
1641                 sc->tsec_link = 0;
1642                 return;
1643         default:
1644                 sc->tsec_link = 0;
1645                 device_printf(dev, "Unknown speed (%d), link %s!\n",
1646                     IFM_SUBTYPE(mii->mii_media_active),
1647                     ((link) ? "up" : "down"));
1648                 return;
1649         }
1650         TSEC_WRITE(sc, TSEC_REG_MACCFG2, tmp);
1651 
1652         /* XXX kludge - use circumstantial evidence for reduced mode. */
1653         id = TSEC_READ(sc, TSEC_REG_ID2);
1654         if (id & 0xffff) {
1655                 ecntrl = TSEC_READ(sc, TSEC_REG_ECNTRL) & ~TSEC_ECNTRL_R100M;
1656                 ecntrl |= (tmp & TSEC_MACCFG2_MII) ? TSEC_ECNTRL_R100M : 0;
1657                 TSEC_WRITE(sc, TSEC_REG_ECNTRL, ecntrl);
1658         }
1659 }
1660 

--------------------------------------------------------------------------------

[ source navigation ] [ diff markup ] [ identifier search ] [ freetext search ] [ file search ] 

--------------------------------------------------------------------------------
 

This page is part of the FreeBSD/Linux Linux Kernel Cross-Reference, and was automatically generated using a modified version of the LXR engine. 


diff -urN u-boot-temp/board/mpc8349ads/mpc8349ads.c u-boot-1.1.3/board/mpc8349ads/mpc8349ads.c
--- u-boot-temp/board/mpc8349ads/mpc8349ads.c	2005-08-13 18:53:35.000000000 -0500
+++ u-boot-1.1.3/board/mpc8349ads/mpc8349ads.c	2006-05-16 18:19:51.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright Freescale Semiconductor, Inc.
+ * Copyright (c) 2004-2006 Freescale Semiconductor, Inc.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -22,6 +22,8 @@
  * Change log:
  * 20050101: Eran Liberty (liberty@freescale.com)
  *           Initial file creating (porting from 85XX & 8260)
+ * Feb,2006: Dave Liu (r63238@freescale.com)
+ * 	     Enable DDR ECC support
  */
 
 #include <common.h>
@@ -31,36 +33,39 @@
 #include <i2c.h>
 #include <spd.h>
 #include <miiphy.h>
+#include <command.h>
 #if defined(CONFIG_PCI)
 #include <pci.h>
 #endif
 #if defined(CONFIG_SPD_EEPROM)
 #include <spd_sdram.h>
 #endif
+
+#if defined(CONFIG_DDR_ECC) && !defined(CONFIG_ECC_INIT_VIA_DDRC)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
 int fixed_sdram(void);
 void sdram_init(void);
 
 int board_early_init_f (void)
 {
 	volatile u8* bcsr = (volatile u8*)CFG_BCSR;
-
+	
 	/* Enable flash write */
 	bcsr[1] &= ~0x01;
-
+	
 	return 0;
 }
 
-
-#define ns2clk(ns) (ns / (1000000000 / CONFIG_8349_CLKIN) + 1)
-
 long int initdram (int board_type)
 {
 	volatile immap_t *im = (immap_t *)CFG_IMMRBAR;
 	u32 msize = 0;
-
+	
 	if ((im->sysconf.immrbar & IMMRBAR_BASE_ADDR) != (u32)im)
 		return -1;
-
+	
 	/* DDR SDRAM - Main SODIMM */
 	im->sysconf.ddrlaw[0].bar = CFG_DDR_BASE & LAWBAR_BAR;
 #if defined(CONFIG_SPD_EEPROM)
@@ -68,6 +73,13 @@
 #else
 	msize = fixed_sdram();
 #endif
+
+#if defined(CONFIG_DDR_ECC) && !defined(CONFIG_ECC_INIT_VIA_DDRC)
+	/*
+	 * Initialize DDR ECC byte
+	 */
+	ddr_enable_ecc(msize * 1024 * 1024);
+#endif
 	/*
 	 * Initialize SDRAM if it is on local bus.
 	 */
@@ -77,7 +89,6 @@
 	return (msize * 1024 * 1024);
 }
 
-
 #if !defined(CONFIG_SPD_EEPROM)
 /*************************************************************************
  *  fixed sdram init -- doesn't use serial presence detect.
@@ -91,8 +102,8 @@
 
 	msize = CFG_DDR_SIZE;
 	for (ddr_size = msize << 20, ddr_size_log2 = 0;
-	     (ddr_size > 1);
-	     ddr_size = ddr_size>>1, ddr_size_log2++) {
+		(ddr_size > 1);
+		ddr_size = ddr_size>>1, ddr_size_log2++) {
 		if (ddr_size & 1) {
 			return -1;
 		}
@@ -100,8 +111,7 @@
 	im->sysconf.ddrlaw[0].ar = LAWAR_EN | ((ddr_size_log2 - 1) & LAWAR_SIZE);
 #if (CFG_DDR_SIZE != 256)
 #warning Currenly any ddr size other than 256 is not supported
-#endif
-
+#endif	
 	im->ddr.csbnds[0].csbnds = 0x00100017;
 	im->ddr.csbnds[1].csbnds = 0x0018001f;
 	im->ddr.csbnds[2].csbnds = 0x00000007;
@@ -110,37 +120,31 @@
 	im->ddr.cs_config[1] = CFG_DDR_CONFIG;
 	im->ddr.cs_config[2] = CFG_DDR_CONFIG;
 	im->ddr.cs_config[3] = CFG_DDR_CONFIG;
-	im->ddr.timing_cfg_1 =
-		3 << TIMING_CFG1_PRETOACT_SHIFT |
-		7 << TIMING_CFG1_ACTTOPRE_SHIFT |
-		3 << TIMING_CFG1_ACTTORW_SHIFT  |
-		4 << TIMING_CFG1_CASLAT_SHIFT   |
-		3 << TIMING_CFG1_REFREC_SHIFT   |
-		3 << TIMING_CFG1_WRREC_SHIFT    |
-		2 << TIMING_CFG1_ACTTOACT_SHIFT |
-		1 << TIMING_CFG1_WRTORD_SHIFT;
+	im->ddr.timing_cfg_1 = 3 << TIMING_CFG1_PRETOACT_SHIFT |
+						7 << TIMING_CFG1_ACTTOPRE_SHIFT |
+						3 << TIMING_CFG1_ACTTORW_SHIFT  |
+						4 << TIMING_CFG1_CASLAT_SHIFT   |
+						3 << TIMING_CFG1_REFREC_SHIFT   |
+						3 << TIMING_CFG1_WRREC_SHIFT    |
+						2 << TIMING_CFG1_ACTTOACT_SHIFT |
+						1 << TIMING_CFG1_WRTORD_SHIFT;
 	im->ddr.timing_cfg_2 = 2 << TIMING_CFG2_WR_DATA_DELAY_SHIFT;
-	im->ddr.sdram_cfg =
-		SDRAM_CFG_SREN
+	im->ddr.sdram_cfg  = SDRAM_CFG_SREN
 #if defined(CONFIG_DDR_2T_TIMING)
-		| SDRAM_CFG_2T_EN
+						| SDRAM_CFG_2T_EN
 #endif
-		| 2 << SDRAM_CFG_SDRAM_TYPE_SHIFT;
-	im->ddr.sdram_mode =
-		0x2000 << SDRAM_MODE_ESD_SHIFT |
-		0x0162 << SDRAM_MODE_SD_SHIFT;
-
+						| 2 << SDRAM_CFG_SDRAM_TYPE_SHIFT;
+	im->ddr.sdram_mode = 0x2000 << SDRAM_MODE_ESD_SHIFT |
+						0x0162 << SDRAM_MODE_SD_SHIFT;
 	im->ddr.sdram_interval = 0x045B << SDRAM_INTERVAL_REFINT_SHIFT |
-		0x0100 << SDRAM_INTERVAL_BSTOPRE_SHIFT;
-	udelay(200);
-
+						0x0100 << SDRAM_INTERVAL_BSTOPRE_SHIFT;
+	udelay(200); 
 	im->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;
 
 	return msize;
 }
 #endif/*!CFG_SPD_EEPROM*/
 
-
 int checkboard (void)
 {
 	puts("Board: Freescale MPC8349ADS\n");
@@ -153,16 +157,16 @@
  */
 #ifndef CONFIG_PCI_PNP
 static struct pci_config_table pci_mpc83xxads_config_table[] = {
-	{PCI_ANY_ID,PCI_ANY_ID,PCI_ANY_ID,PCI_ANY_ID,
-	pci_cfgfunc_config_device, {PCI_ENET0_IOADDR,
-				    PCI_ENET0_MEMADDR,
-				    PCI_COMMON_MEMORY | PCI_COMMAND_MASTER
-	} },
-	{}
-}
+			{
+			PCI_ANY_ID,PCI_ANY_ID,PCI_ANY_ID,PCI_ANY_ID,
+			pci_cfgfunc_config_device,
+			{PCI_ENET0_IOADDR,
+			PCI_ENET0_MEMADDR,
+			PCI_COMMON_MEMORY | PCI_COMMAND_MASTER}
+			},
+			{}
+			}
 #endif
-
-
 volatile static struct pci_controller hose[] = {
 	{
 #ifndef CONFIG_PCI_PNP
@@ -183,14 +187,14 @@
 {
 #ifdef CONFIG_PCI
 	extern void pci_mpc83xx_init(volatile struct pci_controller *hose);
-
+	
 	pci_mpc83xx_init(hose);
 #endif /* CONFIG_PCI */
 }
 
 /*
- * if MPC8349ADS is soldered with SDRAM
- */
+if MPC8349ADS is soldered with SDRAM
+*/
 #if defined(CFG_BR2_PRELIM)  \
 	&& defined(CFG_OR2_PRELIM) \
 	&& defined(CFG_LBLAWBAR2_PRELIM) \
@@ -203,7 +207,7 @@
 sdram_init(void)
 {
 	volatile immap_t *immap = (immap_t *)CFG_IMMRBAR;
-	volatile lbus8349_t *lbc= &immap->lbus;
+	volatile lbus83xx_t *lbc= &immap->lbus;
 	uint *sdram_addr = (uint *)CFG_LBC_SDRAM_BASE;
 
 	puts("\n   SDRAM on Local Bus: ");
@@ -222,47 +226,46 @@
 	/*
 	 * Configure the SDRAM controller Machine Mode Register.
 	 */
-	lbc->lsdmr = CFG_LBC_LSDMR_5; /* 0x40636733; normal operation*/
+	lbc->lsdmr = CFG_LBC_LSDMR_5; /* 0x40636733-normal operation */
 
-	lbc->lsdmr = CFG_LBC_LSDMR_1; /*0x68636733;precharge all the banks*/
+	lbc->lsdmr = CFG_LBC_LSDMR_1; /* 0x68636733-precharge all the banks */
 	asm("sync");
 	*sdram_addr = 0xff;
 	udelay(100);
 
-	lbc->lsdmr = CFG_LBC_LSDMR_2;/*0x48636733;auto refresh*/
+	lbc->lsdmr = CFG_LBC_LSDMR_2;/* 0x48636733-auto refresh */
 	asm("sync");
-	/*1 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*2 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*3 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*4 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*5 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*6 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*7 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-	/*8 times*/
+
 	*sdram_addr = 0xff;
 	udelay(100);
-
-	/* 0x58636733;mode register write operation */
-	lbc->lsdmr = CFG_LBC_LSDMR_4;
+	
+	lbc->lsdmr = CFG_LBC_LSDMR_4; /* 0x58636733-mode register write operation */
 	asm("sync");
 	*sdram_addr = 0xff;
 	udelay(100);
 
-	lbc->lsdmr = CFG_LBC_LSDMR_5; /*0x40636733;normal operation*/
+	lbc->lsdmr = CFG_LBC_LSDMR_5; /* 0x40636733-normal operation */
 	asm("sync");
 	*sdram_addr = 0xff;
 	udelay(100);
@@ -271,6 +274,379 @@
 void
 sdram_init(void)
 {
-	put("SDRAM on Local Bus is NOT available!\n");
+	puts("SDRAM on Local Bus is NOT available!\n");
 }
 #endif
+
+#if defined(CONFIG_DDR_ECC) && defined(CONFIG_DDR_ECC_CMD)
+/*
+ * ECC user commands
+ */
+void ecc_print_status(void)
+{
+	volatile immap_t *immap = (immap_t *)CFG_IMMRBAR;
+	volatile ddr83xx_t *ddr = &immap->ddr;
+
+	printf("\nECC mode: %s\n\n", (ddr->sdram_cfg & SDRAM_CFG_ECC_EN) ? "ON" : "OFF");
+
+	/* Interrupts */
+	printf("Memory Error Interrupt Enable:\n");
+	printf("  Multiple-Bit Error Interrupt Enable: %d\n",
+			(ddr->err_int_en & ECC_ERR_INT_EN_MBEE) ? 1 : 0);
+	printf("  Single-Bit Error Interrupt Enable: %d\n",
+			(ddr->err_int_en & ECC_ERR_INT_EN_SBEE) ? 1 : 0);
+	printf("  Memory Select Error Interrupt Enable: %d\n\n",
+			(ddr->err_int_en & ECC_ERR_INT_EN_MSEE) ? 1 : 0);
+
+	/* Error disable */
+	printf("Memory Error Disable:\n");
+	printf("  Multiple-Bit Error Disable: %d\n",
+			(ddr->err_disable & ECC_ERROR_DISABLE_MBED) ? 1 : 0);
+	printf("  Sinle-Bit Error Disable: %d\n",
+			(ddr->err_disable & ECC_ERROR_DISABLE_SBED) ? 1 : 0);
+	printf("  Memory Select Error Disable: %d\n\n",
+			(ddr->err_disable & ECC_ERROR_DISABLE_MSED) ? 1 : 0);
+
+	/* Error injection */
+	printf("Memory Data Path Error Injection Mask High/Low: %08lx %08lx\n",
+			ddr->data_err_inject_hi, ddr->data_err_inject_lo);
+
+	printf("Memory Data Path Error Injection Mask ECC:\n");
+	printf("  ECC Mirror Byte: %d\n",
+			(ddr->ecc_err_inject & ECC_ERR_INJECT_EMB) ? 1 : 0);
+	printf("  ECC Injection Enable: %d\n",
+			(ddr->ecc_err_inject & ECC_ERR_INJECT_EIEN) ? 1 : 0);
+	printf("  ECC Error Injection Mask: 0x%02x\n\n",
+			ddr->ecc_err_inject & ECC_ERR_INJECT_EEIM);
+
+	/* SBE counter/threshold */
+	printf("Memory Single-Bit Error Management (0..255):\n");
+	printf("  Single-Bit Error Threshold: %d\n",
+			(ddr->err_sbe & ECC_ERROR_MAN_SBET) >> ECC_ERROR_MAN_SBET_SHIFT);
+	printf("  Single-Bit Error Counter: %d\n\n",
+			(ddr->err_sbe & ECC_ERROR_MAN_SBEC) >> ECC_ERROR_MAN_SBEC_SHIFT);
+
+	/* Error detect */
+	printf("Memory Error Detect:\n");
+	printf("  Multiple Memory Errors: %d\n",
+			(ddr->err_detect & ECC_ERROR_DETECT_MME) ? 1 : 0);
+	printf("  Multiple-Bit Error: %d\n",
+			(ddr->err_detect & ECC_ERROR_DETECT_MBE) ? 1 : 0);
+	printf("  Single-Bit Error: %d\n",
+			(ddr->err_detect & ECC_ERROR_DETECT_SBE) ? 1 : 0);
+	printf("  Memory Select Error: %d\n\n",
+			(ddr->err_detect & ECC_ERROR_DETECT_MSE) ? 1 : 0);
+
+	/* Capture data */
+	printf("Memory Error Address Capture: 0x%08lx\n", ddr->capture_address);
+	printf("Memory Data Path Read Capture High/Low: %08lx %08lx\n",
+			ddr->capture_data_hi, ddr->capture_data_lo);
+	printf("Memory Data Path Read Capture ECC: 0x%02x\n\n",
+		ddr->capture_ecc & CAPTURE_ECC_ECE);
+
+	printf("Memory Error Attributes Capture:\n");
+	printf("  Data Beat Number: %d\n",
+			(ddr->capture_attributes & ECC_CAPT_ATTR_BNUM) >> ECC_CAPT_ATTR_BNUM_SHIFT);
+	printf("  Transaction Size: %d\n",
+			(ddr->capture_attributes & ECC_CAPT_ATTR_TSIZ) >> ECC_CAPT_ATTR_TSIZ_SHIFT);
+	printf("  Transaction Source: %d\n",
+			(ddr->capture_attributes & ECC_CAPT_ATTR_TSRC) >> ECC_CAPT_ATTR_TSRC_SHIFT);
+	printf("  Transaction Type: %d\n",
+			(ddr->capture_attributes & ECC_CAPT_ATTR_TTYP) >> ECC_CAPT_ATTR_TTYP_SHIFT);
+	printf("  Error Information Valid: %d\n\n",
+			ddr->capture_attributes & ECC_CAPT_ATTR_VLD);
+}
+
+int do_ecc ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	volatile immap_t *immap = (immap_t *)CFG_IMMRBAR;
+	volatile ddr83xx_t *ddr = &immap->ddr;
+	volatile u32 val;
+	u64 *addr;
+	u32 count;
+	register u64 *i;
+	u32 ret[2];
+	u32 pattern[2];
+	u32 writeback[2];
+
+	pattern[0] = 0xfedcba98UL;
+	pattern[1] = 0x76543210UL;
+
+	writeback[0] = 0x01234567UL;
+	writeback[1] = 0x89abcdefUL;
+
+	if (argc > 4) {
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+	
+	if (argc == 2) {
+		if (strcmp(argv[1], "status") == 0) {
+			ecc_print_status();
+			return 0;
+		} else if (strcmp(argv[1], "captureclear") == 0) {
+			ddr->capture_address = 0;
+			ddr->capture_data_hi = 0;
+			ddr->capture_data_lo = 0;
+			ddr->capture_ecc = 0;
+			ddr->capture_attributes = 0;
+			return 0;
+		}
+	} 
+	
+	if (argc == 3) {
+		if (strcmp(argv[1], "sbecnt") == 0) {
+			val = simple_strtoul(argv[2], NULL, 10);
+			if (val > 255) {
+				printf("Incorrect Counter value, should be 0..255\n");
+				return 1;
+			}
+
+			val = (val << ECC_ERROR_MAN_SBEC_SHIFT);
+			val |= (ddr->err_sbe & ECC_ERROR_MAN_SBET);
+
+			ddr->err_sbe = val;
+			return 0;
+		} else if (strcmp(argv[1], "sbethr") == 0) {
+			val = simple_strtoul(argv[2], NULL, 10);
+			if (val > 255) {
+				printf("Incorrect Counter value, should be 0..255\n");
+				return 1;
+			}
+
+			val = (val << ECC_ERROR_MAN_SBET_SHIFT);
+			val |= (ddr->err_sbe & ECC_ERROR_MAN_SBEC);
+
+			ddr->err_sbe = val;
+			return 0;
+		} else if (strcmp(argv[1], "errdisable") == 0) {
+			val = ddr->err_disable;
+
+			if (strcmp(argv[2], "+sbe") == 0) {
+				val |= ECC_ERROR_DISABLE_SBED;
+			} else if (strcmp(argv[2], "+mbe") == 0) {
+				val |= ECC_ERROR_DISABLE_MBED;
+			} else if (strcmp(argv[2], "+mse") == 0) {
+				val |= ECC_ERROR_DISABLE_MSED;
+			} else if (strcmp(argv[2], "+all") == 0) {
+				val |= (ECC_ERROR_DISABLE_SBED | 
+					ECC_ERROR_DISABLE_MBED | 
+					ECC_ERROR_DISABLE_MSED);
+			} else if (strcmp(argv[2], "-sbe") == 0) {
+				val &= ~ECC_ERROR_DISABLE_SBED;
+			} else if (strcmp(argv[2], "-mbe") == 0) {
+				val &= ~ECC_ERROR_DISABLE_MBED;
+			} else if (strcmp(argv[2], "-mse") == 0) {
+				val &= ~ECC_ERROR_DISABLE_MSED;
+			} else if (strcmp(argv[2], "-all") == 0) {
+				val &= ~(ECC_ERROR_DISABLE_SBED | 
+					ECC_ERROR_DISABLE_MBED | 
+					ECC_ERROR_DISABLE_MSED);
+			} else {
+				printf("Incorrect err_disable field\n");
+				return 1;
+			}
+
+			ddr->err_disable = val;
+			__asm__ __volatile__ ("sync");
+			__asm__ __volatile__ ("isync");
+			return 0;
+		} else if (strcmp(argv[1], "errdetectclr") == 0) {
+			val = ddr->err_detect;
+
+			if (strcmp(argv[2], "mme") == 0) {
+				val |= ECC_ERROR_DETECT_MME;
+			} else if (strcmp(argv[2], "sbe") == 0) {
+				val |= ECC_ERROR_DETECT_SBE;
+			} else if (strcmp(argv[2], "mbe") == 0) {
+				val |= ECC_ERROR_DETECT_MBE;
+			} else if (strcmp(argv[2], "mse") == 0) {
+				val |= ECC_ERROR_DETECT_MSE;
+			} else if (strcmp(argv[2], "all") == 0) {
+				val |= (ECC_ERROR_DETECT_MME |
+					ECC_ERROR_DETECT_MBE |
+					ECC_ERROR_DETECT_SBE |
+					ECC_ERROR_DETECT_MSE);
+			} else {
+				printf("Incorrect err_detect field\n");
+				return 1;
+			}
+
+			ddr->err_detect = val;
+			return 0;
+		} else if (strcmp(argv[1], "injectdatahi") == 0) {
+			val = simple_strtoul(argv[2], NULL, 16);
+
+			ddr->data_err_inject_hi = val;
+			return 0;
+		} else if (strcmp(argv[1], "injectdatalo") == 0) {
+			val = simple_strtoul(argv[2], NULL, 16);
+
+			ddr->data_err_inject_lo = val;
+			return 0;
+		} else if (strcmp(argv[1], "injectecc") == 0) {
+			val = simple_strtoul(argv[2], NULL, 16);
+			if (val > 0xff) {
+				printf("Incorrect ECC inject mask, should be 0x00..0xff\n");
+				return 1;
+			}
+			val |= (ddr->ecc_err_inject & ~ECC_ERR_INJECT_EEIM);
+
+			ddr->ecc_err_inject = val;
+			return 0;
+		} else if (strcmp(argv[1], "inject") == 0) {
+			val = ddr->ecc_err_inject;
+
+			if (strcmp(argv[2], "en") == 0)
+				val |= ECC_ERR_INJECT_EIEN;
+			else if (strcmp(argv[2], "dis") == 0)
+				val &= ~ECC_ERR_INJECT_EIEN;
+			else
+				printf("Incorrect command\n");
+
+			ddr->ecc_err_inject = val;
+			__asm__ __volatile__ ("sync");
+			__asm__ __volatile__ ("isync");
+			return 0;
+		} else if (strcmp(argv[1], "mirror") == 0) {
+			val = ddr->ecc_err_inject;
+
+			if (strcmp(argv[2], "en") == 0)
+				val |= ECC_ERR_INJECT_EMB;
+			else if (strcmp(argv[2], "dis") == 0)
+				val &= ~ECC_ERR_INJECT_EMB;
+			else
+				printf("Incorrect command\n");
+
+			ddr->ecc_err_inject = val;
+			return 0;
+		}
+	}
+
+	if (argc == 4) {
+		if (strcmp(argv[1], "testdw") == 0) {
+			addr = (u64 *)simple_strtoul(argv[2], NULL, 16);
+			count = simple_strtoul(argv[3], NULL, 16);
+
+			if ((u32)addr % 8) {
+				printf("Address not alligned on double word boundary\n");
+				return 1;
+			}
+
+			disable_interrupts();
+
+			for (i = addr; i < addr + count; i++) {
+
+				/* enable injects */
+				ddr->ecc_err_inject |= ECC_ERR_INJECT_EIEN;
+				__asm__ __volatile__ ("sync");
+				__asm__ __volatile__ ("isync");
+
+				/* write memory location injecting errors */
+				ppcDWstore((u32*)i, pattern);
+
+				/* disable injects */
+				ddr->ecc_err_inject &= ~ECC_ERR_INJECT_EIEN;
+				__asm__ __volatile__ ("sync");
+				__asm__ __volatile__ ("isync");
+
+				/* read data, this generates ECC error */
+				ppcDWload((u32*)i, ret);
+
+				/* re-initialize memory, double word write the location again,
+				 * generates new ECC code this time */
+				ppcDWstore((u32*)i, writeback);
+
+			}
+			
+			enable_interrupts();
+
+			return 0;
+		}
+
+		if (strcmp(argv[1], "testword") == 0) {
+			addr = (u64 *)simple_strtoul(argv[2], NULL, 16);
+			count = simple_strtoul(argv[3], NULL, 16);
+
+			if ((u32)addr % 8) {
+				printf("Address not alligned on double word boundary\n");
+				return 1;
+			}
+
+			disable_interrupts();
+
+			for (i = addr; i < addr + count; i++) {
+
+				/* enable injects */
+				ddr->ecc_err_inject |= ECC_ERR_INJECT_EIEN;
+				__asm__ __volatile__ ("sync");
+				__asm__ __volatile__ ("isync");
+
+				/* write memory location injecting errors */
+				*(u32*)i = 0xfedcba98UL;
+				__asm__ __volatile__ ("sync");
+
+				/* sub double word write, bus will read-modify-write, generates ECC error */
+				*((u32*)i+1) = 0x76543210UL;
+				__asm__ __volatile__ ("sync");
+
+				/* disable injects */
+				ddr->ecc_err_inject &= ~ECC_ERR_INJECT_EIEN;
+				__asm__ __volatile__ ("sync");
+				__asm__ __volatile__ ("isync");
+
+				/* re-initialize memory, double word write the location again,
+				 * generates new ECC code this time */
+				ppcDWstore((u32*)i, writeback);
+
+			}
+			
+			enable_interrupts();
+
+			return 0;
+		}
+
+
+	}
+
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+}
+
+U_BOOT_CMD(
+	ecc,     4,     0,      do_ecc,
+	"ecc     - support for DDR ECC features\n",
+	"status              - print out status info\n"
+	"ecc captureclear        - clear capture regs data\n"
+	"ecc sbecnt <val>        - set Single-Bit Error counter\n"
+	"ecc sbethr <val>        - set Single-Bit Threshold\n"
+	"ecc errdisable <flag>   - clear/set disable Memory Error Disable, flag:\n"
+	"  [-|+]sbe - Single-Bit Error\n"
+	"  [-|+]mbe - Multiple-Bit Error\n"
+	"  [-|+]mse - Memory Select Error\n"
+	"  [-|+]all - all errors\n"
+	"ecc errdetectclr <flag> - clear Memory Error Detect, flag:\n"
+	"  mme - Multiple Memory Errors\n"
+	"  sbe - Single-Bit Error\n"
+	"  mbe - Multiple-Bit Error\n"
+	"  mse - Memory Select Error\n"
+	"  all - all errors\n"
+	"ecc injectdatahi <hi>  - set Memory Data Path Error Injection Mask High\n"
+	"ecc injectdatalo <lo>  - set Memory Data Path Error Injection Mask Low\n"
+	"ecc injectecc <ecc>    - set ECC Error Injection Mask\n"
+	"ecc inject <en|dis>    - enable/disable error injection\n"
+	"ecc mirror <en|dis>    - enable/disable mirror byte\n"
+	"ecc testdw <addr> <cnt>  - test mem region with double word access:\n"
+	"  - enables injects\n"
+	"  - writes pattern injecting errors with double word access\n"
+	"  - disables injects\n"
+	"  - reads pattern back with double word access, generates error\n"
+	"  - re-inits memory\n"
+	"ecc testword <addr> <cnt>  - test mem region with word access:\n"
+	"  - enables injects\n"
+	"  - writes pattern injecting errors with word access\n"
+	"  - writes pattern with word access, generates error\n"
+	"  - disables injects\n"
+	"  - re-inits memory"
+);
+#endif /* if defined(CONFIG_DDR_ECC) && defined(CONFIG_DDR_ECC_CMD) */
diff -urN u-boot-temp/doc/README.mpc8349ads u-boot-1.1.3/doc/README.mpc8349ads
--- u-boot-temp/doc/README.mpc8349ads	1969-12-31 18:00:00.000000000 -0600
+++ u-boot-1.1.3/doc/README.mpc8349ads	2006-05-16 18:16:43.000000000 -0500
@@ -0,0 +1,116 @@
+Freescale MPC8349E ADS Boards(MPC8349E PB board)
+------------------------------------------------
+1. Board Switches and Jumpers
+1.0 There are four Dual-In-Line Packages(DIP) Switches on MPC8349 ADS board.  
+    For some reason, the HW designers describe the switch settings
+    in terms of 0 and 1, and then map that to physical switches where
+    the label "On" refers to logic 0 and "Off" is logic 1.
+                                                                                                                             
+    Switch bits are numbered 1 through, like, 4 6 8 or 10, but the
+    bits may contribute to signals that are numbered based at 0,
+    and some of those signals may be high-bit-number-0 too.  Heed
+    well the names and labels and do not get confused.
+                                                                                                                             
+    "Off" == 1
+    "On"  == 0
+                                                                                                                             
+    SW18 is switch 18 as silk-screened onto the board.
+    SW4[8] is the bit labled 8 on Switch 4.
+    SW2[1:6] refers to bits labeled 1 through 6 in order on switch 2.
+    SW3[7:1] refers to bits labeled 7 through 1 in order on switch 3.
+    SW3[1:8]= 0000_0001 refers to bits labeled 1 through 6 is set as "On"
+	      and bits labeled 8 is set as "Off".
+                                                                                                                             
+1.1 For the MPC8349 Pilot Board
+                                                                                                                             
+    First, make sure the board default setting is consistent with the document
+    shipped with your board. Then apply the following setting:
+    SW3[1-8]= 0000_0100  (HRCW setting value is performed on local bus)
+    SW4[1-8]= 1010_1000  (TSEC as GMII mode, PCI 32 bit port, RCW is read from BCSR)
+    SW6[1-8]= 0000_1000  (core enable when boot)
+    SW7[1-8]= 0011_0000  (boot from flash on local bus by reading HRCW from BCSR)
+    JP1 1-2
+    JP2 open
+    JP3 close
+
+2. Memory Map
+
+2.1. The memory map should look pretty much like this:
+
+     0x0000_0000     0x7fff_ffff     DDR		     2G
+     0x8000_0000     0x9fff_ffff     PCI MEM		     512M
+     0xc000_0000     0xdfff_ffff     Rapid IO		     512M
+     0xe000_0000     0xe00f_ffff     CCSR		     1M
+     0xe200_0000     0xe2ff_ffff     PCI IO		     16M
+     0xf000_0000     0xf7ff_ffff     SDRAM		     128M
+     0xf800_0000     0xf80f_ffff     BCSR		     1M
+     0xfe00_0000     0xffff_ffff     FLASH (boot bank)	     16M
+
+
+3. Definitions
+
+3.1 Explanation of NEW definitions in:
+
+	include/configs/MPC8349ADS.h
+
+    CONFIG_MPC83XX	    MPC83XX family
+    CONFIG_MPC8349	    MPC8349 specific
+    CONFIG_MPC8349ADS	    MPC8349ADS board specific
+    CONFIG_TSEC_ENET	    Use on-chip 10/100/1000 ethernet
+
+
+4. Compilation
+
+4.1 Normal Compilation
+
+	Assuming you're using BASH shell:
+
+	export CROSS_COMPILE=your-cross-compile-prefix
+	cd u-boot
+	make distclean
+	make MPC8349ADS_config
+	make
+
+4.2 Enable PCI
+	PCI interface on MDS board can be enabled at compilation.
+		make distclean
+		make MPC8349ADS_PC133M_config
+		make
+	This will compile U-Boot to support PCI 33MHz.
+		
+		make distclean
+		make MPC8349ADS_PC166M_config
+		make
+	This will compile U-Boot to support PCI 66MHz. 
+
+
+5. Downloading and Flashing Images
+
+5.0 Download over serial line using Kermit:
+
+	loadb
+	[Drop to kermit:
+	    ^\c
+	    send <u-boot-bin-image>
+	    c
+	]
+
+
+    Or via tftp:
+
+        tftp 200000 u-boot.bin
+
+5.1 Reflash U-boot Image using U-boot
+
+	tftp 200000 u-boot.bin
+	protect off fe700000 fe73ffff
+	erase fe700000 fe73ffff
+	
+	cp.b 200000 fe700000 xxxx
+	protect on all
+
+You have to supply the correct byte count in HEX for 'xxxx'(appeared in tftp log) from the TFTP.
+
+
+6. Notes
+   The console baudrate for MPC8349ADS is 115200bps.
diff -urN u-boot-temp/drivers/tsec.c u-boot-1.1.3/drivers/tsec.c
--- u-boot-temp/drivers/tsec.c	2005-08-13 18:53:35.000000000 -0500
+++ u-boot-1.1.3/drivers/tsec.c	2006-05-16 18:22:10.000000000 -0500
@@ -6,14 +6,13 @@
  * terms of the GNU Public License, Version 2, incorporated
  * herein by reference.
  *
- * Copyright 2004 Freescale Semiconductor.
+ * Copyright (c) 2004-2006 Freescale Semiconductor, Inc.
  * (C) Copyright 2003, Motorola, Inc.
  * author Andy Fleming
  *
  */
 
 #include <config.h>
-#include <mpc85xx.h>
 #include <common.h>
 #include <malloc.h>
 #include <net.h>
@@ -34,68 +33,57 @@
 
 struct tsec_info_struct {
 	unsigned int phyaddr;
-	u32 flags;
+	unsigned int gigabit;
 	unsigned int phyregidx;
 };
 
-
 /* The tsec_info structure contains 3 values which the
  * driver uses to determine how to operate a given ethernet
  * device.  For now, the structure is initialized with the
  * knowledge that all current implementations have 2 TSEC
  * devices, and one FEC.  The information needed is:
- *  phyaddr - The address of the PHY which is attached to
- *	the given device.
+ * phyaddr - The address of the PHY which is attached to
+ * the given device.
  *
- *  flags - This variable indicates whether the device
- *	supports gigabit speed ethernet, and whether it should be
- *	in reduced mode.
+ * gigabit - This variable indicates whether the device
+ * supports gigabit speed ethernet
  *
- *  phyregidx - This variable specifies which ethernet device
- *	controls the MII Management registers which are connected
- *	to the PHY.  For 8540/8560, only TSEC1 (index 0) has
- *	access to the PHYs, so all of the entries have "0".
+ * phyregidx - This variable specifies which ethernet device
+ * controls the MII Management registers which are connected
+ * to the PHY.  For 8540/8560, only TSEC1 (index 0) has
+ * access to the PHYs, so all of the entries have "0".
  *
  * The values specified in the table are taken from the board's
  * config file in include/configs/.  When implementing a new
  * board with ethernet capability, it is necessary to define:
- *   TSEC1_PHY_ADDR
- *   TSEC1_PHYIDX
- *   TSEC2_PHY_ADDR
- *   TSEC2_PHYIDX
+ *	TSEC1_PHY_ADDR
+ *	TSEC1_PHYIDX
+ *	TSEC2_PHY_ADDR
+ *	TSEC2_PHYIDX
  *
  * and for 8560:
- *   FEC_PHY_ADDR
- *   FEC_PHYIDX
+ *	FEC_PHY_ADDR
+ *	FEC_PHYIDX
  */
 static struct tsec_info_struct tsec_info[] = {
-#if defined(CONFIG_MPC85XX_TSEC1) || defined(CONFIG_MPC83XX_TSEC1)
-	{TSEC1_PHY_ADDR, TSEC_GIGABIT, TSEC1_PHYIDX},
-#else
-	{ 0, 0, 0},
+#ifdef CONFIG_MPC85XX_TSEC1
+	{TSEC1_PHY_ADDR, 1, TSEC1_PHYIDX},
 #endif
-#if defined(CONFIG_MPC85XX_TSEC2) || defined(CONFIG_MPC83XX_TSEC2)
-	{TSEC2_PHY_ADDR, TSEC_GIGABIT, TSEC2_PHYIDX},
-#else
-	{ 0, 0, 0},
+#ifdef CONFIG_MPC85XX_TSEC2
+	{TSEC2_PHY_ADDR, 1, TSEC2_PHYIDX},
 #endif
 #ifdef CONFIG_MPC85XX_FEC
 	{FEC_PHY_ADDR, 0, FEC_PHYIDX},
-#else
-#    if defined(CONFIG_MPC85XX_TSEC3) || defined(CONFIG_MPC83XX_TSEC3)
-	{TSEC3_PHY_ADDR, TSEC_GIGABIT | TSEC_REDUCED, TSEC3_PHYIDX},
-#    else
-	{ 0, 0, 0},
-#    endif
-#    if defined(CONFIG_MPC85XX_TSEC4) || defined(CONFIG_MPC83XX_TSEC4)
-	{TSEC4_PHY_ADDR, TSEC_REDUCED, TSEC4_PHYIDX},
-#    else
-	{ 0, 0, 0},
-#    endif
+#endif
+#ifdef CONFIG_MPC83XX_TSEC1
+	{TSEC1_PHY_ADDR, 1, TSEC1_PHYIDX},
+#endif
+#ifdef CONFIG_MPC83XX_TSEC2
+	{TSEC2_PHY_ADDR, 1, TSEC2_PHYIDX},
 #endif
 };
 
-#define MAXCONTROLLERS	(4)
+#define MAXCONTROLLERS (sizeof(tsec_info)/sizeof(struct tsec_info_struct))
 
 static int relocated = 0;
 
@@ -124,7 +112,7 @@
 /* Initialize device structure. Returns success if PHY
  * initialization succeeded (i.e. if it recognizes the PHY)
  */
-int tsec_initialize(bd_t *bis, int index, char *devname)
+int tsec_initialize(bd_t *bis, int index)
 {
 	struct eth_device* dev;
 	int i;
@@ -143,14 +131,14 @@
 		return 0;
 
 	privlist[index] = priv;
-	priv->regs = (volatile tsec_t *)(TSEC_BASE_ADDR + index*TSEC_SIZE);
-	priv->phyregs = (volatile tsec_t *)(TSEC_BASE_ADDR +
-			tsec_info[index].phyregidx*TSEC_SIZE);
+	priv->regs = (volatile tsec_t *)(CFG_TSEC1 + index*TSEC_SIZE);
+	priv->phyregs = (volatile tsec_t *)(CFG_TSEC1
+		+ tsec_info[index].phyregidx*TSEC_SIZE);
 
 	priv->phyaddr = tsec_info[index].phyaddr;
-	priv->flags = tsec_info[index].flags;
+	priv->gigabit = tsec_info[index].gigabit;
 
-	sprintf(dev->name, devname);
+	sprintf(dev->name,CONFIG_ETHPRIME "%d", index);
 	dev->iobase = 0;
 	dev->priv   = priv;
 	dev->init   = tsec_init;
@@ -164,7 +152,6 @@
 
 	eth_register(dev);
 
-
 	/* Reset the MAC */
 	priv->regs->maccfg1 |= MACCFG1_SOFT_RESET;
 	priv->regs->maccfg1 &= ~(MACCFG1_SOFT_RESET);
@@ -173,11 +160,10 @@
 	return init_phy(dev);
 }
 
-
 /* Initializes data structures and registers for the controller,
- * and brings the interface up.	 Returns the link status, meaning
+ * and brings the interface up.  Returns the link status, meaning
  * that it returns success if the link is up, failure otherwise.
- * This allows u-boot to find the first active controller. */
+ * This allows u-boot to find the first active controller.*/
 int tsec_init(struct eth_device* dev, bd_t * bd)
 {
 	uint tempval;
@@ -193,10 +179,13 @@
 	regs->maccfg2 = MACCFG2_INIT_SETTINGS;
 
 	/* Init ECNTRL */
+#ifdef FIXME
+	regs->dmamr |= DMAMR_WETRPCB;
+#endif
 	regs->ecntrl = ECNTRL_INIT_SETTINGS;
 
 	/* Copy the station address into the address registers.
-	 * Backwards, because little endian MACS are dumb */
+	 * Backwards, because little endian MACS are dumb. */
 	for(i=0;i<MAC_ADDR_LEN;i++) {
 		tmpbuf[MAC_ADDR_LEN - 1 - i] = dev->enetaddr[i];
 	}
@@ -221,7 +210,6 @@
 
 }
 
-
 /* Write value to the device's PHY through the registers
  * specified in priv, modifying the register specified in regnum.
  * It will wait for the write to be done (or for a timeout to
@@ -243,7 +231,7 @@
 
 
 /* Reads register regnum on the device's PHY through the
- * registers specified in priv.	 It lowers and raises the read
+ * registers specified in priv.  It lowers and raises the read
  * command, and waits for the data to become valid (miimind
  * notvalid bit cleared), and the bus to cease activity (miimind
  * busy bit cleared), and then returns the value
@@ -261,7 +249,6 @@
 	/* Clear the command register, and wait */
 	regbase->miimcom = 0;
 	asm("sync");
-
 	/* Initiate a read command, and wait */
 	regbase->miimcom = MIIM_READ_COMMAND;
 	asm("sync");
@@ -275,7 +262,6 @@
 	return value;
 }
 
-
 /* Discover which PHY is attached to the device, and configure it
  * properly.  If the PHY is not recognized, then return 0
  * (failure).  Otherwise, return 1
@@ -286,21 +272,7 @@
 	struct phy_info *curphy;
 
 	/* Assign a Physical address to the TBI */
-
-	{
-		volatile tsec_t *regs = (volatile tsec_t *)(TSEC_BASE_ADDR);
-		regs->tbipa = TBIPA_VALUE;
-		regs = (volatile tsec_t *)(TSEC_BASE_ADDR + TSEC_SIZE);
-		regs->tbipa = TBIPA_VALUE;
-		asm("sync");
-	}
-
-	/* Reset MII (due to new addresses) */
-	priv->phyregs->miimcfg = MIIMCFG_RESET;
-	asm("sync");
-	priv->phyregs->miimcfg = MIIMCFG_INIT_VALUE;
-	asm("sync");
-	while(priv->phyregs->miimind & MIIMIND_BUSY);
+	priv->regs->tbipa=TBIPA_VALUE;
 
 	if(0 == relocated)
 		relocate_cmds();
@@ -318,22 +290,22 @@
 	priv->phyinfo = curphy;
 
 	phy_run_commands(priv, priv->phyinfo->config);
+	
+	udelay(1000); /* FIXME */
 
 	return 1;
 }
 
-
 /* Returns which value to write to the control register. */
 /* For 10/100, the value is slightly different */
 uint mii_cr_init(uint mii_reg, struct tsec_private *priv)
 {
-	if(priv->flags & TSEC_GIGABIT)
+	if(priv->gigabit)
 		return MIIM_CONTROL_INIT;
 	else
 		return MIIM_CR_INIT;
 }
 
-
 /* Parse the status register for link, and then do
  * auto-negotiation */
 uint mii_parse_sr(uint mii_reg, struct tsec_private *priv)
@@ -353,7 +325,6 @@
 	return 0;
 }
 
-
 /* Parse the 88E1011's status register for speed and duplex
  * information */
 uint mii_parse_88E1011_psr(uint mii_reg, struct tsec_private *priv)
@@ -447,13 +418,6 @@
 	return MIIM_CIS8204_SLEDCON_INIT;
 }
 
-uint mii_cis8204_setmode(uint mii_reg, struct tsec_private *priv)
-{
-	if (priv->flags & TSEC_REDUCED)
-		return MIIM_CIS8204_EPHYCON_INIT | MIIM_CIS8204_EPHYCON_RGMII;
-	else
-		return MIIM_CIS8204_EPHYCON_INIT;
-}
 
 /* Initialized required registers to appropriate values, zeroing
  * those we don't care about (unless zero is bad, in which case,
@@ -523,15 +487,6 @@
 			case 10:
 				regs->maccfg2 = ((regs->maccfg2&~(MACCFG2_IF))
 					| MACCFG2_MII);
-
-				/* If We're in reduced mode, we need
-				 * to say whether we're 10 or 100 MB.
-				 */
-				if ((priv->speed == 100)
-				    && (priv->flags & TSEC_REDUCED))
-					regs->ecntrl |= ECNTRL_R100;
-				else
-					regs->ecntrl &= ~(ECNTRL_R100);
 				break;
 			default:
 				printf("%s: Speed was bad\n", dev->name);
@@ -588,9 +543,9 @@
 	regs->dmactrl &= ~(DMACTRL_GRS | DMACTRL_GTS);
 }
 
-/* This returns the status bits of the device.	The return value
+/* This returns the status bits of the device.  The return value
  * is never checked, and this is what the 8260 driver did, so we
- * do the same.	 Presumably, this would be zero if there were no
+ * do the same.  Presumably, this would be zero if there were no
  * errors */
 static int tsec_send(struct eth_device* dev, volatile void *packet, int length)
 {
@@ -598,7 +553,7 @@
 	int result = 0;
 	struct tsec_private *priv = (struct tsec_private *)dev->priv;
 	volatile tsec_t *regs = priv->regs;
-
+	
 	/* Find an empty buffer descriptor */
 	for(i=0; rtx.txbd[txIdx].status & TXBD_READY; i++) {
 		if (i >= TOUT_LOOP) {
@@ -714,12 +669,12 @@
 	},
 };
 
-struct phy_info phy_info_M88E1111S = {
-	0x01410cc,
-	"Marvell 88E1111S",
+struct phy_info phy_info_M88E1111 = {
+	0x001410cc,
+	"Marvell 88E1111",
 	4,
 	(struct phy_cmd[]) { /* config */
-	  /* Reset and configure the PHY */
+		/* Reset and configure the PHY */
 		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
 		{0x1d, 0x1f, NULL},
 		{0x1e, 0x200c, NULL},
@@ -733,7 +688,7 @@
 		{miim_end,}
 	},
 	(struct phy_cmd[]) { /* startup */
-	  /* Status is read once to clear old link state */
+		/* Status is read once to clear old link state */
 		{MIIM_STATUS, miim_read, NULL},
 		/* Auto-negotiate */
 		{MIIM_STATUS, miim_read, &mii_parse_sr},
@@ -756,7 +711,7 @@
 		/* Configure some basic stuff */
 		{MIIM_CONTROL, MIIM_CONTROL_INIT, &mii_cr_init},
 		{MIIM_CIS8204_SLED_CON, MIIM_CIS8204_SLEDCON_INIT, &mii_cis8204_fixled},
-		{MIIM_CIS8204_EPHY_CON, MIIM_CIS8204_EPHYCON_INIT, &mii_cis8204_setmode},
+		{MIIM_CIS8204_EPHY_CON, MIIM_CIS8204_EPHYCON_INIT, NULL},
 		{miim_end,}
 	},
 	(struct phy_cmd[]) { /* startup */
@@ -832,72 +787,17 @@
 	},
 };
 
-uint mii_parse_lxt971_sr2(uint mii_reg, struct tsec_private *priv)
-{
-	unsigned int speed;
-	if (priv->link) {
-		speed = mii_reg & MIIM_LXT971_SR2_SPEED_MASK;
-
-		switch (speed) {
-		case MIIM_LXT971_SR2_10HDX:
-			priv->speed = 10;
-			priv->duplexity = 0;
-			break;
-		case MIIM_LXT971_SR2_10FDX:
-			priv->speed = 10;
-			priv->duplexity = 1;
-			break;
-		case MIIM_LXT971_SR2_100HDX:
-			priv->speed = 100;
-			priv->duplexity = 0;
-		default:
-			priv->speed = 100;
-			priv->duplexity = 1;
-			break;
-		}
-	} else {
-		priv->speed = 0;
-		priv->duplexity = 0;
-	}
-
-	return 0;
-}
-
-static struct phy_info phy_info_lxt971 = {
-	0x0001378e,
-	"LXT971",
-	4,
-	(struct phy_cmd []) {  /* config */
-		{ MIIM_CR, MIIM_CR_INIT, mii_cr_init }, /* autonegotiate */
-		{ miim_end, }
-	},
-	(struct phy_cmd []) {  /* startup - enable interrupts */
-		/* { 0x12, 0x00f2, NULL }, */
-		{ MIIM_STATUS, miim_read, NULL },
-		{ MIIM_STATUS, miim_read, &mii_parse_sr },
-		{ MIIM_LXT971_SR2, miim_read, &mii_parse_lxt971_sr2 },
-		{ miim_end, }
-	},
-	(struct phy_cmd []) {  /* shutdown - disable interrupts */
-		{ miim_end, }
-	},
-};
-
 struct phy_info *phy_info[] = {
-#if 0
-	&phy_info_cis8201,
-#endif
 	&phy_info_cis8204,
 	&phy_info_M88E1011S,
-	&phy_info_M88E1111S,
+	&phy_info_M88E1111,
 	&phy_info_dm9161,
-	&phy_info_lxt971,
 	NULL
 };
 
 
 /* Grab the identifier of the device's PHY, and search through
- * all of the known PHYs to see if one matches.	 If so, return
+ * all of the known PHYs to see if one matches.  If so, return
  * it, if not, return NULL */
 struct phy_info * get_phy_info(struct eth_device *dev)
 {
diff -urN u-boot-temp/drivers/tsec.h u-boot-1.1.3/drivers/tsec.h
--- u-boot-temp/drivers/tsec.h	2005-08-13 18:53:35.000000000 -0500
+++ u-boot-1.1.3/drivers/tsec.h	2006-05-16 18:16:43.000000000 -0500
@@ -20,24 +20,11 @@
 #include <net.h>
 #include <config.h>
 
-#ifndef CFG_TSEC1_OFFSET
-    #define CFG_TSEC1_OFFSET	(0x24000)
-#endif
-
 #define TSEC_SIZE	0x01000
 
-/* FIXME:  Should these be pushed back to 83xx and 85xx config files? */
-#if defined(CONFIG_MPC85xx)
-    #define TSEC_BASE_ADDR	(CFG_IMMR + CFG_TSEC1_OFFSET)
-#elif defined(CONFIG_MPC83XX)
-    #define TSEC_BASE_ADDR	(CFG_IMMRBAR + CFG_TSEC1_OFFSET)
-#endif
-
-
 #define MAC_ADDR_LEN 6
 
-/* #define TSEC_TIMEOUT 	1000000 */
-#define TSEC_TIMEOUT 1000
+#define TSEC_TIMEOUT 	1000000
 #define TOUT_LOOP 	1000000
 
 /* MAC register bits */
@@ -62,7 +49,6 @@
 
 #define ECNTRL_INIT_SETTINGS	0x00001000
 #define ECNTRL_TBI_MODE         0x00000020
-#define ECNTRL_R100		0x00000008
 
 #define miim_end -2
 #define miim_read -1
@@ -119,7 +105,6 @@
 /* Cicada 8204 Extended PHY Control Register 1 */
 #define MIIM_CIS8204_EPHY_CON		0x17
 #define MIIM_CIS8204_EPHYCON_INIT	0x0006
-#define MIIM_CIS8204_EPHYCON_RGMII	0x1000
 
 /* Cicada 8204 Serial LED Control Register */
 #define MIIM_CIS8204_SLED_CON		0x1b
@@ -155,21 +140,17 @@
 #define MIIM_DM9161_10BTCSR	0x12
 #define MIIM_DM9161_10BTCSR_INIT	0x7800
 
-/* LXT971 Status 2 registers */
-#define MIIM_LXT971_SR2       	17  /* Status Register 2  */
-#define MIIM_LXT971_SR2_SPEED_MASK	0xf000
-#define MIIM_LXT971_SR2_10HDX	0x1000  /* 10 Mbit half duplex selected */
-#define MIIM_LXT971_SR2_10FDX	0x2000  /* 10 Mbit full duplex selected */
-#define MIIM_LXT971_SR2_100HDX	0x4000  /* 100 Mbit half duplex selected */
-#define MIIM_LXT971_SR2_100FDX	0x8000  /* 100 Mbit full duplex selected */
-
 #define MIIM_READ_COMMAND       0x00000001
 
 #define MRBLR_INIT_SETTINGS	PKTSIZE_ALIGN
 
 #define MINFLR_INIT_SETTINGS	0x00000040
 
+#ifdef FIXME
+#define DMACTRL_INIT_SETTINGS   0x000000c2
+#else
 #define DMACTRL_INIT_SETTINGS   0x000000c3
+#endif
 #define DMACTRL_GRS             0x00000010
 #define DMACTRL_GTS             0x00000008
 
@@ -203,12 +184,10 @@
 #define IMASK_TXFEN             0x00100000
 #define IMASK_RXFEN0		0x00000080
 
-
 /* Default Attribute fields */
 #define ATTR_INIT_SETTINGS     0x000000c0
 #define ATTRELI_INIT_SETTINGS  0x00000000
 
-
 /* TxBD status field bits */
 #define TXBD_READY		0x8000
 #define TXBD_PADCRC		0x4000
@@ -242,18 +221,21 @@
 #define RXBD_TRUNCATED		0x0001
 #define RXBD_STATS		0x003f
 
+/* DMA Maintenance register */
+#define DMAMR_WETRPCB   0x00200000
+
 typedef struct txbd8
 {
-	ushort       status;         /* Status Fields */
-	ushort       length;         /* Buffer length */
-	uint         bufPtr;         /* Buffer Pointer */
+	ushort       status;	/* Status Fields */
+	ushort       length;	/* Buffer length */
+	uint         bufPtr;	/* Buffer Pointer */
 } txbd8_t;
 
 typedef struct rxbd8
 {
-	ushort       status;         /* Status Fields */
-	ushort       length;         /* Buffer Length */
-	uint         bufPtr;         /* Buffer Pointer */
+	ushort       status;	/* Status Fields */
+	ushort       length;	/* Buffer Length */
+	uint         bufPtr;	/* Buffer Pointer */
 } rxbd8_t;
 
 typedef struct rmon_mib
@@ -352,7 +334,9 @@
 	uint	dmactrl;	/* DMA Control */
 	uint	tbipa;		/* TBI PHY Address */
 
-	uint	res034[3];
+	uint    res034[1];
+	uint    dmamr;      /* DMA Maintenance register */
+	uint	res03c[1];
 	uint	res040[48];
 
 	/* Transmit Control and Status Registers (0x2_n100) */
@@ -366,12 +350,12 @@
 	uint	tbptr;		/* TxBD Pointer */
 	uint	res188[30];
 	/* (0x2_n200) */
-	uint        res200;
+	uint	res200;
 	uint	tbase;		/* TxBD Base Address */
 	uint	res208[42];
 	uint	ostbd;		/* Out of Sequence TxBD */
 	uint	ostbdp;		/* Out of Sequence Tx Data Buffer Pointer */
-	uint        res2b8[18];
+	uint	res2b8[18];
 
 	/* Receive Control and Status Registers (0x2_n300) */
 	uint	rctrl;		/* Receive Control */
@@ -379,17 +363,17 @@
 	uint	res308;
 	uint	rbdlen;		/* RxBD Data Length */
 	uint	res310[4];
-	uint        res320;
+	uint	res320;
 	uint	crbptr; 	/* Current Receive Buffer Pointer */
 	uint	res328[6];
 	uint	mrblr;  	/* Maximum Receive Buffer Length */
 	uint	res344[16];
 	uint	rbptr;   	/* RxBD Pointer */
-	uint        res388[30];
+	uint	res388[30];
 	/* (0x2_n400) */
-	uint        res400;
+	uint	res400;
 	uint	rbase;  	/* RxBD Base Address */
-	uint        res408[62];
+	uint	res408[62];
 
 	/* MAC Registers (0x2_n500) */
 	uint	maccfg1;	/* MAC Configuration #1 */
@@ -421,34 +405,28 @@
 
 	/* RMON MIB Registers (0x2_n680-0x2_n73c) */
 	rmon_mib_t	rmon;
-	uint	res740[48];
+	uint		res740[48];
 
 	/* Hash Function Registers (0x2_n800) */
 	tsec_hash_t	hash;
 
-	uint        res900[128];
+	uint		res900[128];
 
 	/* Pattern Registers (0x2_nb00) */
-	uint        resb00[62];
-	uint        attr;          /* Default Attribute Register */
-	uint        attreli;       /* Default Attribute Extract Length and Index */
+	uint		resb00[62];
+	uint		attr;          /* Default Attribute Register */
+	uint		attreli;       /* Default Attribute Extract Length and Index */
 
 	/* TSEC Future Expansion Space (0x2_nc00-0x2_nffc) */
-	uint	resc00[256];
+	uint		resc00[256];
 } tsec_t;
 
-#define TSEC_GIGABIT (1)
-
-/* This flag currently only has
- * meaning if we're using the eTSEC */
-#define TSEC_REDUCED (1 << 1)
-
 struct tsec_private {
 	volatile tsec_t *regs;
 	volatile tsec_t *phyregs;
 	struct phy_info *phyinfo;
 	uint phyaddr;
-	u32 flags;
+	uint gigabit;
 	uint link;
 	uint duplexity;
 	uint speed;
@@ -470,9 +448,9 @@
  *	to the PHY register
  */
 struct phy_cmd {
-    uint mii_reg;
-    uint mii_data;
-    uint (*funct) (uint mii_reg, struct tsec_private* priv);
+		uint mii_reg;
+		uint mii_data;
+		uint (*funct) (uint mii_reg, struct tsec_private* priv);
 };
 
 /* struct phy_info: a structure which defines attributes for a PHY
@@ -488,18 +466,18 @@
  * commands which tell the driver what to do to the PHY.
  */
 struct phy_info {
-    uint id;
-    char *name;
-    uint shift;
-    /* Called to configure the PHY, and modify the controller
-     * based on the results */
-    struct phy_cmd *config;
+		uint id;
+		char *name;
+		uint shift;
+		/* Called to configure the PHY, and modify the controller
+		 * based on the results */
+		struct phy_cmd *config;
 
-    /* Called when starting up the controller */
-    struct phy_cmd *startup;
+		/* Called when starting up the controller */
+		struct phy_cmd *startup;
 
-    /* Called when bringing down the controller */
-    struct phy_cmd *shutdown;
+		/* Called when bringing down the controller */
+		struct phy_cmd *shutdown;
 };
 
 #endif /* __TSEC_H */
diff -urN u-boot-temp/include/asm-ppc/immap_8349.h u-boot-1.1.3/include/asm-ppc/immap_8349.h
--- u-boot-temp/include/asm-ppc/immap_8349.h	1969-12-31 18:00:00.000000000 -0600
+++ u-boot-1.1.3/include/asm-ppc/immap_8349.h	2006-05-16 18:16:43.000000000 -0500
@@ -0,0 +1,1168 @@
+/*
+ * MPC8349 Internal Memory Map
+ * Copyright (c) 2004-2006 Freescale Semiconductor, Inc.
+ * Eran Liberty (liberty@freescale.com)
+ * 
+ * based on:
+ * - MPC8260 Internal Memory Map
+ *   Copyright (c) 1999 Dan Malek (dmalek@jlc.net)
+ * - MPC85xx Internal Memory Map
+ *   Copyright(c) 2002,2003 Motorola Inc.
+ *   Xianghua Xiao (x.xiao@motorola.com)
+ */
+#ifndef __IMMAP_8349__
+#define __IMMAP_8349__
+
+#include <asm/types.h>
+#include <asm/i2c.h>
+
+/* 
+ * Local Access Window.
+ */
+typedef struct law83xx {
+	u32 bar; /* LBIU local access window base address register */
+#define LAWBAR_BAR         0xFFFFF000 /*Identifies the 20 most-significant
+					address bits of the base of local access window n. 
+					The specified base address should be aligned to the
+					window size, as defined by LBLAWARn[SIZE]. */
+#define LAWBAR_RES	     ~(LAWBAR_BAR)
+	u32 ar; /* LBIU local access window attribute register */
+/*
+ * This Macro were moved into mmu.h
+ */
+#if 0
+#define LAWAR_EN           0x80000000	/*0 The local bus local access window n is disabled.
+					1 The local bus local access window n is enabled 
+					/and other LBLAWAR0 and LBLAWBAR0 fields combine to
+					identify an address range for this window. */
+#define LAWAR_SIZE         0x0000003F	/* Identifies the size of the window from the starting address.
+					 Window size is 2^(SIZE+1) bytes. 000000001010Reserved.
+					 Window is undefined. */
+#define	LAWAR_SIZE_4K	0x0000000B
+#define	LAWAR_SIZE_8K	0x0000000C
+#define	LAWAR_SIZE_16K	0x0000000D
+#define	LAWAR_SIZE_32K	0x0000000E
+#define	LAWAR_SIZE_64K	0x0000000F
+#define	LAWAR_SIZE_128K	0x00000010
+#define	LAWAR_SIZE_256K	0x00000011
+#define	LAWAR_SIZE_512K	0x00000012
+#define	LAWAR_SIZE_1M	0x00000013
+#define	LAWAR_SIZE_2M	0x00000014
+#define	LAWAR_SIZE_4M	0x00000015
+#define	LAWAR_SIZE_8M	0x00000016
+#define	LAWAR_SIZE_16M	0x00000017
+#define	LAWAR_SIZE_32M	0x00000018
+#define	LAWAR_SIZE_64M	0x00000019
+#define	LAWAR_SIZE_128M	0x0000001A
+#define	LAWAR_SIZE_256M	0x0000001B
+#define	LAWAR_SIZE_512M	0x0000001C
+#define	LAWAR_SIZE_1G	0x0000001D
+#define	LAWAR_SIZE_2G	0x0000001E
+#define LAWAR_RES          ~(LAWAR_EN|LAWAR_SIZE)
+#endif
+
+} law83xx_t;
+
+/* 
+ * System configuration registers.
+ */
+typedef struct sysconf83xx {
+	u32 immrbar; /* Internal memory map base address register */
+	u8 res0[0x04];
+	u32 altcbar; /* Alternate configuration base address register */
+#define ALTCBAR_BASE_ADDR     0xFFF00000 /* Identifies the12 most significant
+					 address bits of an alternate base address
+					 used for boot sequencer configuration accesses. */
+#define ALTCBAR_RES           ~(ALTCBAR_BASE_ADDR) /* Reserved. Write has no effect, read returns 0. */
+	u8 res1[0x14];
+	law83xx_t lblaw[4]; 	/* LBIU local access window */
+	u8 res2[0x20];
+	law83xx_t pcilaw[2];	/* PCI local access window */
+	u8 res3[0x30];
+	law83xx_t ddrlaw[2];	/* DDR local access window */
+	u8 res4[0x50];
+	u32 sgprl;		/* System General Purpose Register Low */
+	u32 sgprh; /* System General Purpose Register High */
+	u32 spridr; /* System Part and Revision ID Register */
+#define SPRIDR_PARTID         0xFFFF0000 /* Part Identification. */
+#define SPRIDR_REVID          0x0000FFFF /* Revision Identification. */
+	u8 res5[0x04];
+	u32 spcr; /* System Priority Configuration Register */
+#define SPCR_PCIHPE   0x10000000 /* PCI Highest Priority Enable. */
+#define SPCR_PCIPR    0x03000000 /* PCI bridge system bus request priority. */
+#define SPCR_TBEN     0x00400000 /* E300 PowerPC core time base unit enable. */
+#define SPCR_COREPR   0x00300000 /* E300 PowerPC Core system bus request priority. */
+#define SPCR_TSEC1DP  0x00003000 /* TSEC1 data priority. */
+#define SPCR_TSEC1BDP 0x00000C00 /* TSEC1 buffer descriptor priority. */
+#define SPCR_TSEC1EP  0x00000300 /* TSEC1 emergency priority. */
+#define SPCR_TSEC2DP  0x00000030 /* TSEC2 data priority. */
+#define SPCR_TSEC2BDP 0x0000000C /* TSEC2 buffer descriptor priority. */
+#define SPCR_TSEC2EP  0x00000003 /* TSEC2 emergency priority. */
+#define SPCR_RES      ~(SPCR_PCIHPE|SPCR_PCIPR|SPCR_TBEN|SPCR_COREPR|SPCR_TSEC1DP \
+			 |SPCR_TSEC1BDP|SPCR_TSEC1EP|SPCR_TSEC2DP|SPCR_TSEC2BDP|SPCR_TSEC2EP)
+	u32 sicrl; /* System General Purpose Register Low */
+#define SICRL_LDP_A   0x80000000
+#define SICRL_USB0    0x40000000
+#define SICRL_USB1    0x20000000
+#define SICRL_UART    0x0C000000
+#define SICRL_GPIO1_A 0x02000000
+#define SICRL_GPIO1_B 0x01000000
+#define SICRL_GPIO1_C 0x00800000
+#define SICRL_GPIO1_D 0x00400000
+#define SICRL_GPIO1_E 0x00200000
+#define SICRL_GPIO1_F 0x00180000
+#define SICRL_GPIO1_G 0x00040000
+#define SICRL_GPIO1_H 0x00020000
+#define SICRL_GPIO1_I 0x00010000
+#define SICRL_GPIO1_J 0x00008000
+#define SICRL_GPIO1_K 0x00004000
+#define SICRL_GPIO1_L 0x00003000
+#define SICRL_RES	 ~(SICRL_LDP_A|SICRL_USB0|SICRL_USB1|SICRL_UART|SICRL_GPIO1_A \
+			|SICRL_GPIO1_B|SICRL_GPIO1_C|SICRL_GPIO1_D|SICRL_GPIO1_E \
+			|SICRL_GPIO1_F|SICRL_GPIO1_G|SICRL_GPIO1_H|SICRL_GPIO1_I \
+			|SICRL_GPIO1_J|SICRL_GPIO1_K|SICRL_GPIO1_L )
+	u32 sicrh; /* System General Purpose Register High */
+#define SICRH_DDR     0x80000000
+#define SICRH_TSEC1_A 0x10000000
+#define SICRH_TSEC1_B 0x08000000
+#define SICRH_TSEC1_C 0x04000000
+#define SICRH_TSEC1_D 0x02000000
+#define SICRH_TSEC1_E 0x01000000
+#define SICRH_TSEC1_F 0x00800000
+#define SICRH_TSEC2_A 0x00400000
+#define SICRH_TSEC2_B 0x00200000
+#define SICRH_TSEC2_C 0x00100000
+#define SICRH_TSEC2_D 0x00080000
+#define SICRH_TSEC2_E 0x00040000
+#define SICRH_TSEC2_F 0x00020000
+#define SICRH_TSEC2_G 0x00010000
+#define SICRH_TSEC2_H 0x00008000
+#define SICRH_GPIO2_A 0x00004000
+#define SICRH_GPIO2_B 0x00002000
+#define SICRH_GPIO2_C 0x00001000
+#define SICRH_GPIO2_D 0x00000800
+#define SICRH_GPIO2_E 0x00000400
+#define SICRH_GPIO2_F 0x00000200
+#define SICRH_GPIO2_G 0x00000180
+#define SICRH_GPIO2_H 0x00000060
+#define SICRH_TSOBI1  0x00000002
+#define SICRH_TSOBI2  0x00000001
+#define SICRh_RES     ~(SICRH_DDR|SICRH_TSEC1_A|SICRH_TSEC1_B|SICRH_TSEC1_C \
+			|SICRH_TSEC1_D|SICRH_TSEC1_E|SICRH_TSEC1_F|SICRH_TSEC2_A \
+			|SICRH_TSEC2_B|SICRH_TSEC2_C|SICRH_TSEC2_D|SICRH_TSEC2_E \
+			|SICRH_TSEC2_F|SICRH_TSEC2_G|SICRH_TSEC2_H|SICRH_GPIO2_A \
+			|SICRH_GPIO2_B|SICRH_GPIO2_C|SICRH_GPIO2_D|SICRH_GPIO2_E \
+			|SICRH_GPIO2_F|SICRH_GPIO2_G|SICRH_GPIO2_H|SICRH_TSOBI1  \
+			|SICRH_TSOBI2)
+	u8 res6[0xE4];
+} sysconf83xx_t;
+
+/* 
+ * Watch Dog Timer (WDT) Registers
+ */
+typedef struct wdt83xx {
+	u8 res0[4];
+	u32 swcrr; /* System watchdog control register */
+	u32 swcnr; /* System watchdog count register */
+#define SWCNR_SWCN 0x0000FFFF Software Watchdog Count Field.
+#define SWCNR_RES  ~(SWCNR_SWCN)
+	u8 res1[2];
+	u16 swsrr; /* System watchdog service register */
+	u8 res2[0xF0];
+} wdt83xx_t;
+ 
+/*
+ * RTC/PIT Module Registers
+ */
+typedef struct rtclk83xx {
+	u32 cnr; /* control register */
+#define CNR_CLEN 0x00000080 /* Clock Enable Control Bit  */
+#define CNR_CLIN 0x00000040 /* Input Clock Control Bit  */
+#define CNR_AIM  0x00000002 /* Alarm Interrupt Mask Bit  */
+#define CNR_SIM  0x00000001 /* Second Interrupt Mask Bit  */
+#define CNR_RES  ~(CNR_CLEN | CNR_CLIN | CNR_AIM | CNR_SIM)
+	u32 ldr; /* load register */
+	u32 psr; /* prescale register */
+	u32 ctr; /* register */
+	u32 evr; /* event register */
+#define RTEVR_SIF  0x00000001 /* Second Interrupt Flag Bit  */
+#define RTEVR_AIF  0x00000002 /* Alarm Interrupt Flag Bit  */
+#define RTEVR_RES  ~(EVR_SIF | EVR_AIF)
+	u32 alr; /* alarm register */
+	u8 res0[0xE8];
+} rtclk83xx_t;
+
+/*
+ * Global timper module
+ */
+
+typedef struct gtm83xx {
+		u8    cfr1; /* Timer1/2 Configuration  */
+#define CFR1_PCAS 0x80 /* Pair Cascade mode  */
+#define CFR1_BCM  0x40 /* Backward compatible mode  */
+#define CFR1_STP2 0x20 /* Stop timer  */
+#define CFR1_RST2 0x10 /* Reset timer  */
+#define CFR1_GM2  0x08 /* Gate mode for pin 2  */
+#define CFR1_GM1  0x04 /* Gate mode for pin 1  */
+#define CFR1_STP1 0x02 /* Stop timer  */
+#define CFR1_RST1 0x01 /* Reset timer  */
+		u8    res0[3];
+		u8    cfr2; /* Timer3/4 Configuration  */
+#define CFR2_PCAS 0x80 /* Pair Cascade mode  */
+#define CFR2_SCAS 0x40 /* Super Cascade mode  */
+#define CFR2_STP4 0x20 /* Stop timer  */
+#define CFR2_RST4 0x10 /* Reset timer  */
+#define CFR2_GM4  0x08 /* Gate mode for pin 4  */
+#define CFR2_GM3  0x04 /* Gate mode for pin 3  */
+#define CFR2_STP3 0x02 /* Stop timer  */
+#define CFR2_RST3 0x01 /* Reset timer  */
+		u8    res1[10];
+		u16   mdr1; /* Timer1 Mode Register  */
+#define MDR_SPS  0xff00 /* Secondary Prescaler value  */
+#define MDR_CE   0x00c0 /* Capture edge and enable interrupt  */
+#define MDR_OM   0x0020 /* Output mode  */
+#define MDR_ORI  0x0010 /* Output reference interrupt enable  */
+#define MDR_FRR  0x0008 /* Free run/restart  */
+#define MDR_ICLK 0x0006 /* Input clock source for the timer  */
+#define MDR_GE   0x0001 /* Gate enable  */
+		u16   mdr2; /* Timer2 Mode Register  */
+		u16   rfr1; /* Timer1 Reference Register  */
+		u16   rfr2; /* Timer2 Reference Register  */
+		u16   cpr1; /* Timer1 Capture Register  */
+		u16   cpr2; /* Timer2 Capture Register  */
+		u16   cnr1; /* Timer1 Counter Register  */
+		u16   cnr2; /* Timer2 Counter Register  */
+		u16   mdr3; /* Timer3 Mode Register  */
+		u16   mdr4; /* Timer4 Mode Register  */
+		u16   rfr3; /* Timer3 Reference Register  */
+		u16   rfr4; /* Timer4 Reference Register  */
+		u16   cpr3; /* Timer3 Capture Register  */
+		u16   cpr4; /* Timer4 Capture Register  */
+		u16   cnr3; /* Timer3 Counter Register  */
+		u16   cnr4; /* Timer4 Counter Register  */
+		u16   evr1; /* Timer1 Event Register  */
+		u16   evr2; /* Timer2 Event Register  */
+		u16   evr3; /* Timer3 Event Register  */
+		u16   evr4; /* Timer4 Event Register  */
+#define GTEVR_REF 0x0002 /* Output reference event  */
+#define GTEVR_CAP 0x0001 /* Counter Capture event   */
+#define GTEVR_RES ~(EVR_CAP|EVR_REF)
+		u16   psr1; /* Timer1 Prescaler Register  */
+		u16   psr2; /* Timer2 Prescaler Register  */
+		u16   psr3; /* Timer3 Prescaler Register  */
+		u16   psr4; /* Timer4 Prescaler Register  */
+		u8    res[0xC0];
+} gtm83xx_t;
+
+/*
+ * Integrated Programmable Interrupt Controller
+ */
+typedef struct ipic83xx {
+		u32    sicfr; /*  System Global Interrupt Configuration Register (SICFR)  */
+#define SICFR_HPI  0x7f000000 /*  Highest Priority Interrupt  */
+#define SICFR_MPSB 0x00400000 /*  Mixed interrupts Priority Scheme for group B  */
+#define SICFR_MPSA 0x00200000 /*  Mixed interrupts Priority Scheme for group A  */
+#define SICFR_IPSD 0x00080000 /*  Internal interrupts Priority Scheme for group D  */
+#define SICFR_IPSA 0x00010000 /*  Internal interrupts Priority Scheme for group A  */
+#define SICFR_HPIT 0x00000300 /*  HPI priority position IPIC output interrupt Type  */
+#define SICFR_RES ~(SICFR_HPI|SICFR_MPSB|SICFR_MPSA|SICFR_IPSD|SICFR_IPSA|SICFR_HPIT)
+		u32    sivcr; /*  System Global Interrupt Vector Register (SIVCR)  */
+#define SICVR_IVECX 0xfc000000 /*  Interrupt vector (for CE compatibility purpose only not used in 83xx IPIC implementation)  */
+#define SICVR_IVEC  0x0000007f /*  Interrupt vector  */
+#define SICVR_RES ~(SICVR_IVECX|SICVR_IVEC)
+		u32    sipnr_h; /*  System Internal Interrupt Pending Register - High (SIPNR_H)  */
+#define SIIH_TSEC1TX 0x80000000 /*  TSEC1 Tx interrupt  */
+#define SIIH_TSEC1RX 0x40000000 /*  TSEC1 Rx interrupt  */
+#define SIIH_TSEC1ER 0x20000000 /*  TSEC1 Eror interrupt  */
+#define SIIH_TSEC2TX 0x10000000 /*  TSEC2 Tx interrupt  */
+#define SIIH_TSEC2RX 0x08000000 /*  TSEC2 Rx interrupt  */
+#define SIIH_TSEC2ER 0x04000000 /*  TSEC2 Eror interrupt  */
+#define SIIH_USB2DR  0x02000000 /*  USB2 DR interrupt  */
+#define SIIH_USB2MPH 0x01000000 /*  USB2 MPH interrupt  */
+#define SIIH_UART1   0x00000080 /*  UART1 interrupt  */
+#define SIIH_UART2   0x00000040 /*  UART2 interrupt  */
+#define SIIH_SEC     0x00000020 /*  SEC interrupt  */
+#define SIIH_I2C1    0x00000004 /*  I2C1 interrupt  */
+#define SIIH_I2C2    0x00000002 /*  I2C1 interrupt  */
+#define SIIH_SPI     0x00000001 /*  SPI interrupt  */
+#define SIIH_RES	 ~(SIIH_TSEC1TX|SIIH_TSEC1RX|SIIH_TSEC1ER|SIIH_TSEC2TX \
+			|SIIH_TSEC2RX|SIIH_TSEC2ER|SIIH_USB2DR|SIIH_USB2MPH \
+			|SIIH_UART1  |SIIH_UART2  |SIIH_SEC   |SIIH_I2C1    \
+			|SIIH_I2C2   |SIIH_SPI)
+		u32    sipnr_l; /*  System Internal Interrupt Pending Register - Low (SIPNR_L)  */
+#define SIIL_RTCS  0x80000000 /*  RTC SECOND interrupt  */
+#define SIIL_PIT   0x40000000 /*  PIT interrupt  */
+#define SIIL_PCI1  0x20000000 /*  PCI1 interrupt  */
+#define SIIL_PCI2  0x10000000 /*  PCI2 interrupt  */
+#define SIIL_RTCA  0x08000000 /*  RTC ALARM interrupt  */
+#define SIIL_MU    0x04000000 /*  Message Unit interrupt  */
+#define SIIL_SBA   0x02000000 /*  System Bus Arbiter interrupt  */
+#define SIIL_DMA   0x01000000 /*  DMA interrupt  */
+#define SIIL_GTM4  0x00800000 /*  GTM4 interrupt  */
+#define SIIL_GTM8  0x00400000 /*  GTM8 interrupt  */
+#define SIIL_GPIO1 0x00200000 /*  GPIO1 interrupt  */
+#define SIIL_GPIO2 0x00100000 /*  GPIO2 interrupt  */
+#define SIIL_DDR   0x00080000 /*  DDR interrupt  */
+#define SIIL_LBC   0x00040000 /*  LBC interrupt  */
+#define SIIL_GTM2  0x00020000 /*  GTM2 interrupt  */
+#define SIIL_GTM6  0x00010000 /*  GTM6 interrupt  */
+#define SIIL_PMC   0x00008000 /*  PMC interrupt  */
+#define SIIL_GTM3  0x00000800 /*  GTM3 interrupt  */
+#define SIIL_GTM7  0x00000400 /*  GTM7 interrupt  */
+#define SIIL_GTM1  0x00000020 /*  GTM1 interrupt  */
+#define SIIL_GTM5  0x00000010 /*  GTM5 interrupt  */
+#define SIIL_DPTC  0x00000001 /*  DPTC interrupt (!!! Invisible for user !!!)*/
+#define SIIL_RES	 ~(SIIL_RTCS  |SIIL_PIT  |SIIL_PCI1 |SIIL_PCI2 |SIIL_RTCA \
+		 	|SIIL_MU   |SIIL_SBA  |SIIL_DMA  |SIIL_GTM4 |SIIL_GTM8 \
+			|SIIL_GPIO1|SIIL_GPIO2|SIIL_DDR  |SIIL_LBC  |SIIL_GTM2 \
+			|SIIL_GTM6 |SIIL_PMC  |SIIL_GTM3 |SIIL_GTM7 |SIIL_GTM1 \
+			|SIIL_GTM5 |SIIL_DPTC )
+		u32    siprr_a; /*  System Internal Interrupt Group A Priority Register (PRR)*/
+		u8     res0[8];
+		u32    siprr_d; /*  System Internal Interrupt Group D Priority Register (PRR)*/
+		u32    simsr_h; /*  System Internal Interrupt Mask Register - High (SIIH)*/
+		u32    simsr_l; /*  System Internal Interrupt Mask Register - Low (SIIL)*/
+		u8     res1[4];
+		u32    sepnr;   /*  System External Interrupt Pending Register (SEI)*/
+		u32    smprr_a; /*  System Mixed Interrupt Group A Priority Register (PRR)*/
+		u32    smprr_b; /*  System Mixed Interrupt Group B Priority Register (PRR)*/
+#define PRR_0 0xe0000000 /* Priority Register, Position 0 programming */
+#define PRR_1 0x1c000000 /* Priority Register, Position 1 programming */
+#define PRR_2 0x03800000 /* Priority Register, Position 2 programming */
+#define PRR_3 0x00700000 /* Priority Register, Position 3 programming */
+#define PRR_4 0x0000e000 /* Priority Register, Position 4 programming */
+#define PRR_5 0x00001c00 /* Priority Register, Position 5 programming */
+#define PRR_6 0x00000380 /* Priority Register, Position 6 programming */
+#define PRR_7 0x00000070 /* Priority Register, Position 7 programming */
+#define PRR_RES ~(PRR_0|PRR_1|PRR_2|PRR_3|PRR_4|PRR_5|PRR_6|PRR_7)
+		u32    semsr; /*  System External Interrupt Mask Register (SEI)  */
+#define SEI_IRQ0  0x80000000 /*  IRQ0 external interrupt  */
+#define SEI_IRQ1  0x40000000 /*  IRQ1 external interrupt  */
+#define SEI_IRQ2  0x20000000 /*  IRQ2 external interrupt  */
+#define SEI_IRQ3  0x10000000 /*  IRQ3 external interrupt  */
+#define SEI_IRQ4  0x08000000 /*  IRQ4 external interrupt  */
+#define SEI_IRQ5  0x04000000 /*  IRQ5 external interrupt  */
+#define SEI_IRQ6  0x02000000 /*  IRQ6 external interrupt  */
+#define SEI_IRQ7  0x01000000 /*  IRQ7 external interrupt  */
+#define SEI_SIRQ0 0x00008000 /*  SIRQ0 external interrupt  */
+#define SEI_RES 	~( SEI_IRQ0 |SEI_IRQ1 |SEI_IRQ2 |SEI_IRQ3 |SEI_IRQ4 \
+			|SEI_IRQ5 |SEI_IRQ6 |SEI_IRQ7 |SEI_SIRQ0)
+		u32    secnr; /*  System External Interrupt Control Register (SECNR)  */
+#define SECNR_MIXB0T 0xc0000000 /*  MIXB0 priority position IPIC output interrupt type*/
+#define SECNR_MIXB1T 0x30000000 /*  MIXB1 priority position IPIC output interrupt type*/
+#define SECNR_MIXA0T 0x00c00000 /*  MIXA0 priority position IPIC output interrupt type*/
+#define SECNR_SYSA1T 0x00300000 /*  MIXA1 priority position IPIC output interrupt type*/
+#define SECNR_EDI0   0x00008000 /*  IRQ0 external interrupt edge/level detect*/
+#define SECNR_EDI1   0x00004000 /*  IRQ1 external interrupt edge/level detect*/
+#define SECNR_EDI2   0x00002000 /*  IRQ2 external interrupt edge/level detect*/
+#define SECNR_EDI3   0x00001000 /*  IRQ3 external interrupt edge/level detect*/
+#define SECNR_EDI4   0x00000800 /*  IRQ4 external interrupt edge/level detect*/
+#define SECNR_EDI5   0x00000400 /*  IRQ5 external interrupt edge/level detect*/
+#define SECNR_EDI6   0x00000200 /*  IRQ6 external interrupt edge/level detect*/
+#define SECNR_EDI7   0x00000100 /*  IRQ7 external interrupt edge/level detect*/
+#define SECNR_RES 	~( SECNR_MIXB0T|SECNR_MIXB1T|SECNR_MIXA0T|SECNR_SYSA1T \
+			|SECNR_EDI0  |SECNR_EDI1  |SECNR_EDI2  |SECNR_EDI3   \
+			|SECNR_EDI4  |SECNR_EDI5  |SECNR_EDI6  |SECNR_EDI7)
+		u32   sersr; /*  System Error Status Register (SERR)  */
+		u32   sermr; /*  System Error Mask Register (SERR)  */
+#define SERR_IRQ0 0x80000000 /*  IRQ0 MCP request  */
+#define SERR_WDT  0x40000000 /*  WDT MCP request  */
+#define SERR_SBA  0x20000000 /*  SBA MCP request  */
+#define SERR_DDR  0x10000000 /*  DDR MCP request  */
+#define SERR_LBC  0x08000000 /*  LBC MCP request  */
+#define SERR_PCI1 0x04000000 /*  PCI1 MCP request  */
+#define SERR_PCI2 0x02000000 /*  PCI2 MCP request  */
+#define SERR_MU   0x01000000 /*  MU MCP request  */
+#define SERR_RNC  0x00010000 /*  MU MCP request (!!! Non-visible for users !!!)  */
+#define SERR_RES	 ~( SERR_IRQ0|SERR_WDT |SERR_SBA |SERR_DDR |SERR_LBC \
+			 |SERR_PCI1|SERR_PCI2|SERR_MU  |SERR_RNC )
+		u32    sercr; /*  System Error Control Register  (SERCR)  */
+#define SERCR_MCPR 	0x00000001 /*  MCP Route  */
+#define SERCR_RES 	~(SERCR_MCPR)
+		u8    res2[4];
+		u32   sifcr_h; /*  System Internal Interrupt Force Register - High (SIIH)*/
+		u32   sifcr_l; /*  System Internal Interrupt Force Register - Low (SIIL)*/
+		u32   sefcr;   /*  System External Interrupt Force Register (SEI)  */
+		u32   serfr;   /*  System Error Force Register (SERR)  */
+		u8    res3[0xA0];
+} ipic83xx_t;
+
+/*
+ * System Arbiter Registers
+ */
+typedef struct arbiter83xx {
+	u32 acr; /* Arbiter Configuration Register */
+#define ACR_COREDIS    	0x10000000 /* Core disable. */
+#define ACR_PIPE_DEP   	0x00070000 /* Pipeline depth (number of outstanding transactions).*/
+#define ACR_PCI_RPTCNT 	0x00007000 /* PCI repeat count. */
+#define ACR_RPTCNT     	0x00000700 /* Repeat count. */
+#define ACR_APARK      	0x00000030 /* Address parking. */
+#define ACR_PARKM	0x0000000F /* Parking master. */
+#define ACR_RES 	~(ACR_COREDIS|ACR_PIPE_DEP|ACR_PCI_RPTCNT|ACR_RPTCNT|ACR_APARK|ACR_PARKM)
+	u32 atr; /* Arbiter Timers Register */
+#define ATR_DTO 0x00FF0000 /* Data time out. */
+#define ATR_ATO	0x000000FF /* Address time out. */
+#define ATR_RES ~(ATR_DTO|ATR_ATO)
+	u8 res[4];
+	u32 aer; /* Arbiter Event Register (AE) */
+	u32 aidr; /* Arbiter Interrupt Definition Register (AE) */
+	u32 amr; /* Arbiter Mask Register (AE) */
+	u32 aeatr; /* Arbiter Event Attributes Register */
+#define AEATR_EVENT   0x07000000 /* Event type. */
+#define AEATR_MSTR_ID 0x001F0000 /* Master Id. */
+#define AEATR_TBST    0x00000800 /* Transfer burst. */
+#define AEATR_TSIZE   0x00000700 /* Transfer Size. */
+#define AEATR_TTYPE	  0x0000001F /* Transfer Type. */
+#define AEATR_RES	 ~(AEATR_EVENT|AEATR_MSTR_ID|AEATR_TBST|AEATR_TSIZE|AEATR_TTYPE)
+	u32 aeadr; /* Arbiter Event Address Register */
+	u32 aerr; /* Arbiter Event Response Register (AE)*/
+#define AE_ETEA 0x00000020 /* Transfer error. */
+#define AE_RES_ 0x00000010 /* Reserved transfer type. */
+#define AE_ECW  0x00000008 /* External control word transfer type. */
+#define AE_AO   0x00000004 /* Address Only transfer type. */
+#define AE_DTO  0x00000002 /* Data time out. */
+#define AE_ATO	0x00000001 /* Address time out. */
+#define AE_RSRV		~(AE_ETEA|AE_RES_|AE_ECW|AE_AO|AE_DTO|AE_ATO)
+	u8 res1[0xDC];
+} arbiter83xx_t;
+
+/*
+ * Reset Module
+ */
+typedef struct reset83xx {
+		u32    rcwlr; /* RCWL Register  */
+#define RCWLR_LBIUCM  0x80000000 /* LBIUCM  */
+#define RCWLR_LBIUCM_SHIFT    31
+#define RCWLR_DDRCM   0x40000000 /* DDRCM  */
+#define RCWLR_DDRCM_SHIFT     30
+#define RCWLR_SVCOD   0x30000000 /* SVCOD  */
+#define RCWLR_SPMF    0x0f000000 /* SPMF  */
+#define RCWLR_SPMF_SHIFT      24
+#define RCWLR_COREPLL 0x007F0000 /* COREPLL  */
+#define RCWLR_COREPLL_SHIFT   16
+#define RCWLR_CEVCOD  0x000000C0 /* CEVCOD  */
+#define RCWLR_CEVCOD_SHIFT     6
+#define RCWLR_CEPDF   0x00000020 /* CEPDF  */
+#define RCWLR_CEPDF_SHIFT      5
+#define RCWLR_CEPMF   0x0000001F /* CEPMF  */
+#define RCWLR_CEPMF_SHIFT      0
+#define RCWLR_RES 	~(RCWLR_BIUCM|RCWLR_DDRCM|RCWLR_SVCOD|RCWLR_SPMF|RCWLR_COREPLL|RCWLR_CEVCOD|RCWLR_CEPDF|RCWLR_CEPMF)
+		u32    rcwhr; /* RCHL Register  */
+#define RCWHR_PCIHOST 0x80000000 /* PCIHOST  */
+#define RCWHR_PCIHOST_SHIFT   31
+#define RCWHR_PCI64   0x40000000 /* PCI64  */
+#define RCWHR_PCI1ARB 0x20000000 /* PCI1ARB  */
+#define RCWHR_PCI2ARB 0x10000000 /* PCI2ARB  */
+#define RCWHR_COREDIS 0x08000000 /* COREDIS  */
+#define RCWHR_BMS     0x04000000 /* BMS  */
+#define RCWHR_BOOTSEQ 0x03000000 /* BOOTSEQ  */
+#define RCWHR_SWEN    0x00800000 /* SWEN  */
+#define RCWHR_ROMLOC  0x00700000 /* ROMLOC  */
+#define RCWHR_TSEC1M  0x0000c000 /* TSEC1M  */
+#define RCWHR_TSEC2M  0x00003000 /* TSEC2M  */
+#define RCWHR_TPR     0x00000100 /* TPR  */
+#define RCWHR_TLE     0x00000008 /* TLE  */
+#define RCWHR_LALE    0x00000004 /* LALE  */
+#define RCWHR_RES 	~(RCWHR_PCIHOST|RCWHR_PCI64|RCWHR_PCI1ARB|RCWHR_PCI2ARB \
+			|RCWHR_COREDIS|RCWHR_BMS|RCWHR_BOOTSEQ|RCWHR_SWEN|RCWHR_ROMLOC \
+			|RCWHR_TSEC1M|RCWHR_TSEC2M|RCWHR_TPR|RCWHR_TLE|RCWHR_LALE)
+		u8     res0[8];
+		u32    rsr; /* Reset status Register  */
+#define RSR_RSTSRC 0xE0000000 /* Reset source  */
+#define RSR_RSTSRC_SHIFT   29
+#define RSR_BSF    0x00010000 /* Boot seq. fail  */
+#define RSR_BSF_SHIFT      16
+#define RSR_SWSR   0x00002000 /* software soft reset  */
+#define RSR_SWSR_SHIFT     13
+#define RSR_SWHR   0x00001000 /* software hard reset  */
+#define RSR_SWHR_SHIFT     12
+#define RSR_JHRS   0x00000200 /* jtag hreset  */
+#define RSR_JHRS_SHIFT      9
+#define RSR_JSRS   0x00000100 /* jtag sreset status  */
+#define RSR_JSRS_SHIFT      8
+#define RSR_CSHR   0x00000010 /* checkstop reset status  */
+#define RSR_CSHR_SHIFT      4
+#define RSR_SWRS   0x00000008 /* software watchdog reset status  */
+#define RSR_SWRS_SHIFT      3
+#define RSR_BMRS   0x00000004 /* bus monitop reset status  */
+#define RSR_BMRS_SHIFT      2
+#define RSR_SRS    0x00000002 /* soft reset status  */
+#define RSR_SRS_SHIFT       1
+#define RSR_HRS    0x00000001 /* hard reset status  */
+#define RSR_HRS_SHIFT       0
+#define RSR_RES 	~(RSR_RSTSRC|RSR_BSF|RSR_SWSR|RSR_SWHR|RSR_JHRS|RSR_JSRS|RSR_CSHR|RSR_SWRS|RSR_BMRS|RSR_SRS|RSR_HRS)
+		u32    rmr; /* Reset mode Register  */
+#define RMR_CSRE   0x00000001 /* checkstop reset enable  */
+#define RMR_CSRE_SHIFT      0
+#define RMR_RES ~(RMR_CSRE)
+		u32    rpr; /* Reset protection Register  */
+		u32    rcr; /* Reset Control Register  */
+#define RCR_SWHR 0x00000002 /* software hard reset  */
+#define RCR_SWSR 0x00000001 /* software soft reset  */
+#define RCR_RES ~(RCR_SWHR|RCR_SWSR)
+		u32    rcer; /* Reset Control Enable Register  */
+#define RCER_CRE 0x00000001 /* software hard reset  */
+#define RCER_RES ~(RCER_CRE)
+	u8     res1[0xDC];
+} reset83xx_t;
+ 
+typedef struct clk83xx {
+		u32    spmr; /* system PLL mode Register  */
+#define SPMR_LBIUCM  0x80000000 /* LBIUCM  */
+#define SPMR_DDRCM   0x40000000 /* DDRCM  */
+#define SPMR_SVCOD   0x30000000 /* SVCOD  */
+#define SPMR_SPMF    0x0F000000 /* SPMF  */
+#define SPMR_CKID    0x00800000 /* CKID  */
+#define SPMR_CKID_SHIFT 23
+#define SPMR_COREPLL 0x007F0000 /* COREPLL  */
+#define SPMR_CEVCOD  0x000000C0 /* CEVCOD  */
+#define SPMR_CEPDF   0x00000020 /* CEPDF  */
+#define SPMR_CEPMF   0x0000001F /* CEPMF  */
+#define SPMR_RES	 ~(SPMR_LBIUCM|SPMR_DDRCM|SPMR_SVCOD|SPMR_SPMF|SPMR_CKID \
+			 |SPMR_COREPLL|SPMR_CEVCOD|SPMR_CEPDF|SPMR_CEPMF)
+		u32    occr; /* output clock control Register  */
+#define OCCR_PCICOE0 0x80000000 /* PCICOE0  */
+#define OCCR_PCICOE1 0x40000000 /* PCICOE1  */
+#define OCCR_PCICOE2 0x20000000 /* PCICOE2  */
+#define OCCR_PCICOE3 0x10000000 /* PCICOE3  */
+#define OCCR_PCICOE4 0x08000000 /* PCICOE4  */
+#define OCCR_PCICOE5 0x04000000 /* PCICOE5  */
+#define OCCR_PCICOE6 0x02000000 /* PCICOE6  */
+#define OCCR_PCICOE7 0x01000000 /* PCICOE7  */
+#define OCCR_PCICD0  0x00800000 /* PCICD0  */
+#define OCCR_PCICD1  0x00400000 /* PCICD1  */
+#define OCCR_PCICD2  0x00200000 /* PCICD2  */
+#define OCCR_PCICD3  0x00100000 /* PCICD3  */
+#define OCCR_PCICD4  0x00080000 /* PCICD4  */
+#define OCCR_PCICD5  0x00040000 /* PCICD5  */
+#define OCCR_PCICD6  0x00020000 /* PCICD6  */
+#define OCCR_PCICD7  0x00010000 /* PCICD7  */
+#define OCCR_PCI1CR  0x00000002 /* PCI1CR  */
+#define OCCR_PCI2CR  0x00000001 /* PCI2CR  */
+#define OCCR_RES 	~(OCCR_PCICOE0|OCCR_PCICOE1|OCCR_PCICOE2|OCCR_PCICOE3|OCCR_PCICOE4 \
+			|OCCR_PCICOE5|OCCR_PCICOE6|OCCR_PCICOE7|OCCR_PCICD0|OCCR_PCICD1  \
+			|OCCR_PCICD2 |OCCR_PCICD3 |OCCR_PCICD4 |OCCR_PCICD5|OCCR_PCICD6  \
+			|OCCR_PCICD7 |OCCR_PCI1CR |OCCR_PCI2CR )
+		u32    sccr; /* system clock control Register  */
+#define SCCR_TSEC1CM  0xc0000000 /* TSEC1CM  */
+#define SCCR_TSEC1CM_SHIFT 30
+#define SCCR_TSEC2CM  0x30000000 /* TSEC2CM  */
+#define SCCR_TSEC2CM_SHIFT 28
+#define SCCR_ENCCM    0x03000000 /* ENCCM  */
+#define SCCR_ENCCM_SHIFT 24
+#define SCCR_USBMPHCM 0x00c00000 /* USBMPHCM  */
+#define SCCR_USBMPHCM_SHIFT 22
+#define SCCR_USBDRCM  0x00300000 /* USBDRCM  */
+#define SCCR_USBDRCM_SHIFT 20
+#define SCCR_PCICM    0x00010000 /* PCICM  */
+#define SCCR_RES 	~( SCCR_TSEC1CM|SCCR_TSEC2CM|SCCR_ENCCM|SCCR_USBMPHCM \
+			|SCCR_USBDRCM|SCCR_PCICM)
+	u8     res0[0xF4];
+} clk83xx_t;
+
+/*
+ * Power Management Control Module
+ */
+typedef struct pmc83xx {
+		u32    pmccr; /* PMC Configuration Register  */
+#define PMCCR_SLPEN 0x00000001 /* System Low Power Enable  */
+#define PMCCR_DLPEN 0x00000002 /* DDR SDRAM Low Power Enable  */
+#define PMCCR_RES ~(PMCCR_SLPEN|PMCCR_DLPEN)
+		u32    pmcer; /* PMC Event Register  */
+#define PMCER_PMCI  0x00000001 /* PMC Interrupt  */
+#define PMCER_RES ~(PMCER_PMCI)
+		u32    pmcmr; /* PMC Mask Register  */
+#define PMCMR_PMCIE 0x0001 /* PMC Interrupt Enable  */
+#define PMCMR_RES ~(PMCMR_PMCIE)
+	u8 res0[0xF4];
+} pmc83xx_t;
+
+
+/*
+ * general purpose I/O module
+ */
+typedef struct gpio83xx {
+	u32 dir; /* direction register */
+	u32 odr; /* open drain register */
+	u32 dat; /* data register */
+	u32 ier; /* interrupt event register */
+	u32 imr; /* interrupt mask register */
+	u32 icr; /* external interrupt control register */
+	u8 res0[0xE8];
+} gpio83xx_t;
+
+/* 
+ * DDR Memory Controller Memory Map
+ */
+typedef struct ddr_cs_bnds{
+		u32 csbnds;
+#define CSBNDS_SA 0x00FF0000
+#define CSBNDS_SA_SHIFT   16
+#define CSBNDS_EA 0x000000FF
+#define CSBNDS_EA_SHIFT    0
+		u8  res0[4];
+} ddr_cs_bnds_t;
+
+typedef struct ddr83xx{
+		ddr_cs_bnds_t csbnds[4];	/**< Chip Select x Memory Bounds */
+		u8 res0[0x60];
+		u32 cs_config[4];	/**< Chip Select x Configuration */
+#define CSCONFIG_EN         0x80000000
+#define CSCONFIG_AP         0x00800000
+#define CSCONFIG_ROW_BIT    0x00000700
+#define CSCONFIG_ROW_BIT_12 0x00000000
+#define CSCONFIG_ROW_BIT_13 0x00000100
+#define CSCONFIG_ROW_BIT_14 0x00000200
+#define CSCONFIG_COL_BIT    0x00000007
+#define CSCONFIG_COL_BIT_8  0x00000000
+#define CSCONFIG_COL_BIT_9  0x00000001
+#define CSCONFIG_COL_BIT_10 0x00000002
+#define CSCONFIG_COL_BIT_11 0x00000003
+		u8 res1[0x78];
+		u32 timing_cfg_1;	/**< SDRAM Timing Configuration 1 */
+#define TIMING_CFG1_PRETOACT 0x70000000
+#define TIMING_CFG1_PRETOACT_SHIFT   28
+#define TIMING_CFG1_ACTTOPRE 0x0F000000
+#define TIMING_CFG1_ACTTOPRE_SHIFT   24
+#define TIMING_CFG1_ACTTORW  0x00700000
+#define TIMING_CFG1_ACTTORW_SHIFT    20
+#define TIMING_CFG1_CASLAT   0x00070000
+#define TIMING_CFG1_CASLAT_SHIFT     16
+#define TIMING_CFG1_REFREC   0x0000F000
+#define TIMING_CFG1_REFREC_SHIFT     12
+#define TIMING_CFG1_WRREC    0x00000700
+#define TIMING_CFG1_WRREC_SHIFT       8
+#define TIMING_CFG1_ACTTOACT 0x00000070
+#define TIMING_CFG1_ACTTOACT_SHIFT    4
+#define TIMING_CFG1_WRTORD   0x00000007
+#define TIMING_CFG1_WRTORD_SHIFT      0
+
+		u32 timing_cfg_2;       /**< SDRAM Timing Configuration 2 */
+#define TIMING_CFG2_CPO           0x0F000000
+#define TIMING_CFG2_CPO_SHIFT             24
+#define TIMING_CFG2_ACSM          0x00080000
+#define TIMING_CFG2_WR_DATA_DELAY 0x00001C00
+#define TIMING_CFG2_WR_DATA_DELAY_SHIFT   10
+
+		u32 sdram_cfg;          /**< SDRAM Control Configuration */
+#define SDRAM_CFG_MEM_EN     0x80000000
+#define SDRAM_CFG_SREN       0x40000000
+#define SDRAM_CFG_ECC_EN     0x20000000
+#define SDRAM_CFG_RD_EN      0x10000000
+#define SDRAM_CFG_SDRAM_TYPE 0x03000000
+#define SDRAM_CFG_SDRAM_TYPE_SHIFT   24
+#define SDRAM_CFG_DYN_PWR    0x00200000
+#define SDRAM_CFG_32_BE      0x00080000
+#define SDRAM_CFG_8_BE       0x00040000
+#define SDRAM_CFG_NCAP       0x00020000
+#define SDRAM_CFG_2T_EN      0x00008000
+
+		u8 res2[4];
+		u32 sdram_mode;	/**< SDRAM Mode Configuration */
+#define SDRAM_MODE_ESD 0xFFFF0000
+#define SDRAM_MODE_ESD_SHIFT   16
+#define SDRAM_MODE_SD  0x0000FFFF
+#define SDRAM_MODE_SD_SHIFT0
+
+		u8 res3[8];
+		u32 sdram_interval;/*SDRAM Interval Configuration */
+#define SDRAM_INTERVAL_REFINT  0x3FFF0000
+#define SDRAM_INTERVAL_REFINT_SHIFT    16
+#define SDRAM_INTERVAL_BSTOPRE 0x00003FFF
+#define SDRAM_INTERVAL_BSTOPRE_SHIFT    0
+		u8   res9[8];
+		u32  sdram_clk_cntl;
+		u8   res4[0xCCC];
+		u32 data_err_inject_hi; /**< Memory Data Path Error Injection Mask High */
+		u32 data_err_inject_lo; /**< Memory Data Path Error Injection Mask Low */
+		u32 ecc_err_inject;     /**< Memory Data Path Error Injection Mask ECC */
+#define ECC_ERR_INJECT_EMB			(0x80000000>>22)	/* ECC Mirror Byte */
+#define ECC_ERR_INJECT_EIEN			(0x80000000>>23)	/* Error Injection Enable */
+#define ECC_ERR_INJECT_EEIM			(0xff000000>>24)	/* ECC Erroe Injection Enable */
+#define ECC_ERR_INJECT_EEIM_SHIFT		0
+		u8 res5[0x14];
+		u32 capture_data_hi;    /**< Memory Data Path Read Capture High */
+		u32 capture_data_lo;    /**< Memory Data Path Read Capture Low */
+		u32 capture_ecc;        /**< Memory Data Path Read Capture ECC */
+#define CAPTURE_ECC_ECE				(0xff000000>>24)
+#define CAPTURE_ECC_ECE_SHIFT			0
+		u8 res6[0x14];
+		u32 err_detect;         /**< Memory Error Detect */
+#define ECC_ERROR_DETECT_MME			(0x80000000>>0)		/* Multiple Memory Errors */
+#define ECC_ERROR_DETECT_MBE			(0x80000000>>28)	/* Multiple-Bit Error */
+#define ECC_ERROR_DETECT_SBE			(0x80000000>>29)	/* Single-Bit ECC Error Pickup */
+#define ECC_ERROR_DETECT_MSE			(0x80000000>>31)	/* Memory Select Error */
+		u32 err_disable;        /**< Memory Error Disable */
+#define ECC_ERROR_DISABLE_MBED			(0x80000000>>28)	/* Multiple-Bit ECC Error Disable */
+#define ECC_ERROR_DISABLE_SBED			(0x80000000>>29)	/* Sinle-Bit ECC Error disable */
+#define ECC_ERROR_DISABLE_MSED			(0x80000000>>31)	/* Memory Select Error Disable */
+#define ECC_ERROR_ENABLE			~(ECC_ERROR_DISABLE_MSED|ECC_ERROR_DISABLE_SBED|ECC_ERROR_DISABLE_MBED)
+		u32 err_int_en;         /**< Memory Error Interrupt Enable */
+#define ECC_ERR_INT_EN_MBEE			(0x80000000>>28)	/* Multiple-Bit ECC Error Interrupt Enable */
+#define ECC_ERR_INT_EN_SBEE			(0x80000000>>29)	/* Single-Bit ECC Error Interrupt Enable */
+#define ECC_ERR_INT_EN_MSEE			(0x80000000>>31)	/* Memory Select Error Interrupt Enable */
+#define ECC_ERR_INT_DISABLE			~(ECC_ERR_INT_EN_MBEE|ECC_ERR_INT_EN_SBEE|ECC_ERR_INT_EN_MSEE)
+		u32 capture_attributes; /**< Memory Error Attributes Capture */
+#define ECC_CAPT_ATTR_BNUM			(0xe0000000>>1)		/* Data Beat Num */
+#define ECC_CAPT_ATTR_BNUM_SHIFT		28
+#define ECC_CAPT_ATTR_TSIZ			(0xc0000000>>6)		/* Transaction Size */
+#define ECC_CAPT_ATTR_TSIZ_FOUR_DW		0
+#define ECC_CAPT_ATTR_TSIZ_ONE_DW		1
+#define ECC_CAPT_ATTR_TSIZ_TWO_DW		2
+#define ECC_CAPT_ATTR_TSIZ_THREE_DW		3
+#define ECC_CAPT_ATTR_TSIZ_SHIFT		24
+#define ECC_CAPT_ATTR_TSRC			(0xf8000000>>11)	/* Transaction Source */
+#define ECC_CAPT_ATTR_TSRC_E300_CORE_DT		0x0
+#define ECC_CAPT_ATTR_TSRC_E300_CORE_IF		0x2
+#define ECC_CAPT_ATTR_TSRC_TSEC1		0x4
+#define ECC_CAPT_ATTR_TSRC_TSEC2		0x5
+#define ECC_CAPT_ATTR_TSRC_USB			(0x06|0x07)
+#define ECC_CAPT_ATTR_TSRC_ENCRYPT		0x8
+#define ECC_CAPT_ATTR_TSRC_I2C			0x9
+#define ECC_CAPT_ATTR_TSRC_JTAG			0xA
+#define ECC_CAPT_ATTR_TSRC_PCI1			0xD
+#define ECC_CAPT_ATTR_TSRC_PCI2			0xE
+#define ECC_CAPT_ATTR_TSRC_DMA			0xF
+#define ECC_CAPT_ATTR_TSRC_SHIFT		16
+#define ECC_CAPT_ATTR_TTYP			(0xe0000000>>18)	/* Transaction Type */
+#define ECC_CAPT_ATTR_TTYP_WRITE		0x1
+#define ECC_CAPT_ATTR_TTYP_READ			0x2
+#define ECC_CAPT_ATTR_TTYP_R_M_W		0x3
+#define ECC_CAPT_ATTR_TTYP_SHIFT		12
+#define ECC_CAPT_ATTR_VLD			(0x80000000>>31)	/* Valid */
+		u32 capture_address;    /**< Memory Error Address Capture */
+		u32 capture_ext_address;/**< Memory Error Extended Address Capture */
+		u32 err_sbe;            /**< Memory Single-Bit ECC Error Management */
+#define ECC_ERROR_MAN_SBET			(0xff000000>>8)		/* Single-Bit Error Threshold 0..255*/
+#define ECC_ERROR_MAN_SBET_SHIFT		16
+#define ECC_ERROR_MAN_SBEC			(0xff000000>>24)	/* Single Bit Error Counter 0..255*/
+#define ECC_ERROR_MAN_SBEC_SHIFT		0
+		u8 res7[0xA4];
+		u32 debug_reg;
+		u8 res8[0xFC];
+} ddr83xx_t;
+
+/*
+ * I2C1 Controller
+ */
+
+
+/*
+ * DUART
+ */
+typedef struct duart83xx{
+		u8 urbr_ulcr_udlb; /**< combined register for URBR, UTHR and UDLB */
+		u8 uier_udmb;      /**< combined register for UIER and UDMB */
+		u8 uiir_ufcr_uafr; /**< combined register for UIIR, UFCR and UAFR */
+		u8 ulcr;        /**< line control register */
+		u8 umcr;        /**< MODEM control register */
+		u8 ulsr;        /**< line status register */
+		u8 umsr;        /**< MODEM status register */
+		u8 uscr;        /**< scratch register */
+		u8 res0[8];
+		u8 udsr;        /**< DMA status register */
+		u8 res1[3];
+		u8 res2[0xEC];
+		
+} duart83xx_t;
+
+/*
+ * Local Bus Controller Registers
+ */
+typedef struct lbus_bank{
+		u32 br;             /**< Base Register  */
+		u32 or;             /**< Base Register  */
+} lbus_bank_t;
+
+typedef struct lbus83xx {
+		lbus_bank_t bank[8];
+		u8 res0[0x28];
+		u32 mar;                /**< UPM Address Register */
+		u8 res1[0x4];
+		u32 mamr;               /**< UPMA Mode Register */
+		u32 mbmr;               /**< UPMB Mode Register */
+		u32 mcmr;               /**< UPMC Mode Register */
+		u8 res2[0x8];
+		u32 mrtpr;              /**< Memory Refresh Timer Prescaler Register */
+		u32 mdr;                /**< UPM Data Register */
+		u8 res3[0x8];
+		u32 lsdmr;              /**< SDRAM Mode Register */
+		u8 res4[0x8];
+		u32 lurt;               /**< UPM Refresh Timer */
+		u32 lsrt;               /**< SDRAM Refresh Timer */
+		u8 res5[0x8];
+		u32 ltesr;              /**< Transfer Error Status Register */
+		u32 ltedr;              /**< Transfer Error Disable Register */
+		u32 lteir;              /**< Transfer Error Interrupt Register */
+		u32 lteatr;             /**< Transfer Error Attributes Register */
+		u32 ltear;              /**< Transfer Error Address Register */
+		u8 res6[0xC];
+		u32 lbcr;               /**< Configuration Register */
+#define LBCR_LDIS  0x80000000
+#define LBCR_LDIS_SHIFT    31
+#define LBCR_BCTLC 0x00C00000
+#define LBCR_BCTLC_SHIFT   22
+#define LBCR_LPBSE 0x00020000
+#define LBCR_LPBSE_SHIFT   17
+#define LBCR_EPAR  0x00010000
+#define LBCR_EPAR_SHIFT    16
+#define LBCR_BMT   0x0000FF00
+#define LBCR_BMT_SHIFT      8
+		u32 lcrr;               /**< Clock Ratio Register */
+#define LCRR_DBYP    0x80000000
+#define LCRR_DBYP_SHIFT      31
+#define LCRR_BUFCMDC 0x30000000
+#define LCRR_BUFCMDC_SHIFT   28
+#define LCRR_ECL     0x03000000
+#define LCRR_ECL_SHIFT       24
+#define LCRR_EADC    0x00030000
+#define LCRR_EADC_SHIFT      16
+#define LCRR_CLKDIV  0x0000000F
+#define LCRR_CLKDIV_SHIFT     0
+
+
+		u8 res7[0x28];
+		u8 res8[0xF00];
+} lbus83xx_t;
+
+/*
+ * Serial Peripheral Interface
+ */
+typedef struct spi83xx
+{
+		u32 mode;     /**< mode register  */
+		u32 event;    /**< event register */
+		u32 mask;     /**< mask register  */
+		u32 com;      /**< command register */
+		u8 res0[0x10];
+		u32 tx;       /**< transmit register */
+		u32 rx;       /**< receive register */
+		u8 res1[0xD8];
+} spi83xx_t;
+ 
+typedef struct dma83xx {
+	u8 res0[0x30];
+	u32 omisr;	/* Outbound message interrupt status register */
+	u32 omimr;	/* Outbound message interrupt mask register */
+	u8 res1[0x18];
+	u32 imr0;	/* Inbound message register0 */
+	u32 imr1;	/* Inbound message register1 */
+	u32 omr0;	/* Outbound message register0 */
+	u32 omr1;	/* Outbound message register1 */
+	u32 odr;	/* Outbound doorbell register */
+	u8 res2[0x4];
+	u32 idr;	/* Inbound doorbell register */
+	u8 res3[0x14];
+	u32 imisr;	/* Inbound message interrupt status register */
+	u32 imimr;	/* Inbound message interrupt mask register */
+	u8 res4[0x78];
+
+	u32 dmamr0;	/* DMA 0 mode register */
+	u32 dmasr0;	/* DMA 0 status register */
+	u32 dmacdar0;	/* DMA 0 current descriptor address register */
+	u8 res5[0x4];
+	u32 dmasar0;	/* DMA 0 source address register */
+	u8 res6[0x4];
+	u32 dmadar0;	/* DMA 0 destination address register */
+	u8 res7[0x4];
+	u32 dmabcr0;	/* DMA 0 byte count register */
+	u32 dmandar0;	/* DMA 0 next descriptor address register */
+	u8 res8[0x58];
+
+	u32 dmamr1;	/* DMA 1 mode register */
+	u32 dmasr1;	/* DMA 1 status register */
+	u32 dmacdar1;	/* DMA 1 current descriptor address register */
+	u8 res9[0x4];
+	u32 dmasar1;	/* DMA 1 source address register */
+	u8 res10[0x4];
+	u32 dmadar1;	/* DMA 1 destination address register */
+	u8 res11[0x4];
+	u32 dmabcr1;	/* DMA 1 byte count register */
+	u32 dmandar1;	/* DMA 1 next descriptor address register */
+	u8 res12[0x58];
+
+	u32 dmamr2;	/* DMA 2 mode register */
+	u32 dmasr2;	/* DMA 2 status register */
+	u32 dmacdar2;	/* DMA 2 current descriptor address register */
+	u8 res13[0x4];
+	u32 dmasar2;	/* DMA 2 source address register */
+	u8 res14[0x4];
+	u32 dmadar2;	/* DMA 2 destination address register */
+	u8 res15[0x4];
+	u32 dmabcr2;	/* DMA 2 byte count register */
+	u32 dmandar2;	/* DMA 2 next descriptor address register */
+	u8 res16[0x58];
+
+	u32 dmamr3;	/* DMA 3 mode register */
+	u32 dmasr3;	/* DMA 3 status register */
+	u32 dmacdar3;	/* DMA 3 current descriptor address register */
+	u8 res17[0x4];
+	u32 dmasar3;	/* DMA 3 source address register */
+	u8 res18[0x4];
+	u32 dmadar3;	/* DMA 3 destination address register */
+	u8 res19[0x4];
+	u32 dmabcr3;	/* DMA 3 byte count register */
+	u32 dmandar3;	/* DMA 3 next descriptor address register */
+
+	u32 dmagsr;	/* DMA general status register */
+	u8  res20[0x54];
+} dma83xx_t;
+
+/* DMAMRn -DMA Mode Register */
+#define DMAMR_SAHTS_8B	0x0000c000
+#define DMAMR_SAHE	0x00001000
+#define DMAMR_CTM	0x00000004
+#define DMAMR_CS	0x00000001
+
+/* DMASRn -DMA Status Register */
+#define DMASR_TE	0x00000080
+#define DMASR_CB	0x00000004
+
+/*
+ * PCI Software Configuration Registers
+ */
+typedef struct pciconf83xx {
+	u32	config_address;
+#define PCI_CONFIG_ADDRESS_EN	0x80000000
+#define PCI_CONFIG_ADDRESS_BN_SHIFT	16
+#define PCI_CONFIG_ADDRESS_BN_MASK	0x00ff0000
+#define PCI_CONFIG_ADDRESS_DN_SHIFT	11
+#define PCI_CONFIG_ADDRESS_DN_MASK	0x0000f800
+#define PCI_CONFIG_ADDRESS_FN_SHIFT	8
+#define PCI_CONFIG_ADDRESS_FN_MASK	0x00000700
+#define PCI_CONFIG_ADDRESS_RN_SHIFT	0
+#define PCI_CONFIG_ADDRESS_RN_MASK	0x000000fc
+	u32 config_data;
+	u32 int_ack;
+	u8	res[116];
+} pciconf83xx_t;
+
+/*
+ * PCI Outbound Translation Register
+ */
+typedef struct pci_outbound_window {
+	u32	potar;
+	u8	res0[4];
+	u32	pobar;
+	u8	res1[4];
+	u32	pocmr;
+	u8	res2[4];
+} pot83xx_t;
+/*
+ * Sequencer
+ */
+typedef struct ios83xx {
+	pot83xx_t	pot[6];
+#define POTAR_TA_MASK	0x000fffff
+#define	POBAR_BA_MASK	0x000fffff
+#define	POCMR_EN	0x80000000
+#define	POCMR_IO	0x40000000	/* 0--memory space 1--I/O space */
+#define	POCMR_SE	0x20000000	/* streaming enable */
+#define	POCMR_DST	0x10000000	/* 0--PCI1 1--PCI2*/
+#define	POCMR_CM_MASK	0x000fffff
+#define	POCMR_CM_4G	0x00000000
+#define	POCMR_CM_2G	0x00080000
+#define	POCMR_CM_1G	0x000C0000
+#define	POCMR_CM_512M	0x000E0000
+#define	POCMR_CM_256M	0x000F0000
+#define	POCMR_CM_128M	0x000F8000
+#define	POCMR_CM_64M	0x000FC000
+#define	POCMR_CM_32M	0x000FE000
+#define	POCMR_CM_16M	0x000FF000
+#define	POCMR_CM_8M	0x000FF800
+#define	POCMR_CM_4M	0x000FFC00
+#define	POCMR_CM_2M	0x000FFE00
+#define	POCMR_CM_1M	0x000FFF00
+#define	POCMR_CM_512K	0x000FFF80
+#define	POCMR_CM_256K	0x000FFFC0
+#define	POCMR_CM_128K	0x000FFFE0
+#define	POCMR_CM_64K	0x000FFFF0
+#define	POCMR_CM_32K	0x000FFFF8
+#define	POCMR_CM_16K	0x000FFFFC
+#define	POCMR_CM_8K	0x000FFFFE
+#define	POCMR_CM_4K	0x000FFFFF
+	u8	res0[0x60];
+	u32	pmcr;
+	u8	res1[4];
+	u32	dtcr;
+	u8	res2[4];
+} ios83xx_t;
+
+/*
+ * PCI Controller Control and Status Registers
+ */
+typedef struct pcictrl83xx {
+	u32	esr;
+#define ESR_MERR	0x80000000
+#define ESR_APAR	0x00000400
+#define	ESR_PCISERR	0x00000200
+#define	ESR_MPERR	0x00000100
+#define	ESR_TPERR	0x00000080
+#define	ESR_NORSP	0x00000040
+#define	ESR_TABT	0x00000020
+	u32	ecdr;
+#define ECDR_APAR	0x00000400
+#define	ECDR_PCISERR	0x00000200
+#define	ECDR_MPERR	0x00000100
+#define	ECDR_TPERR	0x00000080
+#define	ECDR_NORSP	0x00000040
+#define	ECDR_TABT	0x00000020
+	u32 eer;
+#define EER_APAR	0x00000400
+#define	EER_PCISERR	0x00000200
+#define	EER_MPERR	0x00000100
+#define	EER_TPERR	0x00000080
+#define	EER_NORSP	0x00000040
+#define	EER_TABT	0x00000020
+	u32	eatcr;
+#define	EATCR_ERRTYPR_MASK	0x70000000
+#define	EATCR_ERRTYPR_APR	0x00000000	/* address parity error */
+#define	EATCR_ERRTYPR_WDPR	0x10000000	/* write data parity error */
+#define	EATCR_ERRTYPR_RDPR	0x20000000	/* read data parity error */
+#define	EATCR_ERRTYPR_MA	0x30000000	/* master abort */
+#define	EATCR_ERRTYPR_TA	0x40000000	/* target abort */
+#define	EATCR_ERRTYPR_SE	0x50000000	/* system error indication received */
+#define	EATCR_ERRTYPR_PEA	0x60000000	/* parity error indication received on a read */
+#define	EATCR_ERRTYPR_PEW	0x70000000	/* parity error indication received on a write */
+#define EATCR_BN_MASK		0x0f000000	/* beat number */
+#define	EATCR_BN_1st		0x00000000
+#define	EATCR_BN_2ed		0x01000000
+#define	EATCR_BN_3rd		0x02000000
+#define	EATCR_BN_4th		0x03000000
+#define	EATCR_BN_5th		0x0400000
+#define	EATCR_BN_6th		0x05000000
+#define	EATCR_BN_7th		0x06000000
+#define	EATCR_BN_8th		0x07000000
+#define	EATCR_BN_9th		0x08000000
+#define EATCR_TS_MASK		0x00300000	/* transaction size */
+#define	EATCR_TS_4		0x00000000
+#define	EATCR_TS_1		0x00100000
+#define	EATCR_TS_2		0x00200000
+#define	EATCR_TS_3		0x00300000
+#define	EATCR_ES_MASK		0x000f0000	/* error source */
+#define	EATCR_ES_EM		0x00000000	/* external master */
+#define	EATCR_ES_DMA		0x00050000
+#define	EATCR_CMD_MASK		0x0000f000
+#define	EATCR_HBE_MASK		0x00000f00	/* PCI high byte enable*/
+#define	EATCR_BE_MASK		0x000000f0	/* PCI byte enable */
+#define	EATCR_HPB		0x00000004	/* high parity bit */
+#define	EATCR_PB		0x00000002	/* parity bit*/
+#define	EATCR_VI		0x00000001	/* error information valid */
+	u32	eacr;
+	u32	eeacr;
+	u32	edlcr;
+	u32	edhcr;
+	u32	gcr;
+	u32	ecr;
+	u32	gsr;
+	u8	res0[12];
+	u32	pitar2;
+	u8	res1[4];
+	u32	pibar2;
+	u32	piebar2;
+	u32	piwar2;
+	u8	res2[4];
+	u32	pitar1;
+	u8	res3[4];
+	u32	pibar1;
+	u32	piebar1;
+	u32	piwar1;
+	u8	res4[4];
+	u32	pitar0;
+	u8	res5[4];
+	u32	pibar0;
+	u8	res6[4];
+	u32	piwar0;
+	u8	res7[132];
+#define PITAR_TA_MASK		0x000fffff
+#define PIBAR_MASK		0xffffffff
+#define PIEBAR_EBA_MASK		0x000fffff
+#define PIWAR_EN		0x80000000
+#define PIWAR_PF		0x20000000
+#define	PIWAR_RTT_MASK		0x000f0000
+#define	PIWAR_RTT_NO_SNOOP	0x00040000
+#define PIWAR_RTT_SNOOP		0x00050000
+#define	PIWAR_WTT_MASK		0x0000f000
+#define	PIWAR_WTT_NO_SNOOP	0x00004000
+#define PIWAR_WTT_SNOOP		0x00005000
+#define	PIWAR_IWS_MASK	0x0000003F
+#define	PIWAR_IWS_4K	0x0000000B
+#define	PIWAR_IWS_8K	0x0000000C
+#define	PIWAR_IWS_16K	0x0000000D
+#define	PIWAR_IWS_32K	0x0000000E
+#define	PIWAR_IWS_64K	0x0000000F
+#define	PIWAR_IWS_128K	0x00000010
+#define	PIWAR_IWS_256K	0x00000011
+#define	PIWAR_IWS_512K	0x00000012
+#define	PIWAR_IWS_1M	0x00000013
+#define	PIWAR_IWS_2M	0x00000014
+#define	PIWAR_IWS_4M	0x00000015
+#define	PIWAR_IWS_8M	0x00000016
+#define	PIWAR_IWS_16M	0x00000017
+#define	PIWAR_IWS_32M	0x00000018
+#define	PIWAR_IWS_64M	0x00000019
+#define	PIWAR_IWS_128M	0x0000001A
+#define	PIWAR_IWS_256M	0x0000001B
+#define	PIWAR_IWS_512M	0x0000001C
+#define	PIWAR_IWS_1G	0x0000001D
+#define	PIWAR_IWS_2G	0x0000001E
+} pcictrl83xx_t;
+
+/*
+ * USB 
+ */
+typedef struct usb83xx {
+	u8 fixme[0x2000];
+} usb83xx_t;
+
+/*
+ * TSEC
+ */
+typedef struct tsec83xx {
+	u8 fixme[0x1000];
+} tsec83xx_t;
+
+/*
+ * Security
+ */
+typedef struct security83xx {
+	u8 fixme[0x10000];
+} security83xx_t;
+
+typedef struct immap {
+	sysconf83xx_t sysconf; /* System configuration */
+	wdt83xx_t     wdt;     /* Watch Dog Timer (WDT) Registers */
+	rtclk83xx_t   rtc;     /* Real Time Clock Module Registers */
+	rtclk83xx_t   pit;     /* Periodic Interval Timer */
+	gtm83xx_t     gtm[2];  /* Global Timers Module */
+	ipic83xx_t    ipic;    /* Integrated Programmable Interrupt Controller */
+	arbiter83xx_t arbiter; /* System Arbiter Registers */
+	reset83xx_t   reset;   /* Reset Module */
+	clk83xx_t     clk;     /* System Clock Module */
+	pmc83xx_t     pmc;     /* Power Management Control Module */
+	gpio83xx_t    pgio[2]; /* general purpose I/O module */
+	u8 res0[0x200];
+	u8 DDL_DDR[0x100];
+	u8 DDL_LBIU[0x100];
+	u8 res1[0xE00];
+	ddr83xx_t     ddr;     /* DDR Memory Controller Memory */
+	i2c_t     i2c[2];      /* I2C1 Controller */
+	u8 res2[0x1300];
+	duart83xx_t   duart[2];/* DUART */
+	u8 res3[0x900];
+	lbus83xx_t    lbus;    /* Local Bus Controller Registers */
+	u8 res4[0x1000];
+	spi83xx_t     spi;     /* Serial Peripheral Interface */
+	u8 res5[0xF00];
+	dma83xx_t     dma;     /* DMA */
+	pciconf83xx_t pci_conf[2];  /* PCI Software Configuration Registers */
+	ios83xx_t     ios;     /* Sequencer */
+	pcictrl83xx_t pci_ctrl[2];  /* PCI Controller Control and Status Registers */
+	u8 res6[0x19900];
+	usb83xx_t     usb;
+	tsec83xx_t    tsec[2];
+	u8 res7[0xA000];
+	security83xx_t security;
+} immap_t;
+
+#endif /* __IMMAP_83xx__ */
diff -urN u-boot-temp/include/configs/MPC8349ADS.h u-boot-1.1.3/include/configs/MPC8349ADS.h
--- u-boot-temp/include/configs/MPC8349ADS.h	2005-08-13 18:53:35.000000000 -0500
+++ u-boot-1.1.3/include/configs/MPC8349ADS.h	2006-05-16 18:16:43.000000000 -0500
@@ -31,41 +31,43 @@
 
 #undef DEBUG
 
+#include <configs/pci_config.h>
+
 #define CONFIG_MII
 
 /*
  * High Level Configuration Options
  */
 #define CONFIG_E300		1	/* E300 Family */
+#define CONFIG_E300C1		1	/* E300C1 core specific */
 #define CONFIG_MPC83XX		1	/* MPC83XX family */
-#define CONFIG_MPC8349		1	/* MPC8349 specific */
+#define CONFIG_MPC8349		1	/* MPC8349 CPU specific */
 #define CONFIG_MPC8349ADS	1	/* MPC8349ADS board specific */
 
-/* FIXME: Real PCI support will come in a follow-up update. */
-#undef CONFIG_PCI
-
 #define CONFIG_TSEC_ENET 		/* tsec ethernet support */
 #define CONFIG_ENV_OVERWRITE
 
 #define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup*/
+#define CONFIG_DDR_ECC			/* only for ECC DDR module */
+#define CONFIG_DDR_ECC_CMD		/* Use DDR ECC user commands */
 
-#undef CONFIG_DDR_ECC			/* only for ECC DDR module */
-
-#define PCI_66M
-#ifdef PCI_66M
 #define CONFIG_83XX_CLKIN	66000000	/* in Hz */
-#else
-#define CONFIG_83XX_CLKIN	33000000	/* in Hz */
-#endif
 
 #ifndef CONFIG_SYS_CLK_FREQ
-#ifdef PCI_66M
 #define CONFIG_SYS_CLK_FREQ	66000000
-#else
-#define CONFIG_SYS_CLK_FREQ	33000000
-#endif
 #endif
 
+#define CFG_SCCR_INIT		(SCCR_DEFAULT & (~SCCR_CLK_MASK))
+#define CFG_SCCR_TSEC1CM	SCCR_TSEC1CM_1	/* TSEC1 clock setting */
+#define CFG_SCCR_TSEC2CM	SCCR_TSEC2CM_1	/* TSEC2 clock setting */
+#define CFG_SCCR_ENCCM		SCCR_ENCCM_3	/* ENC clock setting */
+#define CFG_SCCR_USBCM		SCCR_USBCM_3	/* USB clock setting */
+#define CFG_SCCR_VAL		( CFG_SCCR_INIT		\
+				| CFG_SCCR_TSEC1CM	\
+				| CFG_SCCR_TSEC2CM	\
+				| CFG_SCCR_ENCCM	\
+				| CFG_SCCR_USBCM	)
+
 #define CONFIG_BOARD_EARLY_INIT_F	/* call board_pre_init */
 
 #define CFG_IMMRBAR		0xE0000000
@@ -74,6 +76,8 @@
 #define CFG_MEMTEST_START       0x00000000      /* memtest region */
 #define CFG_MEMTEST_END         0x00100000
 
+
+
 /*
  * DDR Setup
  */
@@ -86,12 +90,12 @@
 #if defined(CONFIG_SPD_EEPROM)
 	/*
 	 * Determine DDR configuration from I2C interface.
-	 */
+	*/
 	#define SPD_EEPROM_ADDRESS	0x51		/* DDR DIMM */
 #else
 	/*
 	 * Manually set up DDR parameters
-	 */
+	*/
 	#define CFG_DDR_SIZE	    256		/* Mb */
 	#define CFG_DDR_CONFIG	(CSCONFIG_EN | CSCONFIG_ROW_BIT_13 | CSCONFIG_COL_BIT_9)
 	#define CFG_DDR_TIMING_1	0x37344321
@@ -123,6 +127,7 @@
 #define CFG_LBLAWBAR0_PRELIM CFG_FLASH_BASE	/* Window base at flash base */
 #define CFG_LBLAWAR0_PRELIM  0x80000016		/* 16Mb window size */
 
+
 #define CFG_MAX_FLASH_BANKS	1		/* number of banks */
 #define CFG_MAX_FLASH_SECT	64		/* sectors per device */
 
@@ -133,6 +138,7 @@
 #define CFG_MID_FLASH_JUMP      0x7F000000
 #define CFG_MONITOR_BASE    	TEXT_BASE	/* start of monitor */
 
+
 #if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
 #define CFG_RAMBOOT
 #else
@@ -148,14 +154,11 @@
 #define CFG_BR1_PRELIM	  (CFG_BCSR|0x00000801)	/* Port-size=8bit, MSEL=GPCM */
 #define CFG_OR1_PRELIM		0xFFFFE8f0	/* length 32K */
 
-#define CONFIG_L1_INIT_RAM
-#define CFG_INIT_RAM_LOCK 	1
-#define CFG_INIT_RAM_ADDR	0xe4010000   /* Initial RAM address */
+#define CFG_INIT_RAM_ADDR	0xE6000000   /* Initial RAM address */
 #define CFG_INIT_RAM_END    	0x1000	     /* End of used area in RAM*/
 
 #define CFG_GBL_DATA_SIZE  	0x100     /* num bytes initial data */
 #define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
-#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
 
 #define CFG_MONITOR_LEN	    	(256 * 1024) /* Reserve 256 kB for Mon */
 #define CFG_MALLOC_LEN	    	(128 * 1024) /* Reserved for malloc */
@@ -192,8 +195,11 @@
  */
 
 #define CFG_BR2_PRELIM		0xf0001861 /*Port-size=32bit, MSEL=SDRAM*/
-#define CFG_LBLAWBAR2_PRELIM	0xF0000000
-#define CFG_LBLAWAR2_PRELIM	0x80000019 /*64M*/
+
+#define CFG_LBLAWBAR2_PRELIM 0xF0000000
+
+#define CFG_LBLAWAR2_PRELIM 0x80000019 /*64M*/
+
 
 /*
  * The SDRAM size in MB, CFG_LBC_SDRAM_SIZE, is 64.
@@ -246,7 +252,7 @@
 #define CFG_LBC_LSDMR_OP_RWINV	(7 << (31 - 4))
 
 #define CFG_LBC_LSDMR_COMMON    ( CFG_LBC_LSDMR_RFEN            \
-				| CFG_LBC_LSDMR_BSMA1516	\
+                                | CFG_LBC_LSDMR_BSMA1516	\
 				| CFG_LBC_LSDMR_RFCR8		\
 				| CFG_LBC_LSDMR_PRETOACT6	\
 				| CFG_LBC_LSDMR_ACTTORW3	\
@@ -255,6 +261,7 @@
 				| CFG_LBC_LSDMR_CL3		\
 				)
 
+
 /*
  * SDRAM Controller configuration sequence.
  */
@@ -268,6 +275,7 @@
 				| CFG_LBC_LSDMR_OP_MRW)
 #define CFG_LBC_LSDMR_5		( CFG_LBC_LSDMR_COMMON \
 				| CFG_LBC_LSDMR_OP_NORMAL)
+
 #endif
 
 /*
@@ -295,11 +303,11 @@
 /* I2C */
 #define  CONFIG_HARD_I2C		/* I2C with hardware support*/
 #undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
-#define CFG_I2C_SPEED		400000	/* I2C speed and slave address */
-#define CFG_I2C_SLAVE		0x7F
+#define CFG_I2C_SPEED		0x3F	/* I2C speed */
+#define CFG_I2C_SLAVE		0x7F	/* I2C slave address */
 #define CFG_I2C_NOPROBES        {0x69}	/* Don't probe these addrs */
-#define CFG_I2C_OFFSET      0x3000
-#define CFG_I2C2_OFFSET      0x3100
+#define CFG_I2C_OFFSET		0x3000
+#define CFG_I2C2_OFFSET		0x3100
 
 /* TSEC */
 #define CFG_TSEC1_OFFSET 0x24000
@@ -307,6 +315,7 @@
 #define CFG_TSEC2_OFFSET 0x25000
 #define CFG_TSEC2 (CFG_IMMRBAR+CFG_TSEC2_OFFSET)
 
+
 /* IO Configuration */
 #define CFG_IO_CONF (\
 	IO_CONF_UART |\
@@ -331,15 +340,25 @@
 #define CFG_PCI1_IO_PHYS	0xe2000000
 #define CFG_PCI1_IO_SIZE	0x1000000	/* 16M */
 
+
 #define CFG_PCI2_MEM_BASE	0xA0000000
 #define CFG_PCI2_MEM_PHYS	CFG_PCI2_MEM_BASE
 #define CFG_PCI2_MEM_SIZE	0x20000000	/* 512M */
 #define CFG_PCI2_IO_BASE	0x00000000
 #define CFG_PCI2_IO_PHYS	0xe3000000
 #define CFG_PCI2_IO_SIZE	0x1000000	/* 16M */
+
+#define CFG_PCI_SLV_MEM_LOCAL   CFG_SDRAM_BASE
+#define CFG_PCI_SLV_MEM_BUS     0x00000000
+#define CFG_PCI_SLV_MEM_SIZE    0x80000000
+
+
 #if defined(CONFIG_PCI)
 
+//#define PCI_64BIT 
 #define PCI_ALL_PCI1
+//#define PCI_ONE_PCI1
+//#define PCI_TWO_PCI1
 #if defined(PCI_64BIT)
 #undef PCI_ALL_PCI1
 #undef PCI_TWO_PCI1
@@ -349,7 +368,7 @@
 #define CONFIG_NET_MULTI
 #define CONFIG_PCI_PNP	               	/* do pci plug-and-play */
 
-#undef CONFIG_EEPRO100
+#define CONFIG_EEPRO100
 #undef CONFIG_TULIP
 
 #if !defined(CONFIG_PCI_PNP)
@@ -363,7 +382,9 @@
 
 #endif	/* CONFIG_PCI */
 
+
 #if defined(CONFIG_TSEC_ENET)
+
 #ifndef CONFIG_NET_MULTI
 #define CONFIG_NET_MULTI 	1
 #endif
@@ -371,18 +392,19 @@
 #define CONFIG_GMII		1	/* MII PHY management */
 #define CONFIG_MPC83XX_TSEC1	1
 #define CONFIG_MPC83XX_TSEC1_NAME	"TSEC0"
+
 #define CONFIG_MPC83XX_TSEC2	1
 #define CONFIG_MPC83XX_TSEC2_NAME	"TSEC1"
+
 #define TSEC1_PHY_ADDR		0
 #define TSEC2_PHY_ADDR		1
 #define TSEC1_PHYIDX		0
 #define TSEC2_PHYIDX		0
-
-/* Options are: TSEC[0-1] */
-#define CONFIG_ETHPRIME		"TSEC0"
+#define CONFIG_ETHPRIME		"Freescale TSEC"
 
 #endif	/* CONFIG_TSEC_ENET */
 
+
 /*
  * Environment
  */
@@ -402,35 +424,39 @@
 #define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
 
 #if defined(CFG_RAMBOOT)
-#if defined(CONFIG_PCI)
-#define  CONFIG_COMMANDS	((CONFIG_CMD_DFL	\
-				 | CFG_CMD_PING		\
-				 | CFG_CMD_PCI		\
-				 | CFG_CMD_I2C)		\
+	#if defined(CONFIG_PCI)
+		#define  CONFIG_COMMANDS	((CONFIG_CMD_DFL	\
+				| CFG_CMD_PING		\
+				| CFG_CMD_ASKENV	\
+				| CFG_CMD_PCI		\
+				| CFG_CMD_I2C)		\
 				&			\
-				 ~(CFG_CMD_ENV		\
-				  | CFG_CMD_LOADS))
-#else
-#define  CONFIG_COMMANDS	((CONFIG_CMD_DFL	\
-				 | CFG_CMD_PING		\
-				 | CFG_CMD_I2C)		\
+				~(CFG_CMD_ENV		\
+				| CFG_CMD_LOADS))
+	#else
+		#define  CONFIG_COMMANDS	((CONFIG_CMD_DFL	\
+				| CFG_CMD_PING		\
+				| CFG_CMD_ASKENV	\
+				| CFG_CMD_I2C)		\
 				&			\
-				 ~(CFG_CMD_ENV		\
-				  | CFG_CMD_LOADS))
-#endif
+				~(CFG_CMD_ENV		\
+				| CFG_CMD_LOADS))
+	#endif
 #else
-#if defined(CONFIG_PCI)
-#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL		\
+	 #if defined(CONFIG_PCI)
+   	 	#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL		\
 				| CFG_CMD_PCI		\
 				| CFG_CMD_PING		\
+				| CFG_CMD_ASKENV	\
 				| CFG_CMD_I2C)
-#else
-#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL		\
+	#else
+		#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL		\
 				| CFG_CMD_PING		\
+				| CFG_CMD_ASKENV	\
 				| CFG_CMD_I2C       \
 				| CFG_CMD_MII       \
 				)
-#endif
+	#endif
 #endif
 
 #include <cmd_confdefs.h>
@@ -506,16 +532,65 @@
 	HRCWH_TSEC2M_IN_GMII )
 #endif
 
-#define CFG_HID0_INIT 0x000000000
 
-#define CFG_HID0_FINAL CFG_HID0_INIT
-
-/* #define CFG_HID0_FINAL		(\
-	HID0_ENABLE_INSTRUCTION_CACHE |\
-	HID0_ENABLE_M_BIT |\
-	HID0_ENABLE_ADDRESS_BROADCAST ) */
+/* DDR: icache cacheable, but dcache-inhibit and guarded */
+#define CFG_IBAT0L	(CFG_SDRAM_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT0U	(CFG_SDRAM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CFG_DBAT0L	(CFG_SDRAM_BASE | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_DBAT0U	CFG_IBAT0U
+
+/* IMMRBAR: cache-inhibit and guarded */
+#define CFG_IBAT1L	(CFG_IMMRBAR | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT1U	(CFG_IMMRBAR | BATU_BL_1M | BATU_VS | BATU_VP)
+#define CFG_DBAT1L	CFG_IBAT1L
+#define CFG_DBAT1U	CFG_IBAT1U
+
+/* BCSR: cache-inhibit and guarded */
+#define CFG_IBAT2L	(CFG_BCSR | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT2U	(CFG_BCSR | BATU_BL_128K | BATU_VS | BATU_VP)
+#define CFG_DBAT2L	CFG_IBAT2L
+#define CFG_DBAT2U	CFG_IBAT2U
+
+/* FLASH: icache cacheable, but dcache-inhibit and guarded */
+#define CFG_IBAT3L	(CFG_FLASH_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT3U	(CFG_FLASH_BASE | BATU_BL_32M | BATU_VS | BATU_VP)
+#define CFG_DBAT3L	(CFG_FLASH_BASE | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_DBAT3U	CFG_IBAT3U
+
+/* Local bus SDRAM: cacheable */
+#define CFG_IBAT4L	(CFG_LBC_SDRAM_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT4U	(CFG_LBC_SDRAM_BASE | BATU_BL_64M | BATU_VS | BATU_VP)
+#define CFG_DBAT4L	CFG_IBAT4L
+#define CFG_DBAT4U	CFG_IBAT4U
+
+/* Stack in dcache: cacheable, no memory coherence */
+#define CFG_IBAT5L	(CFG_INIT_RAM_ADDR | BATL_PP_10)
+#define CFG_IBAT5U	(CFG_INIT_RAM_ADDR | BATU_BL_128K | BATU_VS | BATU_VP)
+#define CFG_DBAT5L	CFG_IBAT5L
+#define CFG_DBAT5U	CFG_IBAT5U
+
+#ifdef CONFIG_PCI
+/* PCI MEM space: cacheable */
+#define CFG_IBAT6L	(CFG_PCI1_MEM_PHYS | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT6U	(CFG_PCI1_MEM_PHYS | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CFG_DBAT6L	CFG_IBAT6L
+#define CFG_DBAT6U	CFG_IBAT6U
+/* PCI IO space: cache-inhibit and guarded */
+#define CFG_IBAT7L	(CFG_PCI1_IO_PHYS | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT7U	(CFG_PCI1_IO_PHYS | BATU_BL_16M | BATU_VS | BATU_VP)
+#define CFG_DBAT7L	CFG_IBAT7L
+#define CFG_DBAT7U	CFG_IBAT7U
+#else
+#define CFG_IBAT6L	(0)
+#define CFG_IBAT6U	(0)
+#define CFG_IBAT7L	(0)
+#define CFG_IBAT7U	(0)
+#define CFG_DBAT6L	CFG_IBAT6L
+#define CFG_DBAT6U	CFG_IBAT6U
+#define CFG_DBAT7L	CFG_IBAT7L
+#define CFG_DBAT7U	CFG_IBAT7U
+#endif
 
-#define CFG_HID2 0x000000000
 
 /*
  * Internal Definitions
@@ -530,6 +605,7 @@
 #define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
 #endif
 
+
 /*
  * Environment Configuration
  */
@@ -540,14 +616,14 @@
 #define CONFIG_ETH1ADDR  00:E0:0C:00:7D:01
 #endif
 
-#define CONFIG_IPADDR    192.168.1.253
+#define CONFIG_IPADDR    10.193.20.150
 
 #define CONFIG_HOSTNAME	 unknown
-#define CONFIG_ROOTPATH	 /nfsroot
-#define CONFIG_BOOTFILE	 your.uImage
+#define CONFIG_ROOTPATH	 /tftpboot/10.193.20.150
+#define CONFIG_BOOTFILE	 /tftpboot/vmlinux.150
 
-#define CONFIG_SERVERIP  192.168.1.1
-#define CONFIG_GATEWAYIP 192.168.1.1
+#define CONFIG_SERVERIP  10.193.20.58
+#define CONFIG_GATEWAYIP 10.193.20.254
 #define CONFIG_NETMASK   255.255.255.0
 
 #define CONFIG_LOADADDR  200000	/* default location for tftp and bootm */
@@ -558,27 +634,39 @@
 #define CONFIG_BAUDRATE	 115200
 
 
-#define	CONFIG_EXTRA_ENV_SETTINGS			\
-	"netdev=eth0\0"					\
-	"consoledev=ttyS0\0"				\
-	"ramdiskaddr=400000\0"				\
-	"ramdiskfile=ramfs.83xx\0"
-
-#define CONFIG_NFSBOOTCOMMAND				\
-	"setenv bootargs root=/dev/nfs rw "		\
-	"nfsroot=$serverip:$rootpath "			\
-	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
-	"console=$consoledev,$baudrate $othbootargs;"	\
-	"tftp $loadaddr $bootfile;"			\
-	"bootm $loadaddr"
-
-#define CONFIG_RAMBOOTCOMMAND				\
-	"setenv bootargs root=/dev/ram rw "		\
-	"console=$consoledev,$baudrate $othbootargs;"	\
-	"tftp $ramdiskaddr $ramdiskfile;"		\
-	"tftp $loadaddr $bootfile;"			\
-	"bootm $loadaddr $ramdiskaddr"
-
+#define	CONFIG_EXTRA_ENV_SETTINGS		                        \
+   "netdev=eth0\0"                                                      \
+   "consoledev=ttyS0\0"                                                 \
+   "ramdiskaddr=400000\0"			                        \
+   "ramdiskfile=ramfs.83xx\0"						\
+
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr"
+
+#define CONFIG_RAMBOOTCOMMAND \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+#define CONFIG_PREBOOT \
+   "echo ======================NOTICE============================;"    \
+   "echo This is the first time that you boot up this board. You are;"  \
+   "echo required to set a valid MAC address for your Ethernet interface.;"\
+   "echo MAKE SURE YOUR MAC ADDRESS IS CORRECTLY ENTERED!;"      \
+   "echo You can always change it by using setenv ethaddr {MAC address};" \
+   "echo to change it again.;"                                         \
+   "askenv ethaddr 'Please enter your MAC address:' 17;"               \
+   "setenv preboot;"                                                   \
+   "printenv ethaddr;" \
+   "saveenv;"
+                                                                                                                             
 #define CONFIG_BOOTCOMMAND CONFIG_NFSBOOTCOMMAND
 
 #endif	/* __CONFIG_H */
diff -urN u-boot-temp/include/mpc8349.h u-boot-1.1.3/include/mpc8349.h
--- u-boot-temp/include/mpc8349.h	1969-12-31 18:00:00.000000000 -0600
+++ u-boot-1.1.3/include/mpc8349.h	2006-05-16 18:27:19.000000000 -0500
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2004-2006 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Change log:
+ * 20050101: Eran Liberty (liberty@freescale.com)
+ *           Initial file creating (porting from 85XX & 8260)
+ */
+
+/*
+ * mpc8349.h
+ *
+ * MPC8349 specific definitions
+ */
+
+#ifndef __MPC8349_H__
+#define __MPC8349_H__
+
+#if defined(CONFIG_E300)
+#include <asm/e300.h>
+#endif
+
+/*
+ *MPC83xx cpu provide RCR register to do reset thing specially. easier to implement
+ */
+#define MPC83xx_RESET
+
+/*
+ * System reset offset (PowerPC standard)
+ */
+#define EXC_OFF_SYS_RESET	0x0100
+
+/*
+ * Default Internal Memory Register Space (Freescale recomandation)
+ */
+#define CONFIG_DEFAULT_IMMR 0xFF400000
+
+/*
+ * Watchdog
+ */
+#define SWCRR      0x0204
+#define SWCRR_SWTC 0xFFFF0000 /* Software Watchdog Time Count. */
+#define SWCRR_SWEN 0x00000004 /* Watchdog Enable bit. */
+#define SWCRR_SWRI 0x00000002 /* Software Watchdog Reset/Interrupt Select bit. */
+#define SWCRR_SWPR 0x00000001 /* Software Watchdog Counter Prescale bit. */
+#define SWCRR_RES  ~(SWCRR_SWTC | SWCRR_SWEN | SWCRR_SWRI | SWCRR_SWPR)
+
+#define SWCNR      0x0208
+#define SWCNR_SWCN 0x0000FFFF Software Watchdog Count Field.
+#define SWCNR_RES  ~(SWCNR_SWCN)
+
+#define SWSRR      0x020E
+
+/*
+ * Default Internal Memory Register Space (Freescale recomandation)
+ */
+#define IMMRBAR 0x0000
+
+/* Identifies the 12 most-significant address bits of the base of the 1 MByte internal memory window. */
+#define IMMRBAR_BASE_ADDR     0xFFF00000
+
+#define IMMRBAR_RES           ~(IMMRBAR_BASE_ADDR)
+
+/*
+ * Default Internal Memory Register Space (Freescale recomandation)
+ */
+#define LBLAWBAR0 0x0020
+#define LBLAWAR0  0x0024
+#define LBLAWBAR1 0x0028
+#define LBLAWAR1  0x002C
+#define LBLAWBAR2 0x0030
+#define LBLAWAR2  0x0034
+#define LBLAWBAR3 0x0038
+#define LBLAWAR3  0x003C
+
+/*
+ * The device ID and revision numbers
+ */
+#define SPR_8349E_REV10 0x80300100
+#define SPR_8349_REV10 0x80310100
+#define SPR_8347E_REV10_TBGA 0x80320100
+#define SPR_8347_REV10_TBGA 0x80330100
+#define SPR_8347E_REV10_PBGA 0x80340100
+#define SPR_8347_REV10_PBGA 0x80350100
+#define SPR_8343E_REV10 0x80360100
+#define SPR_8343_REV10 0x80370100
+
+#define SPR_8349E_REV11 0x80300101
+#define SPR_8349_REV11 0x80310101
+#define SPR_8347E_REV11_TBGA 0x80320101
+#define SPR_8347_REV11_TBGA 0x80330101
+#define SPR_8347E_REV11_PBGA 0x80340101
+#define SPR_8347_REV11_PBGA 0x80350101
+#define SPR_8343E_REV11 0x80360101
+#define SPR_8343_REV11 0x80370101
+
+/*
+ * Base Registers & Option Registers
+ */
+#define BR0 0x5000
+#define BR1 0x5008
+#define BR2 0x5010
+#define BR3 0x5018
+#define BR4 0x5020
+#define BR5 0x5028
+#define BR6 0x5030
+#define BR7 0x5038
+
+#define BR_BA   0xFFFF8000
+#define BR_BA_SHIFT     15
+#define BR_PS   0x00001800
+#define BR_PS_SHIFT     11
+#define BR_DECC 0x00000600
+#define BR_DECC_SHIFT    9
+#define BR_WP   0x00000100
+#define BR_WP_SHIFT      8
+#define BR_MSEL 0x000000E0
+#define BR_MSEL_SHIFT    5
+#define BR_V    0x00000001
+#define BR_V_SHIFT       0
+#define BR_RES  ~(BR_BA|BR_PS|BR_DECC|BR_WP|BR_MSEL|BR_V)
+
+#define OR0 0x5004
+#define OR1 0x500C
+#define OR2 0x5014
+#define OR3 0x501C
+#define OR4 0x5024
+#define OR5 0x502C
+#define OR6 0x5034
+#define OR7 0x503C
+
+#define OR_GPCM_AM    0xFFFF8000
+#define OR_GPCM_AM_SHIFT      15
+#define OR_GPCM_BCTLD 0x00001000
+#define OR_GPCM_BCTLD_SHIFT   12
+#define OR_GPCM_CSNT  0x00000800
+#define OR_GPCM_CSNT_SHIFT    11
+#define OR_GPCM_ACS   0x00000600
+#define OR_GPCM_ACS_SHIFT      9
+#define OR_GPCM_XACS  0x00000100
+#define OR_GPCM_XACS_SHIFT     8
+#define OR_GPCM_SCY   0x000000F0
+#define OR_GPCM_SCY_SHIFT      4
+#define OR_GPCM_SETA  0x00000008
+#define OR_GPCM_SETA_SHIFT     3
+#define OR_GPCM_TRLX  0x00000004
+#define OR_GPCM_TRLX_SHIFT     2
+#define OR_GPCM_EHTR  0x00000002
+#define OR_GPCM_EHTR_SHIFT     1
+#define OR_GPCM_EAD   0x00000001
+#define OR_GPCM_EAD_SHIFT      0
+
+#define OR_UPM_AM    0xFFFF8000
+#define OR_UPM_AM_SHIFT      15
+#define OR_UPM_XAM   0x00006000
+#define OR_UPM_XAM_SHIFT     13
+#define OR_UPM_BCTLD 0x00001000
+#define OR_UPM_BCTLD_SHIFT   12
+#define OR_UPM_BI    0x00000100
+#define OR_UPM_BI_SHIFT       8
+#define OR_UPM_TRLX  0x00000004
+#define OR_UPM_TRLX_SHIFT     2
+#define OR_UPM_EHTR  0x00000002
+#define OR_UPM_EHTR_SHIFT     1
+#define OR_UPM_EAD   0x00000001
+#define OR_UPM_EAD_SHIFT      0
+
+#define OR_SDRAM_AM    0xFFFF8000
+#define OR_SDRAM_AM_SHIFT      15
+#define OR_SDRAM_XAM   0x00006000
+#define OR_SDRAM_XAM_SHIFT     13
+#define OR_SDRAM_COLS  0x00001C00
+#define OR_SDRAM_COLS_SHIFT    10
+#define OR_SDRAM_ROWS  0x000001C0
+#define OR_SDRAM_ROWS_SHIFT     6
+#define OR_SDRAM_PMSEL 0x00000020
+#define OR_SDRAM_PMSEL_SHIFT    5
+#define OR_SDRAM_EAD   0x00000001
+#define OR_SDRAM_EAD_SHIFT      0
+
+/*
+ * Hard Reset Configration Word - High
+ */
+#define HRCWH_PCI_AGENT              0x00000000
+#define HRCWH_PCI_HOST               0x80000000
+
+#define HRCWH_32_BIT_PCI             0x00000000
+#define HRCWH_64_BIT_PCI             0x40000000
+
+#define HRCWH_PCI1_ARBITER_DISABLE   0x00000000
+#define HRCWH_PCI1_ARBITER_ENABLE    0x20000000
+
+#define HRCWH_PCI2_ARBITER_DISABLE   0x00000000
+#define HRCWH_PCI2_ARBITER_ENABLE    0x10000000
+
+#define HRCWH_CORE_DISABLE           0x08000000
+#define HRCWH_CORE_ENABLE            0x00000000
+
+#define HRCWH_FROM_0X00000100        0x00000000
+#define HRCWH_FROM_0XFFF00100        0x04000000
+
+#define HRCWH_BOOTSEQ_DISABLE        0x00000000
+#define HRCWH_BOOTSEQ_NORMAL         0x01000000
+#define HRCWH_BOOTSEQ_EXTENDED       0x02000000
+
+#define HRCWH_SW_WATCHDOG_DISABLE    0x00000000
+#define HRCWH_SW_WATCHDOG_ENABLE     0x00800000
+
+#define HRCWH_ROM_LOC_DDR_SDRAM      0x00000000
+#define HRCWH_ROM_LOC_PCI1           0x00100000
+#define HRCWH_ROM_LOC_PCI2           0x00200000
+#define HRCWH_ROM_LOC_LOCAL_8BIT     0x00500000
+#define HRCWH_ROM_LOC_LOCAL_16BIT    0x00600000
+#define HRCWH_ROM_LOC_LOCAL_32BIT    0x00700000
+
+#define HRCWH_TSEC1M_IN_RGMII        0x00000000
+#define HRCWH_TSEC1M_IN_RTBI         0x00004000
+#define HRCWH_TSEC1M_IN_GMII         0x00008000
+#define HRCWH_TSEC1M_IN_TBI          0x0000C000
+
+#define HRCWH_TSEC2M_IN_RGMII        0x00000000
+#define HRCWH_TSEC2M_IN_RTBI         0x00001000
+#define HRCWH_TSEC2M_IN_GMII         0x00002000
+#define HRCWH_TSEC2M_IN_TBI          0x00003000
+
+#define HRCWH_BIG_ENDIAN             0x00000000
+#define HRCWH_LITTLE_ENDIAN          0x00000008
+
+/*
+ * Hard Reset Configration Word - Low
+ */
+#define HRCWL_LCL_BUS_TO_SCB_CLK_1X1 0x00000000
+#define HRCWL_LCL_BUS_TO_SCB_CLK_2X1 0x80000000
+
+#define HRCWL_DDR_TO_SCB_CLK_1X1     0x00000000
+#define HRCWL_DDR_TO_SCB_CLK_2X1     0x40000000
+
+#define HRCWL_CSB_TO_CLKIN_16X1      0x00000000
+#define HRCWL_CSB_TO_CLKIN_1X1       0x01000000
+#define HRCWL_CSB_TO_CLKIN_2X1       0x02000000
+#define HRCWL_CSB_TO_CLKIN_3X1       0x03000000
+#define HRCWL_CSB_TO_CLKIN_4X1       0x04000000
+#define HRCWL_CSB_TO_CLKIN_5X1       0x05000000
+#define HRCWL_CSB_TO_CLKIN_6X1       0x06000000
+#define HRCWL_CSB_TO_CLKIN_7X1       0x07000000
+#define HRCWL_CSB_TO_CLKIN_8X1       0x08000000
+#define HRCWL_CSB_TO_CLKIN_9X1       0x09000000
+#define HRCWL_CSB_TO_CLKIN_10X1      0x0A000000
+#define HRCWL_CSB_TO_CLKIN_11X1      0x0B000000
+#define HRCWL_CSB_TO_CLKIN_12X1      0x0C000000
+#define HRCWL_CSB_TO_CLKIN_13X1      0x0D000000
+#define HRCWL_CSB_TO_CLKIN_14X1      0x0E000000
+#define HRCWL_CSB_TO_CLKIN_15X1      0x0F000000
+
+#define HRCWL_VCO_BYPASS             0x00000000
+#define HRCWL_VCO_1X2                0x00000000
+#define HRCWL_VCO_1X4                0x00200000
+#define HRCWL_VCO_1X8                0x00400000
+
+#define HRCWL_CORE_TO_CSB_BYPASS     0x00000000
+#define HRCWL_CORE_TO_CSB_1X1        0x00020000
+#define HRCWL_CORE_TO_CSB_1_5X1      0x00030000
+#define HRCWL_CORE_TO_CSB_2X1        0x00040000
+#define HRCWL_CORE_TO_CSB_2_5X1      0x00050000
+#define HRCWL_CORE_TO_CSB_3X1        0x00060000
+
+/*
+ * LCRR - Clock Ratio Register (10.3.1.16) 
+ */
+#define LCRR_DBYP      0x80000000
+#define LCRR_DBYP_SHIFT        31
+#define LCRR_BUFCMDC   0x30000000
+#define LCRR_BUFCMDC_1 0x10000000
+#define LCRR_BUFCMDC_2 0x20000000
+#define LCRR_BUFCMDC_3 0x30000000
+#define LCRR_BUFCMDC_4 0x00000000
+#define LCRR_BUFCMDC_SHIFT     28
+#define LCRR_ECL       0x03000000
+#define LCRR_ECL_4     0x00000000
+#define LCRR_ECL_5     0x01000000
+#define LCRR_ECL_6     0x02000000
+#define LCRR_ECL_7     0x03000000
+#define LCRR_ECL_SHIFT         24
+#define LCRR_EADC      0x00030000
+#define LCRR_EADC_1    0x00010000
+#define LCRR_EADC_2    0x00020000
+#define LCRR_EADC_3    0x00030000
+#define LCRR_EADC_4    0x00000000
+#define LCRR_EADC_SHIFT        16
+#define LCRR_CLKDIV    0x0000000F
+#define LCRR_CLKDIV_2  0x00000002
+#define LCRR_CLKDIV_4  0x00000004
+#define LCRR_CLKDIV_8  0x00000008
+#define LCRR_CLKDIV_SHIFT       0
+ 
+/*
+ * SCCR-System Clock Control Register
+ */
+#define SCCR_TSEC1CM_0	0x00000000
+#define SCCR_TSEC1CM_1	0x40000000
+#define SCCR_TSEC1CM_2	0x80000000
+#define SCCR_TSEC1CM_3	0xC0000000
+#define SCCR_TSEC2CM_0	0x00000000
+#define SCCR_TSEC2CM_1	0x10000000
+#define SCCR_TSEC2CM_2	0x20000000
+#define SCCR_TSEC2CM_3	0x30000000
+#define SCCR_ENCCM_0	0x00000000
+#define SCCR_ENCCM_1	0x01000000
+#define SCCR_ENCCM_2	0x02000000
+#define SCCR_ENCCM_3	0x03000000
+#define SCCR_USBCM_0	0x00000000
+#define SCCR_USBCM_1	0x00500000
+#define SCCR_USBCM_2	0x00A00000
+#define SCCR_USBCM_3	0x00F00000
+
+#define SCCR_CLK_MASK	( SCCR_TSEC1CM_3	\
+			| SCCR_TSEC2CM_3	\
+			| SCCR_ENCCM_3		\
+			| SCCR_USBCM_3		)
+
+#define SCCR_DEFAULT	0xFFFFFFFF
+
+#endif	/* __MPC83XX_H__ */
diff -urN u-boot-temp/net/eth.c u-boot-1.1.3/net/eth.c
--- u-boot-temp/net/eth.c	2005-08-13 18:53:35.000000000 -0500
+++ u-boot-1.1.3/net/eth.c	2006-05-16 18:16:43.000000000 -0500
@@ -156,28 +156,26 @@
 #endif
 #if defined(CONFIG_MPC85XX_TSEC1)
 	tsec_initialize(bis, 0, CONFIG_MPC85XX_TSEC1_NAME);
-#elif defined(CONFIG_MPC83XX_TSEC1)
-	tsec_initialize(bis, 0, CONFIG_MPC83XX_TSEC1_NAME);
 #endif
 #if defined(CONFIG_MPC85XX_TSEC2)
 	tsec_initialize(bis, 1, CONFIG_MPC85XX_TSEC2_NAME);
-#elif defined(CONFIG_MPC83XX_TSEC2)
-	tsec_initialize(bis, 1, CONFIG_MPC83XX_TSEC2_NAME);
 #endif
 #if defined(CONFIG_MPC85XX_FEC)
 	tsec_initialize(bis, 2, CONFIG_MPC85XX_FEC_NAME);
 #else
 #    if defined(CONFIG_MPC85XX_TSEC3)
 	tsec_initialize(bis, 2, CONFIG_MPC85XX_TSEC3_NAME);
-#    elif defined(CONFIG_MPC83XX_TSEC3)
-	tsec_initialize(bis, 2, CONFIG_MPC83XX_TSEC3_NAME);
 #    endif
 #    if defined(CONFIG_MPC85XX_TSEC4)
 	tsec_initialize(bis, 3, CONFIG_MPC85XX_TSEC4_NAME);
-#    elif defined(CONFIG_MPC83XX_TSEC4)
-	tsec_initialize(bis, 3, CONFIG_MPC83XX_TSEC4_NAME);
 #    endif
 #endif
+#if defined(CONFIG_MPC83XX_TSEC1)
+	tsec_initialize(bis, 0, CONFIG_MPC83XX_TSEC1_NAME);
+#endif
+#if defined(CONFIG_MPC83XX_TSEC2)
+	tsec_initialize(bis, 1, CONFIG_MPC83XX_TSEC2_NAME);
+#endif
 #if defined(CONFIG_AU1X00)
 	au1x00_enet_initialize(bis);
 #endif




Patch: Fix phy_read/write redefinition errors in ucc_geth_phy.c
Submitter Timur Tabi 
Date 2006-12-14 04:39:09 
Message ID <11660315492978-git-send-email-timur@freescale.com> 
Download Fix phy_read/write redefinition errors in ucc_geth_phy.c.patch 
State Accepted 
Trees  


prev - back to list - next
Comments
Timur Tabi 2006-12-14 04:39:09
From: Timur Tabi <timur@freescale.com>

The local versions of phy_read() and phy_write() in ucc_geth_phy.c conflict
with the prototypes in include/linux/phy.h, so this patch renames them, 
moves them to the top of the file (while eliminating the redundant prototype),
and makes them static.

Signed-off-by: Timur Tabi <timur@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

---
 drivers/net/ucc_geth_phy.c |  134 ++++++++++++++++++++++----------------------
 1 files changed, 66 insertions(+), 68 deletions(-)

-- 
1.4.4Paul Mackerras 2006-12-19 16:51:16
timur@freescale.com writes:

> The local versions of phy_read() and phy_write() in ucc_geth_phy.c conflict
> with the prototypes in include/linux/phy.h, so this patch renames them, 
> moves them to the top of the file (while eliminating the redundant prototype),
> and makes them static.

You really need to send this patch to Jeff Garzik and the netdev
list.  If the driver won't compile in its current state in Linus' tree
because of the problem this fixes, make sure you make that point in
the patch commentary and explicitly ask Jeff to get the patch into
2.6.20.

Paul.Kumar Gala 2006-12-20 03:15:17
On Dec 18, 2006, at 11:51 PM, Paul Mackerras wrote:

> timur@freescale.com writes:
>
>> The local versions of phy_read() and phy_write() in ucc_geth_phy.c  
>> conflict
>> with the prototypes in include/linux/phy.h, so this patch renames  
>> them,
>> moves them to the top of the file (while eliminating the redundant  
>> prototype),
>> and makes them static.
>
> You really need to send this patch to Jeff Garzik and the netdev
> list.  If the driver won't compile in its current state in Linus' tree
> because of the problem this fixes, make sure you make that point in
> the patch commentary and explicitly ask Jeff to get the patch into
> 2.6.20.

I pretty much did this yesterday, so hopefully Jeff will pick up the  
patches and push them to linus with his next set of fixes for 2.6.20.

- kPatch
diff --git a/drivers/net/ucc_geth_phy.c b/drivers/net/ucc_geth_phy.c
index 5360ec0..3c86592 100644
--- a/drivers/net/ucc_geth_phy.c
+++ b/drivers/net/ucc_geth_phy.c
@@ -68,8 +68,31 @@  static int gbit_config_aneg(struct ugeth
 static int genmii_config_aneg(struct ugeth_mii_info *mii_info);
 static int genmii_update_link(struct ugeth_mii_info *mii_info);
 static int genmii_read_status(struct ugeth_mii_info *mii_info);
-u16 phy_read(struct ugeth_mii_info *mii_info, u16 regnum);
-void phy_write(struct ugeth_mii_info *mii_info, u16 regnum, u16 val);
+
+static u16 ucc_geth_phy_read(struct ugeth_mii_info *mii_info, u16 regnum)
+{
+	u16 retval;
+	unsigned long flags;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irqsave(&mii_info->mdio_lock, flags);
+	retval = mii_info->mdio_read(mii_info->dev, mii_info->mii_id, regnum);
+	spin_unlock_irqrestore(&mii_info->mdio_lock, flags);
+
+	return retval;
+}
+
+static void ucc_geth_phy_write(struct ugeth_mii_info *mii_info, u16 regnum, u16 val)
+{
+	unsigned long flags;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irqsave(&mii_info->mdio_lock, flags);
+	mii_info->mdio_write(mii_info->dev, mii_info->mii_id, regnum, val);
+	spin_unlock_irqrestore(&mii_info->mdio_lock, flags);
+}
 
 /* Write value to the PHY for this device to the register at regnum, */
 /* waiting until the write is done before it returns.  All PHY */
@@ -184,7 +207,7 @@  static void config_genmii_advert(struct
 	advertise = mii_info->advertising;
 
 	/* Setup standard advertisement */
-	adv = phy_read(mii_info, MII_ADVERTISE);
+	adv = ucc_geth_phy_read(mii_info, MII_ADVERTISE);
 	adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
 	if (advertise & ADVERTISED_10baseT_Half)
 		adv |= ADVERTISE_10HALF;
@@ -194,7 +217,7 @@  static void config_genmii_advert(struct
 		adv |= ADVERTISE_100HALF;
 	if (advertise & ADVERTISED_100baseT_Full)
 		adv |= ADVERTISE_100FULL;
-	phy_write(mii_info, MII_ADVERTISE, adv);
+	ucc_geth_phy_write(mii_info, MII_ADVERTISE, adv);
 }
 
 static void genmii_setup_forced(struct ugeth_mii_info *mii_info)
@@ -204,7 +227,7 @@  static void genmii_setup_forced(struct u
 
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
-	ctrl = phy_read(mii_info, MII_BMCR);
+	ctrl = ucc_geth_phy_read(mii_info, MII_BMCR);
 
 	ctrl &=
 	    ~(BMCR_FULLDPLX | BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);
@@ -234,7 +257,7 @@  static void genmii_setup_forced(struct u
 		break;
 	}
 
-	phy_write(mii_info, MII_BMCR, ctrl);
+	ucc_geth_phy_write(mii_info, MII_BMCR, ctrl);
 }
 
 /* Enable and Restart Autonegotiation */
@@ -244,9 +267,9 @@  static void genmii_restart_aneg(struct u
 
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
-	ctl = phy_read(mii_info, MII_BMCR);
+	ctl = ucc_geth_phy_read(mii_info, MII_BMCR);
 	ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
-	phy_write(mii_info, MII_BMCR, ctl);
+	ucc_geth_phy_write(mii_info, MII_BMCR, ctl);
 }
 
 static int gbit_config_aneg(struct ugeth_mii_info *mii_info)
@@ -261,14 +284,14 @@  static int gbit_config_aneg(struct ugeth
 		config_genmii_advert(mii_info);
 		advertise = mii_info->advertising;
 
-		adv = phy_read(mii_info, MII_1000BASETCONTROL);
+		adv = ucc_geth_phy_read(mii_info, MII_1000BASETCONTROL);
 		adv &= ~(MII_1000BASETCONTROL_FULLDUPLEXCAP |
 			 MII_1000BASETCONTROL_HALFDUPLEXCAP);
 		if (advertise & SUPPORTED_1000baseT_Half)
 			adv |= MII_1000BASETCONTROL_HALFDUPLEXCAP;
 		if (advertise & SUPPORTED_1000baseT_Full)
 			adv |= MII_1000BASETCONTROL_FULLDUPLEXCAP;
-		phy_write(mii_info, MII_1000BASETCONTROL, adv);
+		ucc_geth_phy_write(mii_info, MII_1000BASETCONTROL, adv);
 
 		/* Start/Restart aneg */
 		genmii_restart_aneg(mii_info);
@@ -298,10 +321,10 @@  static int genmii_update_link(struct uge
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	/* Do a fake read */
-	phy_read(mii_info, MII_BMSR);
+	ucc_geth_phy_read(mii_info, MII_BMSR);
 
 	/* Read link and autonegotiation status */
-	status = phy_read(mii_info, MII_BMSR);
+	status = ucc_geth_phy_read(mii_info, MII_BMSR);
 	if ((status & BMSR_LSTATUS) == 0)
 		mii_info->link = 0;
 	else
@@ -329,7 +352,7 @@  static int genmii_read_status(struct uge
 		return err;
 
 	if (mii_info->autoneg) {
-		status = phy_read(mii_info, MII_LPA);
+		status = ucc_geth_phy_read(mii_info, MII_LPA);
 
 		if (status & (LPA_10FULL | LPA_100FULL))
 			mii_info->duplex = DUPLEX_FULL;
@@ -352,9 +375,9 @@  static int marvell_init(struct ugeth_mii
 {
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
-	phy_write(mii_info, 0x14, 0x0cd2);
-	phy_write(mii_info, MII_BMCR,
-		  phy_read(mii_info, MII_BMCR) | BMCR_RESET);
+	ucc_geth_phy_write(mii_info, 0x14, 0x0cd2);
+	ucc_geth_phy_write(mii_info, MII_BMCR,
+		  ucc_geth_phy_read(mii_info, MII_BMCR) | BMCR_RESET);
 	msleep(4000);
 
 	return 0;
@@ -367,13 +390,13 @@  static int marvell_config_aneg(struct ug
 	/* The Marvell PHY has an errata which requires
 	 * that certain registers get written in order
 	 * to restart autonegotiation */
-	phy_write(mii_info, MII_BMCR, BMCR_RESET);
+	ucc_geth_phy_write(mii_info, MII_BMCR, BMCR_RESET);
 
-	phy_write(mii_info, 0x1d, 0x1f);
-	phy_write(mii_info, 0x1e, 0x200c);
-	phy_write(mii_info, 0x1d, 0x5);
-	phy_write(mii_info, 0x1e, 0);
-	phy_write(mii_info, 0x1e, 0x100);
+	ucc_geth_phy_write(mii_info, 0x1d, 0x1f);
+	ucc_geth_phy_write(mii_info, 0x1e, 0x200c);
+	ucc_geth_phy_write(mii_info, 0x1d, 0x5);
+	ucc_geth_phy_write(mii_info, 0x1e, 0);
+	ucc_geth_phy_write(mii_info, 0x1e, 0x100);
 
 	gbit_config_aneg(mii_info);
 
@@ -398,7 +421,7 @@  static int marvell_read_status(struct ug
 	 * are as set */
 	if (mii_info->autoneg && mii_info->link) {
 		int speed;
-		status = phy_read(mii_info, MII_M1011_PHY_SPEC_STATUS);
+		status = ucc_geth_phy_read(mii_info, MII_M1011_PHY_SPEC_STATUS);
 
 		/* Get the duplexity */
 		if (status & MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX)
@@ -430,7 +453,7 @@  static int marvell_ack_interrupt(struct
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	/* Clear the interrupts by reading the reg */
-	phy_read(mii_info, MII_M1011_IEVENT);
+	ucc_geth_phy_read(mii_info, MII_M1011_IEVENT);
 
 	return 0;
 }
@@ -440,9 +463,9 @@  static int marvell_config_intr(struct ug
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	if (mii_info->interrupts == MII_INTERRUPT_ENABLED)
-		phy_write(mii_info, MII_M1011_IMASK, MII_M1011_IMASK_INIT);
+		ucc_geth_phy_write(mii_info, MII_M1011_IMASK, MII_M1011_IMASK_INIT);
 	else
-		phy_write(mii_info, MII_M1011_IMASK, MII_M1011_IMASK_CLEAR);
+		ucc_geth_phy_write(mii_info, MII_M1011_IMASK, MII_M1011_IMASK_CLEAR);
 
 	return 0;
 }
@@ -451,9 +474,9 @@  static int cis820x_init(struct ugeth_mii
 {
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
-	phy_write(mii_info, MII_CIS8201_AUX_CONSTAT,
+	ucc_geth_phy_write(mii_info, MII_CIS8201_AUX_CONSTAT,
 		  MII_CIS8201_AUXCONSTAT_INIT);
-	phy_write(mii_info, MII_CIS8201_EXT_CON1, MII_CIS8201_EXTCON1_INIT);
+	ucc_geth_phy_write(mii_info, MII_CIS8201_EXT_CON1, MII_CIS8201_EXTCON1_INIT);
 
 	return 0;
 }
@@ -477,7 +500,7 @@  static int cis820x_read_status(struct ug
 	if (mii_info->autoneg && mii_info->link) {
 		int speed;
 
-		status = phy_read(mii_info, MII_CIS8201_AUX_CONSTAT);
+		status = ucc_geth_phy_read(mii_info, MII_CIS8201_AUX_CONSTAT);
 		if (status & MII_CIS8201_AUXCONSTAT_DUPLEX)
 			mii_info->duplex = DUPLEX_FULL;
 		else
@@ -505,7 +528,7 @@  static int cis820x_ack_interrupt(struct
 {
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
-	phy_read(mii_info, MII_CIS8201_ISTAT);
+	ucc_geth_phy_read(mii_info, MII_CIS8201_ISTAT);
 
 	return 0;
 }
@@ -515,9 +538,9 @@  static int cis820x_config_intr(struct ug
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	if (mii_info->interrupts == MII_INTERRUPT_ENABLED)
-		phy_write(mii_info, MII_CIS8201_IMASK, MII_CIS8201_IMASK_MASK);
+		ucc_geth_phy_write(mii_info, MII_CIS8201_IMASK, MII_CIS8201_IMASK_MASK);
 	else
-		phy_write(mii_info, MII_CIS8201_IMASK, 0);
+		ucc_geth_phy_write(mii_info, MII_CIS8201_IMASK, 0);
 
 	return 0;
 }
@@ -541,7 +564,7 @@  static int dm9161_read_status(struct uge
 	/* If we aren't autonegotiating, assume speeds
 	 * are as set */
 	if (mii_info->autoneg && mii_info->link) {
-		status = phy_read(mii_info, MII_DM9161_SCSR);
+		status = ucc_geth_phy_read(mii_info, MII_DM9161_SCSR);
 		if (status & (MII_DM9161_SCSR_100F | MII_DM9161_SCSR_100H))
 			mii_info->speed = SPEED_100;
 		else
@@ -572,7 +595,7 @@  static void dm9161_timer(unsigned long d
 {
 	struct ugeth_mii_info *mii_info = (struct ugeth_mii_info *)data;
 	struct dm9161_private *priv = mii_info->priv;
-	u16 status = phy_read(mii_info, MII_BMSR);
+	u16 status = ucc_geth_phy_read(mii_info, MII_BMSR);
 
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
@@ -599,11 +622,11 @@  static int dm9161_init(struct ugeth_mii_
 	/* Reset is not done yet */
 	priv->resetdone = 0;
 
-	phy_write(mii_info, MII_BMCR,
-		  phy_read(mii_info, MII_BMCR) | BMCR_RESET);
+	ucc_geth_phy_write(mii_info, MII_BMCR,
+		  ucc_geth_phy_read(mii_info, MII_BMCR) | BMCR_RESET);
 
-	phy_write(mii_info, MII_BMCR,
-		  phy_read(mii_info, MII_BMCR) & ~BMCR_ISOLATE);
+	ucc_geth_phy_write(mii_info, MII_BMCR,
+		  ucc_geth_phy_read(mii_info, MII_BMCR) & ~BMCR_ISOLATE);
 
 	config_genmii_advert(mii_info);
 	/* Start/Restart aneg */
@@ -634,7 +657,7 @@  static int dm9161_ack_interrupt(struct u
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	/* Clear the interrupts by reading the reg */
-	phy_read(mii_info, MII_DM9161_INTR);
+	ucc_geth_phy_read(mii_info, MII_DM9161_INTR);
 
 
 	return 0;
@@ -645,9 +668,9 @@  static int dm9161_config_intr(struct uge
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	if (mii_info->interrupts == MII_INTERRUPT_ENABLED)
-		phy_write(mii_info, MII_DM9161_INTR, MII_DM9161_INTR_INIT);
+		ucc_geth_phy_write(mii_info, MII_DM9161_INTR, MII_DM9161_INTR_INIT);
 	else
-		phy_write(mii_info, MII_DM9161_INTR, MII_DM9161_INTR_STOP);
+		ucc_geth_phy_write(mii_info, MII_DM9161_INTR, MII_DM9161_INTR_STOP);
 
 	return 0;
 }
@@ -718,31 +741,6 @@  static struct phy_info *phy_info[] = {
 	NULL
 };
 
-u16 phy_read(struct ugeth_mii_info *mii_info, u16 regnum)
-{
-	u16 retval;
-	unsigned long flags;
-
-	ugphy_vdbg("%s: IN", __FUNCTION__);
-
-	spin_lock_irqsave(&mii_info->mdio_lock, flags);
-	retval = mii_info->mdio_read(mii_info->dev, mii_info->mii_id, regnum);
-	spin_unlock_irqrestore(&mii_info->mdio_lock, flags);
-
-	return retval;
-}
-
-void phy_write(struct ugeth_mii_info *mii_info, u16 regnum, u16 val)
-{
-	unsigned long flags;
-
-	ugphy_vdbg("%s: IN", __FUNCTION__);
-
-	spin_lock_irqsave(&mii_info->mdio_lock, flags);
-	mii_info->mdio_write(mii_info->dev, mii_info->mii_id, regnum, val);
-	spin_unlock_irqrestore(&mii_info->mdio_lock, flags);
-}
-
 /* Use the PHY ID registers to determine what type of PHY is attached
  * to device dev.  return a struct phy_info structure describing that PHY
  */
@@ -757,11 +755,11 @@  struct phy_info *get_phy_info(struct uge
 	ugphy_vdbg("%s: IN", __FUNCTION__);
 
 	/* Grab the bits from PHYIR1, and put them in the upper half */
-	phy_reg = phy_read(mii_info, MII_PHYSID1);
+	phy_reg = ucc_geth_phy_read(mii_info, MII_PHYSID1);
 	phy_ID = (phy_reg & 0xffff) << 16;
 
 	/* Grab the bits from PHYIR2, and put them in the lower half */
-	phy_reg = phy_read(mii_info, MII_PHYSID2);
+	phy_reg = ucc_geth_phy_read(mii_info, MII_PHYSID2);
 	phy_ID |= (phy_reg & 0xffff);
 
 	/* loop through all the known PHY types, and find one that */
patchwork patch tracking system 


 15 #define MII_BMCR            0x00        /* Basic mode control register */
 16 #define MII_BMSR            0x01        /* Basic mode status register  */
 17 #define MII_PHYSID1         0x02        /* PHYS ID 1                   */
 18 #define MII_PHYSID2         0x03        /* PHYS ID 2                   */
 19 #define MII_ADVERTISE       0x04        /* Advertisement control reg   */
 20 #define MII_LPA             0x05        /* Link partner ability reg    */
 21 #define MII_EXPANSION       0x06        /* Expansion register          */
 22 #define MII_DCOUNTER        0x12        /* Disconnect counter          */
 23 #define MII_FCSCOUNTER      0x13        /* False carrier counter       */
 24 #define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
 25 #define MII_RERRCOUNTER     0x15        /* Receive error counter       */
 26 #define MII_SREVISION       0x16        /* Silicon revision            */
 27 #define MII_RESV1           0x17        /* Reserved...                 */
 28 #define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
 29 #define MII_PHYADDR         0x19        /* PHY address                 */
 30 #define MII_RESV2           0x1a        /* Reserved...                 */
 31 #define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
 32 #define MII_NCONFIG         0x1c        /* Network interface config    */
 33 
 34 /* Basic mode control register. */
 35 #define BMCR_RESV               0x007f  /* Unused...                   */
 36 #define BMCR_CTST               0x0080  /* Collision test              */
 37 #define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
 38 #define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
 39 #define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
 40 #define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
 41 #define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
 42 #define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
 43 #define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
 44 #define BMCR_RESET              0x8000  /* Reset the DP83840           */
 45 
 46 /* Basic mode status register. */
 47 #define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
 48 #define BMSR_JCD                0x0002  /* Jabber detected             */
 49 #define BMSR_LSTATUS            0x0004  /* Link status                 */
 50 #define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
 51 #define BMSR_RFAULT             0x0010  /* Remote fault detected       */
 52 #define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
 53 #define BMSR_RESV               0x07c0  /* Unused...                   */
 54 #define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
 55 #define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
 56 #define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
 57 #define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
 58 #define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
 59 
 60 /* Advertisement control register. */
 61 #define ADVERTISE_SLCT          0x001f  /* Selector bits               */
 62 #define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
 63 #define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
 64 #define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
 65 #define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
 66 #define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
 67 #define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
 68 #define ADVERTISE_RESV          0x1c00  /* Unused...                   */
 69 #define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
 70 #define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
 71 #define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
 72 
 73 #define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
 74                         ADVERTISE_CSMA)
 75 #define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
 76                        ADVERTISE_100HALF | ADVERTISE_100FULL)
 77 
 78 /* Link partner ability register. */
 79 #define LPA_SLCT                0x001f  /* Same as advertise selector  */
 80 #define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
 81 #define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
 82 #define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
 83 #define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
 84 #define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
 85 #define LPA_RESV                0x1c00  /* Unused...                   */
 86 #define LPA_RFAULT              0x2000  /* Link partner faulted        */
 87 #define LPA_LPACK               0x4000  /* Link partner acked us       */
 88 #define LPA_NPAGE               0x8000  /* Next page bit               */
 89 
 90 #define LPA_DUPLEX              (LPA_10FULL | LPA_100FULL)
 91 #define LPA_100                 (LPA_100FULL | LPA_100HALF | LPA_100BASE4)
 92 
 93 /* Expansion register for auto-negotiation. */
 94 #define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
 95 #define EXPANSION_LCWP          0x0002  /* Got new RX page code word   */
 96 #define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
 97 #define EXPANSION_NPCAPABLE     0x0008  /* Link partner supports npage */
 98 #define EXPANSION_MFAULTS       0x0010  /* Multiple faults detected    */
 99 #define EXPANSION_RESV          0xffe0  /* Unused...                   */
100 
101 /* N-way test register. */
102 #define NWAYTEST_RESV1          0x00ff  /* Unused...                   */
103 #define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
104 #define NWAYTEST_RESV2          0xfe00  /* Unused...                   */
105 
106 
